{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Resolver Test Cases Documentation","text":"<p>This documentation provides a comprehensive set of System View Description (SVD) tests designed to test and validate the logical processing capabilities of SVD parsers. The main focus is on handling complex SVD features such as <code>derivedFrom</code>, <code>dim</code>, and other constructs that require parsers to perform logical expansion and complete derivation of data structures. For each test file, an additional expanded version is provided, where the logical processing has already been applied.</p>"},{"location":"test_application_of_default_values.html","title":"test_application_of_default_values","text":"<p>This feature includes tests that verify the parser correctly applies default values to properties not explicitly defined in the SVD file. It ensures the parser adheres to the SVD standard by assigning the appropriate predefined defaults.</p>"},{"location":"test_application_of_default_values.html#tests.test_process.test_application_of_default_values.test_custom_register_properties_on_device_level","title":"<code>test_custom_register_properties_on_device_level</code>","text":"<p>This test ensures that the default values are overwritten if custom values are specified in a processed SVD file on device level.</p> <p>Expected Outcome: The device is processed correctly, with custom register properties specified at the device level overriding the default values. The register size is set to 16 bits, the access type is <code>WRITE_ONLY</code>, the protection type is <code>SECURE</code>, the reset value is <code>0xDEADBEEF</code>, and the reset mask is <code>0xDEADC0DE</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_application_of_default_values.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_custom_register_properties_on_device_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the default values are overwritten if custom values are specified in a processed SVD\n    file on device level.\n\n    **Expected Outcome:** The device is processed correctly, with custom register properties specified at the device\n    level overriding the default values. The register size is set to 16 bits, the access type is `WRITE_ONLY`, the\n    protection type is `SECURE`, the reset value is `0xDEADBEEF`, and the reset mask is `0xDEADC0DE`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"application_of_default_values/custom_register_properties_on_device_level.svd\"\n    )\n\n    assert device.size == 16\n    assert device.access == AccessType.WRITE_ONLY\n    assert device.protection == ProtectionStringType.SECURE\n    assert device.reset_value == 0xDEADBEEF\n    assert device.reset_mask == 0xDEADC0DE\n</code></pre> SVD file: <code>application_of_default_values/custom_register_properties_on_device_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;custom_register_properties_on_device_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;size&gt;16&lt;/size&gt;\n  &lt;access&gt;write-only&lt;/access&gt;\n  &lt;protection&gt;s&lt;/protection&gt;\n  &lt;resetValue&gt;0xDEADBEEF&lt;/resetValue&gt;\n  &lt;resetMask&gt;0xDEADC0DE&lt;/resetMask&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;version&gt;1.0&lt;/version&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_application_of_default_values.html#tests.test_process.test_application_of_default_values.test_default_register_properties_on_device_level","title":"<code>test_default_register_properties_on_device_level</code>","text":"<p>Although not stated in the SVD specification, <code>svdconv</code> assigns default values to size (32), access (read- write), resetValue (0x0), and resetMask (0xFFFFFFFF). This test ensures that the default values are set if they are not specified in a processed SVD file.</p> <p>Expected Outcome: The device is processed correctly, with default register properties applied at the device level. The register size is set to 32 bits, the access type is <code>READ_WRITE</code>, the protection type is <code>ANY</code>, the reset value is <code>0x0</code>, and the reset mask is <code>0xFFFFFFFF</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_application_of_default_values.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_default_register_properties_on_device_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    Although not stated in the SVD specification, `svdconv` assigns default values to size (32), access (read-\n    write), resetValue (0x0), and resetMask (0xFFFFFFFF). This test ensures that the default values are set if\n    they are not specified in a processed SVD file.\n\n    **Expected Outcome:** The device is processed correctly, with default register properties applied at the device\n    level. The register size is set to 32 bits, the access type is `READ_WRITE`, the protection type is `ANY`, the\n    reset value is `0x0`, and the reset mask is `0xFFFFFFFF`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"application_of_default_values/default_register_properties_on_device_level.svd\"\n    )\n\n    assert device.size == 32\n    assert device.access == AccessType.READ_WRITE\n    assert device.protection == ProtectionStringType.ANY\n    assert device.reset_value == 0x0\n    assert device.reset_mask == 0xFFFFFFFF\n</code></pre> SVD file: <code>application_of_default_values/default_register_properties_on_device_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;default_register_properties_on_device_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;version&gt;1.0&lt;/version&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html","title":"test_cluster_inheritance_via_derived_from","text":"<p>For this feature, test cases cover scenarios where a derived cluster inherits properties from a base cluster, ensuring correct behavior when values are inherited.</p>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_alternate_cluster","title":"<code>test_alternate_cluster</code>","text":"<p>This test case assesses the correct handling of the <code>alternateCluster</code> feature in the SVD file, which allows one cluster to act as an alternate version of another. In this scenario, <code>ClusterB</code> is derived from <code>ClusterA</code> and is marked as an alternate cluster by specifying <code>ClusterA</code> in the <code>&lt;alternateCluster&gt;</code> tag. Both clusters share the same address offset (<code>0x0</code>), implying that they can be used interchangeably, depending on the use case.</p> <p>Expected Outcome: The parser should correctly interpret <code>ClusterB</code> as an alternate of <code>ClusterA</code>. It should process the <code>derivedFrom</code> attribute, allowing <code>ClusterB</code> to inherit all characteristics from <code>ClusterA</code>. Additionally, the parser should recognize the <code>&lt;alternateCluster&gt;</code> tag and confirm that <code>ClusterB</code> is designated as an alternate of <code>ClusterA</code>. Both clusters should be treated as residing at the same address offset (<code>0x0</code>), with <code>ClusterA</code> having no <code>alternateCluster</code> association, while <code>ClusterB</code> explicitly references <code>ClusterA</code>. The parsing process should proceed without errors or warnings, consistent with the behavior of <code>svdconv</code>, which correctly handles this feature.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_cluster(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case assesses the correct handling of the `alternateCluster` feature in the SVD file, which allows\n    one cluster to act as an alternate version of another. In this scenario, `ClusterB` is derived from `ClusterA`\n    and is marked as an alternate cluster by specifying `ClusterA` in the `&lt;alternateCluster&gt;` tag. Both clusters\n    share the same address offset (`0x0`), implying that they can be used interchangeably, depending on the use\n    case.\n\n    **Expected Outcome:** The parser should correctly interpret `ClusterB` as an alternate of `ClusterA`. It should\n    process the `derivedFrom` attribute, allowing `ClusterB` to inherit all characteristics from `ClusterA`.\n    Additionally, the parser should recognize the `&lt;alternateCluster&gt;` tag and confirm that `ClusterB` is\n    designated as an alternate of `ClusterA`. Both clusters should be treated as residing at the same address\n    offset (`0x0`), with `ClusterA` having no `alternateCluster` association, while `ClusterB` explicitly\n    references `ClusterA`. The parsing process should proceed without errors or warnings, consistent with the\n    behavior of `svdconv`, which correctly handles this feature.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/alternate_cluster.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].alternate_cluster is None\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].alternate_cluster == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/alternate_cluster.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_cluster&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterA&lt;/alternateCluster&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_circular_inheritance","title":"<code>test_circular_inheritance</code>","text":"<p>This test case examines how the parser handles scenarios where clusters are involved in circular inheritance. In this setup, <code>ClusterA</code>, which is defined first in the SVD file, is set to inherit from <code>ClusterB</code>. Conversely, <code>ClusterB</code> is also configured to inherit from <code>ClusterA</code>. This creates a loop of inheritance, which is logically invalid and should not be allowed. Proper parsing should identify this circular reference and raise an error, preventing further processing. Circular inheritance could lead to infinite loops or unresolved dependencies if not handled correctly.</p> <p>Expected Outcome: The parser should detect the circular inheritance between <code>ClusterA</code> and <code>ClusterB</code> and raise an appropriate error, indicating that circular references are not supported. Unlike some other complex inheritance scenarios, where forward or backward references might be resolved by proper linkage, circular inheritance represents a fundamental logical flaw.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Circular inheritance is not supported\")\ndef test_circular_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines how the parser handles scenarios where clusters are involved in circular inheritance.\n    In this setup, `ClusterA`, which is defined first in the SVD file, is set to inherit from `ClusterB`.\n    Conversely, `ClusterB` is also configured to inherit from `ClusterA`. This creates a loop of inheritance,\n    which is logically invalid and should not be allowed. Proper parsing should identify this circular reference\n    and raise an error, preventing further processing. Circular inheritance could lead to infinite loops or\n    unresolved dependencies if not handled correctly.\n\n    **Expected Outcome:** The parser should detect the circular inheritance between `ClusterA` and `ClusterB` and\n    raise an appropriate error, indicating that circular references are not supported. Unlike some other complex\n    inheritance scenarios, where forward or backward references might be resolved by proper linkage, circular\n    inheritance represents a fundamental logical flaw.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/circular_inheritance.svd\")\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/circular_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;circular_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster derivedFrom=\"ClusterB\"&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_cluster_overlap","title":"<code>test_cluster_overlap</code>","text":"<p>This test case evaluates how the parser handles overlapping clusters within a peripheral, where <code>ClusterB</code> is derived from <code>ClusterA</code> but is assigned an address offset that causes an overlap. In the SVD file, <code>ClusterA</code> is defined at address offset <code>0x0</code> with a size of <code>16</code>, and <code>ClusterB</code>, derived from <code>ClusterA</code>, is placed at address offset <code>0x1</code> with a size of <code>8</code>. This configuration leads to overlapping address ranges for these clusters. While <code>svdconv</code> processes this file without detecting the overlap, this behavior appears to be a bug. Ideally, a parser should issue a warning to alert the user of the overlap, ensuring that any unintended address conflicts are recognized and can be corrected.</p> <p>Expected Outcome: The parser should correctly process the SVD file, identifying both <code>ClusterA</code> and <code>ClusterB</code> while issuing a warning to indicate that their address ranges overlap. Specifically, <code>ClusterA</code> occupies the range starting at <code>0x0</code> for <code>16</code> bytes, and <code>ClusterB</code> starts at <code>0x1</code> with a size of <code>8</code>, causing the two clusters to share overlapping addresses. The warning should provide clear information about which clusters are affected and the nature of the overlap, giving users the necessary insights to address any configuration issues in their SVD definitions.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>def test_cluster_overlap(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates how the parser handles overlapping clusters within a peripheral, where `ClusterB` is\n    derived from `ClusterA` but is assigned an address offset that causes an overlap. In the SVD file, `ClusterA`\n    is defined at address offset `0x0` with a size of `16`, and `ClusterB`, derived from `ClusterA`, is placed at\n    address offset `0x1` with a size of `8`. This configuration leads to overlapping address ranges for these\n    clusters. While `svdconv` processes this file without detecting the overlap, this behavior appears to be a\n    bug. Ideally, a parser should issue a warning to alert the user of the overlap, ensuring that any unintended\n    address conflicts are recognized and can be corrected.\n\n    **Expected Outcome:** The parser should correctly process the SVD file, identifying both `ClusterA` and `ClusterB`\n    while issuing a warning to indicate that their address ranges overlap. Specifically, `ClusterA` occupies the\n    range starting at `0x0` for `16` bytes, and `ClusterB` starts at `0x1` with a size of `8`, causing the two\n    clusters to share overlapping addresses. The warning should provide clear information about which clusters are\n    affected and the nature of the overlap, giving users the necessary insights to address any configuration\n    issues in their SVD definitions.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/cluster_overlap.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 16\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 16\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x1\n    assert device.peripherals[0].registers_clusters[1].size == 8\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 8\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/cluster_overlap.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;cluster_overlap&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x1&lt;/addressOffset&gt;\n          &lt;size&gt;8&lt;/size&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_derive_from_self","title":"<code>test_derive_from_self</code>","text":"<p>This test case evaluates a scenario where a cluster attempts to derive from itself, creating an invalid configuration. In the SVD file, <code>ClusterA</code> is defined with a <code>derivedFrom</code> attribute pointing to its own name. Such configurations should be detected as erroneous because a cluster cannot logically inherit properties from itself. This kind of self-reference should lead to a parsing error.</p> <p>Expected Outcome: The parser should detect the invalid self-referential inheritance and raise an error, indicating that a cluster cannot derive from itself. This ensures that the system handles such configurations correctly by stopping further processing and informing the user of the issue.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Can't derive from self\")\ndef test_derive_from_self(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates a scenario where a cluster attempts to derive from itself, creating an invalid\n    configuration. In the SVD file, `ClusterA` is defined with a `derivedFrom` attribute pointing to its own name.\n    Such configurations should be detected as erroneous because a cluster cannot logically inherit properties from\n    itself. This kind of self-reference should lead to a parsing error.\n\n    **Expected Outcome:** The parser should detect the invalid self-referential inheritance and raise an error,\n    indicating that a cluster cannot derive from itself. This ensures that the system handles such configurations\n    correctly by stopping further processing and informing the user of the issue.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/derive_from_self.svd\")\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/derive_from_self.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;derive_from_self&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_multiple_inheritance_backward_reference","title":"<code>test_multiple_inheritance_backward_reference</code>","text":"<p>This test case evaluates how the parser handles multiple levels of inheritance using the <code>derivedFrom</code> attribute. The scenario consists of three clusters: <code>ClusterA</code>, defined as the base cluster; <code>ClusterB</code>, which derives from <code>ClusterA</code>; and <code>ClusterC</code>, which in turn derives from <code>ClusterB</code>. The SVD file defines these clusters in a backward-compatible order, starting with <code>ClusterA</code> and then progressively building upon it with <code>ClusterB</code> and <code>ClusterC</code>. This setup tests the parser's ability to correctly inherit properties across multiple layers of derivation, ensuring that each derived cluster appropriately inherits all relevant attributes from its predecessors.</p> <p>Expected Outcome: The parser should successfully process the multiple inheritance chain, maintaining the correct properties throughout each level. <code>ClusterA</code> should be recognized as the base, with all its defined properties and a register named <code>RegisterA</code>. <code>ClusterB</code>, derived from <code>ClusterA</code>, should inherit all the base attributes and the <code>RegisterA</code> structure, located at a new offset, demonstrating that it has extended the base. Finally, <code>ClusterC</code> should inherit the cumulative properties from both <code>ClusterA</code> and <code>ClusterB</code>, further verifying the parser's capability to manage complex inheritance patterns across multiple derived entities. This behavior should mirror <code>svdconv</code>'s processing and ensure consistent, hierarchical inheritance.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_backward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates how the parser handles multiple levels of inheritance using the `derivedFrom`\n    attribute. The scenario consists of three clusters: `ClusterA`, defined as the base cluster; `ClusterB`, which\n    derives from `ClusterA`; and `ClusterC`, which in turn derives from `ClusterB`. The SVD file defines these\n    clusters in a backward-compatible order, starting with `ClusterA` and then progressively building upon it with\n    `ClusterB` and `ClusterC`. This setup tests the parser's ability to correctly inherit properties across\n    multiple layers of derivation, ensuring that each derived cluster appropriately inherits all relevant\n    attributes from its predecessors.\n\n    **Expected Outcome:** The parser should successfully process the multiple inheritance chain, maintaining the\n    correct properties throughout each level. `ClusterA` should be recognized as the base, with all its defined\n    properties and a register named `RegisterA`. `ClusterB`, derived from `ClusterA`, should inherit all the base\n    attributes and the `RegisterA` structure, located at a new offset, demonstrating that it has extended the\n    base. Finally, `ClusterC` should inherit the cumulative properties from both `ClusterA` and `ClusterB`,\n    further verifying the parser's capability to manage complex inheritance patterns across multiple derived\n    entities. This behavior should mirror `svdconv`'s processing and ensure consistent, hierarchical inheritance.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"cluster_inheritance_via_derivedfrom/multiple_inheritance_backward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Cluster)\n    assert device.peripherals[0].registers_clusters[2].name == \"ClusterC\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[2].size == 32\n    assert len(device.peripherals[0].registers_clusters[2].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[2].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[2].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[2].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[2].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/multiple_inheritance_backward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_inheritance_backward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterB\"&gt;\n          &lt;name&gt;ClusterC&lt;/name&gt;\n          &lt;description&gt;ClusterC description&lt;/description&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_multiple_inheritance_forward_reference","title":"<code>test_multiple_inheritance_forward_reference</code>","text":"<p>This test case assesses the parser's handling of complex inheritance structures where the base cluster (<code>ClusterC</code>) is referenced by derived clusters (<code>ClusterB</code> and <code>ClusterA</code>) in a forward manner. In this setup, the SVD file defines <code>ClusterA</code> first, followed by <code>ClusterB</code>, and finally <code>ClusterC</code>, which serves as the base for the other clusters. The <code>derivedFrom</code> attribute is used to create a chain of inheritance starting from <code>ClusterC</code> as the base, with <code>ClusterB</code> inheriting from it, and <code>ClusterA</code> inheriting from <code>ClusterB</code>. This configuration challenges the parser to correctly resolve references even when the base entity appears later in the file.</p> <p>Expected Outcome: The parser should be able to process the forward references correctly, linking each derived cluster back to its base cluster despite the forward order of definition. <code>ClusterA</code>, appearing first in the SVD file, should correctly inherit properties from <code>ClusterB</code>, which in turn inherits from <code>ClusterC</code>. Each derived cluster should maintain the properties defined in its base and apply them consistently. <code>ClusterA</code>, <code>ClusterB</code>, and <code>ClusterC</code> should all include the expected attributes, registers, and configurations inherited through the chain, confirming that the parser effectively handles forward inheritance. This contrasts with <code>svdconv</code>, which fails to process such forward references, making robust support for this feature a valuable enhancement in the parser.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case assesses the parser's handling of complex inheritance structures where the base cluster\n    (`ClusterC`) is referenced by derived clusters (`ClusterB` and `ClusterA`) in a forward manner. In this setup,\n    the SVD file defines `ClusterA` first, followed by `ClusterB`, and finally `ClusterC`, which serves as the\n    base for the other clusters. The `derivedFrom` attribute is used to create a chain of inheritance starting\n    from `ClusterC` as the base, with `ClusterB` inheriting from it, and `ClusterA` inheriting from `ClusterB`.\n    This configuration challenges the parser to correctly resolve references even when the base entity appears\n    later in the file.\n\n    **Expected Outcome:** The parser should be able to process the forward references correctly, linking each derived\n    cluster back to its base cluster despite the forward order of definition. `ClusterA`, appearing first in the\n    SVD file, should correctly inherit properties from `ClusterB`, which in turn inherits from `ClusterC`. Each\n    derived cluster should maintain the properties defined in its base and apply them consistently. `ClusterA`,\n    `ClusterB`, and `ClusterC` should all include the expected attributes, registers, and configurations inherited\n    through the chain, confirming that the parser effectively handles forward inheritance. This contrasts with\n    `svdconv`, which fails to process such forward references, making robust support for this feature a valuable\n    enhancement in the parser.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"cluster_inheritance_via_derivedfrom/multiple_inheritance_forward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Cluster)\n    assert device.peripherals[0].registers_clusters[2].name == \"ClusterC\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[2].size == 32\n    assert len(device.peripherals[0].registers_clusters[2].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[2].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[2].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[2].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[2].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/multiple_inheritance_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_inheritance_forward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster derivedFrom=\"ClusterB\"&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterC\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterC&lt;/name&gt;\n          &lt;description&gt;ClusterC description&lt;/description&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_nested_cluster_inheritance","title":"<code>test_nested_cluster_inheritance</code>","text":"<p>This test case explores the scenario where a cluster contains another cluster, and the inner cluster attempts to inherit properties from its parent using the <code>derivedFrom</code> attribute. In the provided SVD file, <code>ClusterB</code> is nested within <code>ClusterA</code>, and it is set to inherit from <code>ClusterA</code>. This creates a situation where a cluster is attempting to derive from its own parent, forming a nested inheritance pattern that is logically flawed. Proper parsing should recognize that this setup is invalid because nested clusters should not inherit from their parent clusters in this manner. Attempting to resolve such inheritance could lead to recursive loops or other unintended behavior, making it essential for the parser to detect and handle this case appropriately.</p> <p>Expected Outcome: The parser should raise an error upon encountering this nested inheritance, clearly indicating that this pattern is not supported. The parser's robustness should ensure that it does not attempt to process the inheritance further, as doing so could result in a circular dependency or recursive issues. Unlike <code>svdconv</code>, which crashes with a segmentation fault (SigSegV) when encountering such a configuration, a well-implemented parser should gracefully handle this invalid setup by issuing a clear error message, preventing further processing of the file.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Nested inheritance is not supported\")\ndef test_nested_cluster_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case explores the scenario where a cluster contains another cluster, and the inner cluster attempts\n    to inherit properties from its parent using the `derivedFrom` attribute. In the provided SVD file, `ClusterB`\n    is nested within `ClusterA`, and it is set to inherit from `ClusterA`. This creates a situation where a\n    cluster is attempting to derive from its own parent, forming a nested inheritance pattern that is logically\n    flawed. Proper parsing should recognize that this setup is invalid because nested clusters should not inherit\n    from their parent clusters in this manner. Attempting to resolve such inheritance could lead to recursive\n    loops or other unintended behavior, making it essential for the parser to detect and handle this case\n    appropriately.\n\n    **Expected Outcome:** The parser should raise an error upon encountering this nested inheritance, clearly\n    indicating that this pattern is not supported. The parser's robustness should ensure that it does not attempt\n    to process the inheritance further, as doing so could result in a circular dependency or recursive issues.\n    Unlike `svdconv`, which crashes with a segmentation fault (SigSegV) when encountering such a configuration, a\n    well-implemented parser should gracefully handle this invalid setup by issuing a clear error message,\n    preventing further processing of the file.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/nested_cluster_inheritance.svd\")\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/nested_cluster_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;nested_cluster_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;cluster derivedFrom=\"ClusterA\"&gt;\n            &lt;name&gt;ClusterB&lt;/name&gt;\n            &lt;description&gt;ClusterB description&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/cluster&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_override_behavior","title":"<code>test_override_behavior</code>","text":"<p>This test case examines how derived clusters can override specific properties inherited from their base cluster using the <code>derivedFrom</code> attribute. When a derived cluster redefines certain attributes, it should effectively replace the values that would otherwise be inherited.</p> <p>Expected Outcome: The parser should correctly handle scenarios where a derived cluster overrides properties inherited from a base cluster. For <code>ClusterA</code>, all attributes should match those defined in the base configuration, reflecting typical inheritance. However, <code>ClusterB</code>, while still inheriting from a similar base, should show overridden properties where explicitly defined. Attributes such as <code>alternate_cluster</code>, <code>header_struct_name</code>, and <code>protection</code> should reflect the customizations specified within <code>ClusterB</code>. Moreover, registers within <code>ClusterB</code> should inherit general properties but may also have some overridden settings, such as <code>size</code> or <code>access</code>. The parser must correctly interpret both inherited and redefined values, ensuring that <code>ClusterB</code> retains a consistent but modified behavior compared to <code>ClusterA</code>. This behavior mirrors what <code>svdconv</code> processes, ensuring that derived configurations accurately apply the specified overrides without causing any inconsistencies.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_override_behavior(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines how derived clusters can override specific properties inherited from their base\n    cluster using the `derivedFrom` attribute. When a derived cluster redefines certain attributes, it should\n    effectively replace the values that would otherwise be inherited.\n\n    **Expected Outcome:** The parser should correctly handle scenarios where a derived cluster overrides properties\n    inherited from a base cluster. For `ClusterA`, all attributes should match those defined in the base\n    configuration, reflecting typical inheritance. However, `ClusterB`, while still inheriting from a similar\n    base, should show overridden properties where explicitly defined. Attributes such as `alternate_cluster`,\n    `header_struct_name`, and `protection` should reflect the customizations specified within `ClusterB`.\n    Moreover, registers within `ClusterB` should inherit general properties but may also have some overridden\n    settings, such as `size` or `access`. The parser must correctly interpret both inherited and redefined values,\n    ensuring that `ClusterB` retains a consistent but modified behavior compared to `ClusterA`. This behavior\n    mirrors what `svdconv` processes, ensuring that derived configurations accurately apply the specified\n    overrides without causing any inconsistencies.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/override_behavior.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n    assert device.peripherals[0].size == 16\n    assert device.peripherals[0].access == AccessType.READ_WRITE\n    assert device.peripherals[0].protection == ProtectionStringType.ANY\n    assert device.peripherals[0].reset_value == 0x0\n    assert device.peripherals[0].reset_mask == 0xFFFFFFFF\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].description == \"ClusterA description\"\n    assert device.peripherals[0].registers_clusters[0].alternate_cluster == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[0].header_struct_name == \"HeaderStructName\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 8\n    assert device.peripherals[0].registers_clusters[0].access == AccessType.WRITE_ONLY\n    assert device.peripherals[0].registers_clusters[0].protection == ProtectionStringType.SECURE\n    assert device.peripherals[0].registers_clusters[0].reset_value == 0xDEADBEEF\n    assert device.peripherals[0].registers_clusters[0].reset_mask == 0xDEADC0DE\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 8\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].access == AccessType.WRITE_ONLY\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].protection == ProtectionStringType.SECURE\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].reset_value == 0xDEADBEEF\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].reset_mask == 0xDEADC0DE\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].description == \"ClusterB description\"\n    assert device.peripherals[0].registers_clusters[1].alternate_cluster == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[1].header_struct_name == \"HeaderStructName2\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].size == 16\n    assert device.peripherals[0].registers_clusters[1].access == AccessType.WRITE_ONCE\n    assert device.peripherals[0].registers_clusters[1].protection == ProtectionStringType.NON_SECURE\n    assert device.peripherals[0].registers_clusters[1].reset_value == 0x0F0F0F0F\n    assert device.peripherals[0].registers_clusters[1].reset_mask == 0xABABABAB\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 2\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 16\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].access == AccessType.WRITE_ONCE\n    assert (\n        device.peripherals[0].registers_clusters[1].registers_clusters[0].protection == ProtectionStringType.NON_SECURE\n    )\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].reset_value == 0x0F0F0F0F\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].reset_mask == 0xABABABAB\n\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].size == 16\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].access == AccessType.WRITE_ONCE\n    assert (\n        device.peripherals[0].registers_clusters[1].registers_clusters[1].protection == ProtectionStringType.NON_SECURE\n    )\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].reset_value == 0x0F0F0F0F\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].reset_mask == 0xABABABAB\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/override_behavior.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;override_behavior&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterB&lt;/alternateCluster&gt;\n          &lt;headerStructName&gt;HeaderStructName&lt;/headerStructName&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;8&lt;/size&gt;\n          &lt;access&gt;write-only&lt;/access&gt;\n          &lt;protection&gt;s&lt;/protection&gt;\n          &lt;resetValue&gt;0xDEADBEEF&lt;/resetValue&gt;\n          &lt;resetMask&gt;0xDEADC0DE&lt;/resetMask&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterA&lt;/alternateCluster&gt;\n          &lt;headerStructName&gt;HeaderStructName2&lt;/headerStructName&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n          &lt;access&gt;writeOnce&lt;/access&gt;\n          &lt;protection&gt;n&lt;/protection&gt;\n          &lt;resetValue&gt;0x0F0F0F0F&lt;/resetValue&gt;\n          &lt;resetMask&gt;0xABABABAB&lt;/resetMask&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_register_inheritance_overlap_address","title":"<code>test_register_inheritance_overlap_address</code>","text":"<p>This test case evaluates how a derived cluster manages address space conflicts when it inherits registers from a base cluster and defines additional registers that cause overlapping addresses. In the provided SVD file, <code>ClusterA</code> defines <code>RegisterA</code> at address offset <code>0x0</code> with a size of 32 bits, while <code>ClusterB</code>, which is derived from <code>ClusterA</code>, also defines <code>RegisterB</code> at address offset <code>0x2</code> with a size of 16 bits. Because of their sizes, <code>RegisterB</code> ends up overlapping with the address space occupied by <code>RegisterA</code>. Older versions of <code>svdconv</code> did not recognize this behavior and therefore, newer versions issue a warning instead of an error to inform users of the potential address conflict. A parser that aims to maintain compatibility with older SVD files should similarly allow registers with overlapping addresses while issuing a clear warning to alert users of the overlap. This approach ensures that backward compatibility is maintained, but it also makes developers aware of potential problems that could arise from such configurations.</p> <p>Expected Outcome: The parser should successfully process the SVD file, but it must issue a warning indicating that <code>RegisterB</code> overlaps with <code>RegisterA</code> within <code>ClusterB</code>. The warning should clearly state the address conflict and provide details about the overlapping addresses and sizes. This behavior mirrors that of <code>svdconv</code>, ensuring that the parser maintains backward compatibility while still alerting developers to potential configuration issues that could cause unexpected behavior in hardware interaction.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>def test_register_inheritance_overlap_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates how a derived cluster manages address space conflicts when it inherits registers from\n    a base cluster and defines additional registers that cause overlapping addresses. In the provided SVD file,\n    `ClusterA` defines `RegisterA` at address offset `0x0` with a size of 32 bits, while `ClusterB`, which is\n    derived from `ClusterA`, also defines `RegisterB` at address offset `0x2` with a size of 16 bits. Because of\n    their sizes, `RegisterB` ends up overlapping with the address space occupied by `RegisterA`. Older versions of\n    `svdconv` did not recognize this behavior and therefore, newer versions issue a warning instead of an error to\n    inform users of the potential address conflict. A parser that aims to maintain compatibility with older SVD\n    files should similarly allow registers with overlapping addresses while issuing a clear warning to alert users\n    of the overlap. This approach ensures that backward compatibility is maintained, but it also makes developers\n    aware of potential problems that could arise from such configurations.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, but it must issue a warning indicating\n    that `RegisterB` overlaps with `RegisterA` within `ClusterB`. The warning should clearly state the address\n    conflict and provide details about the overlapping addresses and sizes. This behavior mirrors that of\n    `svdconv`, ensuring that the parser maintains backward compatibility while still alerting developers to\n    potential configuration issues that could cause unexpected behavior in hardware interaction.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"cluster_inheritance_via_derivedfrom/register_inheritance_overlap_address.svd\"\n        )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 2\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].size == 16\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/register_inheritance_overlap_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_overlap_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;size&gt;32&lt;/size&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n            &lt;size&gt;16&lt;/size&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_register_inheritance_same_address","title":"<code>test_register_inheritance_same_address</code>","text":"<p>This test scenario evaluates how a derived cluster handles cases where it inherits a register from a base cluster, and the derived cluster also defines another register at the same address offset. In the SVD file, <code>ClusterA</code> defines <code>RegisterA</code> at address offset <code>0x0</code>, and <code>ClusterB</code>, which is derived from <code>ClusterA</code>, also defines <code>RegisterB</code> at the same address offset <code>0x0</code>. As a result, both <code>RegisterA</code> (inherited from <code>ClusterA</code>) and <code>RegisterB</code> (defined within <code>ClusterB</code>) occupy the same address space within <code>ClusterB</code>. <code>svdconv</code> processes this case without raising a hard error but issues a warning to highlight the overlap, because of compatibility reasons. For a parser designed to work with both new and old SVD files, it is recommended to allow registers with the same addresses but issue a warning to the user.</p> <p>Expected Outcome: The parser should process the file successfully but must issue a warning indicating that <code>RegisterB</code> is assigned the same address as <code>RegisterA</code> due to inheritance. The warning should explicitly state the address conflict, providing enough information for developers to recognize and address any unintended overlaps in the register configurations.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>def test_register_inheritance_same_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test scenario evaluates how a derived cluster handles cases where it inherits a register from a base\n    cluster, and the derived cluster also defines another register at the same address offset. In the SVD file,\n    `ClusterA` defines `RegisterA` at address offset `0x0`, and `ClusterB`, which is derived from `ClusterA`, also\n    defines `RegisterB` at the same address offset `0x0`. As a result, both `RegisterA` (inherited from\n    `ClusterA`) and `RegisterB` (defined within `ClusterB`) occupy the same address space within `ClusterB`.\n    `svdconv` processes this case without raising a hard error but issues a warning to highlight the overlap,\n    because of [compatibility reasons](https://github.com/Open-CMSIS-Pack/devtools/blob/44643999691347946562c526fc\n    0474194f865c74/tools/svdconv/SVDModel/src/SvdPeripheral.cpp#L721). For a parser designed to work with both new\n    and old SVD files, it is recommended to allow registers with the same addresses but issue a warning to the\n    user.\n\n    **Expected Outcome:** The parser should process the file successfully but must issue a warning indicating that\n    `RegisterB` is assigned the same address as `RegisterA` due to inheritance. The warning should explicitly\n    state the address conflict, providing enough information for developers to recognize and address any\n    unintended overlaps in the register configurations.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"cluster_inheritance_via_derivedfrom/register_inheritance_same_address.svd\"\n        )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 2\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/register_inheritance_same_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_same_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_register_inheritance_same_name","title":"<code>test_register_inheritance_same_name</code>","text":"<p>This test case addresses a situation where a derived cluster attempts to inherit a register from a base cluster, but there is a naming conflict because the derived cluster defines a register with the same name as the one it is inheriting. In the SVD file, <code>ClusterA</code> defines a register named <code>RegisterA</code>, and <code>ClusterB</code>, which is derived from <code>ClusterA</code>, also defines its own <code>RegisterA</code>. Since <code>ClusterB</code> inherits from <code>ClusterA</code>, this results in a conflict where <code>RegisterA</code> is effectively defined twice within <code>ClusterB</code>. While <code>svdconv</code> correctly identifies this issue and raises an error, a robust parser must also handle this case by issuing an appropriate error message.</p> <p>Expected Outcome: The parser should raise an error indicating that <code>RegisterA</code> is already defined in <code>ClusterA</code>, and therefore cannot be inherited by <code>ClusterB</code> because it has the same name. The error should be explicit, preventing further processing and avoiding any ambiguity around the derived cluster's register structure.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"RegisterA is already defined in ClusterA and cannot be inherited because it has the same name\",\n)\ndef test_register_inheritance_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case addresses a situation where a derived cluster attempts to inherit a register from a base\n    cluster, but there is a naming conflict because the derived cluster defines a register with the same name as\n    the one it is inheriting. In the SVD file, `ClusterA` defines a register named `RegisterA`, and `ClusterB`,\n    which is derived from `ClusterA`, also defines its own `RegisterA`. Since `ClusterB` inherits from `ClusterA`,\n    this results in a conflict where `RegisterA` is effectively defined twice within `ClusterB`. While `svdconv`\n    correctly identifies this issue and raises an error, a robust parser must also handle this case by issuing an\n    appropriate error message.\n\n    **Expected Outcome:** The parser should raise an error indicating that `RegisterA` is already defined in\n    `ClusterA`, and therefore cannot be inherited by `ClusterB` because it has the same name. The error should be\n    explicit, preventing further processing and avoiding any ambiguity around the derived cluster's register\n    structure.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/register_inheritance_same_name.svd\")\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/register_inheritance_same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_same_address","title":"<code>test_same_address</code>","text":"<p>This test case examines how the parser handles situations where two clusters, <code>ClusterA</code> and <code>ClusterB</code>, are defined at the same address offset within a peripheral. In the provided SVD file, both clusters are located at address offset <code>0x0</code>, which leads to potential address conflicts. Older versions of <code>svdconv</code> did not recognize this behavior and for compatibility, newer versions issue a warning instead of an error to inform users of the potential address conflict. A modern parser should replicate this behavior by allowing the SVD file to be processed but should issue a warning to alert the user of the address overlap.</p> <p>Expected Outcome: The parser should successfully parse the SVD file, identifying both <code>ClusterA</code> and <code>ClusterB</code> at the same address offset (<code>0x0</code>). However, a warning should be issued to inform the user that <code>ClusterB</code> shares the same address as <code>ClusterA</code>, indicating a potential conflict.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>def test_same_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines how the parser handles situations where two clusters, `ClusterA` and `ClusterB`, are\n    defined at the same address offset within a peripheral. In the provided SVD file, both clusters are located at\n    address offset `0x0`, which leads to potential address conflicts. Older versions of `svdconv` did not\n    recognize this behavior and for compatibility, newer versions issue a warning instead of an error to inform\n    users of the potential address conflict. A modern parser should replicate this behavior by allowing the SVD\n    file to be processed but should issue a warning to alert the user of the address overlap.\n\n    **Expected Outcome:** The parser should successfully parse the SVD file, identifying both `ClusterA` and\n    `ClusterB` at the same address offset (`0x0`). However, a warning should be issued to inform the user that\n    `ClusterB` shares the same address as `ClusterA`, indicating a potential conflict.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/same_address.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/same_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;same_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_simple_inheritance_backward_reference_different_scope","title":"<code>test_simple_inheritance_backward_reference_different_scope</code>","text":"<p>This test case evaluates how a parser handles cluster inheritance via the <code>derivedFrom</code> attribute when the derived cluster refers to a base cluster that is defined within a different peripheral. In this scenario, <code>ClusterA</code> from one peripheral acts as the base cluster, while a similarly named <code>ClusterA</code> in another peripheral inherits its properties. This setup is intended to confirm that cross-scope inheritance works correctly, ensuring that the derived cluster can access and copy properties from a base cluster, even when they reside within different scopes or peripherals.</p> <p>Expected Outcome: The parser should accurately resolve the <code>derivedFrom</code> reference across different scopes, allowing <code>ClusterA</code> in the second peripheral to inherit all the properties from <code>ClusterA</code> in the first peripheral. This includes settings such as size and any registers defined within the original cluster. The implementation should validate that properties are correctly inherited and applied to the derived cluster, ensuring consistency and accuracy. The parser's ability to handle this cross-scope inheritance efficiently is crucial, as <code>svdconv</code> processes these scenarios without issues.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_backward_reference_different_scope(\n    get_processed_device_from_testfile: Callable[[str], Device]\n):\n    \"\"\"\n    This test case evaluates how a parser handles cluster inheritance via the `derivedFrom` attribute when the\n    derived cluster refers to a base cluster that is defined within a different peripheral. In this scenario,\n    `ClusterA` from one peripheral acts as the base cluster, while a similarly named `ClusterA` in another\n    peripheral inherits its properties. This setup is intended to confirm that cross-scope inheritance works\n    correctly, ensuring that the derived cluster can access and copy properties from a base cluster, even when\n    they reside within different scopes or peripherals.\n\n    **Expected Outcome:** The parser should accurately resolve the `derivedFrom` reference across different scopes,\n    allowing `ClusterA` in the second peripheral to inherit all the properties from `ClusterA` in the first\n    peripheral. This includes settings such as size and any registers defined within the original cluster. The\n    implementation should validate that properties are correctly inherited and applied to the derived cluster,\n    ensuring consistency and accuracy. The parser's ability to handle this cross-scope inheritance efficiently is\n    crucial, as `svdconv` processes these scenarios without issues.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"cluster_inheritance_via_derivedfrom/simple_inheritance_backward_reference_different_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Cluster)\n    assert device.peripherals[1].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n    assert len(device.peripherals[1].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/simple_inheritance_backward_reference_different_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_backward_reference_different_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster derivedFrom=\"PeripheralA.ClusterA\"&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_simple_inheritance_backward_reference_same_scope","title":"<code>test_simple_inheritance_backward_reference_same_scope</code>","text":"<p>This test case examines the functionality of cluster inheritance using the <code>derivedFrom</code> attribute, specifically when a derived cluster references a base cluster that has been defined earlier within the same scope. The SVD file contains two clusters: <code>ClusterA</code>, which serves as the base, and <code>ClusterB</code>, which derives its properties from <code>ClusterA</code>. The test verifies that <code>ClusterB</code> correctly inherits the settings of <code>ClusterA</code>, such as address offsets and register definitions, without requiring explicit redefinition. This allows for efficient reuse of configurations and consistency across similar clusters.</p> <p>Expected Outcome: The parser should successfully interpret the SVD file, recognizing <code>ClusterB</code> as a derivative of <code>ClusterA</code>. <code>ClusterB</code> should inherit all properties from <code>ClusterA</code>, including the register within it. The test should confirm that the derived cluster behaves exactly as if it were fully defined on its own, ensuring no loss of information or incorrect settings. The implementation must accurately parse and apply the inheritance mechanism, consistent with how <code>svdconv</code> processes the file.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_backward_reference_same_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines the functionality of cluster inheritance using the `derivedFrom` attribute,\n    specifically when a derived cluster references a base cluster that has been defined earlier within the same\n    scope. The SVD file contains two clusters: `ClusterA`, which serves as the base, and `ClusterB`, which derives\n    its properties from `ClusterA`. The test verifies that `ClusterB` correctly inherits the settings of\n    `ClusterA`, such as address offsets and register definitions, without requiring explicit redefinition. This\n    allows for efficient reuse of configurations and consistency across similar clusters.\n\n    **Expected Outcome:** The parser should successfully interpret the SVD file, recognizing `ClusterB` as a\n    derivative of `ClusterA`. `ClusterB` should inherit all properties from `ClusterA`, including the register\n    within it. The test should confirm that the derived cluster behaves exactly as if it were fully defined on its\n    own, ensuring no loss of information or incorrect settings. The implementation must accurately parse and apply\n    the inheritance mechanism, consistent with how `svdconv` processes the file.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"cluster_inheritance_via_derivedfrom/simple_inheritance_backward_reference_same_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/simple_inheritance_backward_reference_same_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_backward_reference_same_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_simple_inheritance_forward_reference_different_scope","title":"<code>test_simple_inheritance_forward_reference_different_scope</code>","text":"<p>This test case explores how a parser manages cluster inheritance using the <code>derivedFrom</code> attribute when a derived cluster refers to a base cluster defined later within a different peripheral. Unlike backward references, forward references imply that the parser must anticipate and correctly resolve a reference to a cluster that has not yet been defined, adding complexity to the inheritance mechanism. This setup checks whether the parser can seamlessly link the derived cluster to its base cluster, even when the base cluster appears later and exists within a different peripheral scope. <code>svdconv</code> cannot handle forward references within a different scope, leading to an error, but a robust parser should be capable of managing such cases without issues.</p> <p>Expected Outcome: The parser should successfully handle the <code>derivedFrom</code> reference, allowing <code>ClusterA</code> in the first peripheral to inherit from <code>ClusterA</code> defined in the second peripheral. It must accurately inherit all properties, including sizes and register definitions. The parser should ensure that cross-scope and forward references do not disrupt the resolution of inherited properties, maintaining consistent and accurate behavior.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_forward_reference_different_scope(\n    get_processed_device_from_testfile: Callable[[str], Device]\n):\n    \"\"\"\n    This test case explores how a parser manages cluster inheritance using the `derivedFrom` attribute when a\n    derived cluster refers to a base cluster defined later within a different peripheral. Unlike backward\n    references, forward references imply that the parser must anticipate and correctly resolve a reference to a\n    cluster that has not yet been defined, adding complexity to the inheritance mechanism. This setup checks\n    whether the parser can seamlessly link the derived cluster to its base cluster, even when the base cluster\n    appears later and exists within a different peripheral scope. `svdconv` cannot handle forward references\n    within a different scope, leading to an error, but a robust parser should be capable of managing such cases\n    without issues.\n\n    **Expected Outcome:** The parser should successfully handle the `derivedFrom` reference, allowing `ClusterA` in\n    the first peripheral to inherit from `ClusterA` defined in the second peripheral. It must accurately inherit\n    all properties, including sizes and register definitions. The parser should ensure that cross-scope and\n    forward references do not disrupt the resolution of inherited properties, maintaining consistent and accurate\n    behavior.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"cluster_inheritance_via_derivedfrom/simple_inheritance_forward_reference_different_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Cluster)\n    assert device.peripherals[1].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n    assert len(device.peripherals[1].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/simple_inheritance_forward_reference_different_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_forward_reference_different_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster derivedFrom=\"PeripheralB.ClusterA\"&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_simple_inheritance_forward_reference_same_scope","title":"<code>test_simple_inheritance_forward_reference_same_scope</code>","text":"<p>This test case evaluates the functionality of cluster inheritance via the <code>derivedFrom</code> attribute when a derived cluster refers to a base cluster that is defined later in the same scope. Unlike backward references, this scenario involves the base cluster being declared after the derived cluster. This setup is used to ensure that the parser can correctly resolve forward references, allowing <code>ClusterA</code> to derive from <code>ClusterB</code>, even though <code>ClusterB</code> is defined later in the SVD file. <code>svdconv</code> cannot handle forward references within the same scope, leading to an error, but a robust parser should be capable of managing such cases without issues.</p> <p>Expected Outcome: The parser should successfully process the SVD file, correctly handling the forward reference so that <code>ClusterA</code> inherits all properties from <code>ClusterB</code>. This includes the register defined within the base cluster. The test should confirm that <code>ClusterA</code> behaves as though it were explicitly defined with the same settings as <code>ClusterB</code>, ensuring consistency and accurate inheritance. The implementation must be able to parse these forward references efficiently, overcoming the limitations observed in <code>svdconv</code>.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_forward_reference_same_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates the functionality of cluster inheritance via the `derivedFrom` attribute when a\n    derived cluster refers to a base cluster that is defined later in the same scope. Unlike backward references,\n    this scenario involves the base cluster being declared after the derived cluster. This setup is used to ensure\n    that the parser can correctly resolve forward references, allowing `ClusterA` to derive from `ClusterB`, even\n    though `ClusterB` is defined later in the SVD file. `svdconv` cannot handle forward references within the same\n    scope, leading to an error, but a robust parser should be capable of managing such cases without issues.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, correctly handling the forward\n    reference so that `ClusterA` inherits all properties from `ClusterB`. This includes the register defined\n    within the base cluster. The test should confirm that `ClusterA` behaves as though it were explicitly defined\n    with the same settings as `ClusterB`, ensuring consistency and accurate inheritance. The implementation must\n    be able to parse these forward references efficiently, overcoming the limitations observed in `svdconv`.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"cluster_inheritance_via_derivedfrom/simple_inheritance_forward_reference_same_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/simple_inheritance_forward_reference_same_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_forward_reference_same_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster derivedFrom=\"ClusterB\"&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_size_inheritance","title":"<code>test_size_inheritance</code>","text":"<p>This test case verifies that the <code>size</code> attribute is correctly inherited when using <code>derivedFrom</code> on clusters and registers. In the provided setup, <code>ClusterB</code> is derived from <code>ClusterA</code>, which has a specified <code>size</code> of 8 for <code>RegisterA</code>. Since <code>RegisterB</code> in <code>ClusterB</code> does not define its own <code>size</code>, it should inherit the <code>size</code> attribute from <code>RegisterA</code> in <code>ClusterA</code>. This test confirms that the parser correctly applies this inheritance, ensuring consistent <code>size</code> values across derived elements without explicit redefinition.</p> <p>Expected Outcome: The parser should successfully inherit the <code>size</code> attribute for <code>RegisterB</code>, resulting in <code>ClusterB</code> and its registers having the same size attributes as the elements in <code>ClusterA</code>. Specifically, <code>RegisterB</code> in <code>ClusterB</code> should inherit a <code>size</code> of 8.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_size_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case verifies that the `size` attribute is correctly inherited when using `derivedFrom` on clusters\n    and registers. In the provided setup, `ClusterB` is derived from `ClusterA`, which has a specified `size` of 8\n    for `RegisterA`. Since `RegisterB` in `ClusterB` does not define its own `size`, it should inherit the `size`\n    attribute from `RegisterA` in `ClusterA`. This test confirms that the parser correctly applies this\n    inheritance, ensuring consistent `size` values across derived elements without explicit redefinition.\n\n    **Expected Outcome:** The parser should successfully inherit the `size` attribute for `RegisterB`, resulting in\n    `ClusterB` and its registers having the same size attributes as the elements in `ClusterA`. Specifically,\n    `RegisterB` in `ClusterB` should inherit a `size` of 8.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/size_inheritance.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n    assert device.peripherals[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 8\n\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/size_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;size_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;size&gt;8&lt;/size&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_cluster_inheritance_via_derived_from.html#tests.test_process.test_cluster_inheritance_via_derived_from.test_value_inheritance","title":"<code>test_value_inheritance</code>","text":"<p>This test case focuses on the inheritance of properties within clusters when utilizing the <code>derivedFrom</code> attribute. Specifically, it examines how a derived cluster can inherit various attributes\u2014such as description, alternate clusters, header structure names, access permissions, and reset configurations\u2014from a base cluster. The goal is to ensure that the parser accurately handles the propagation of these values, maintaining consistency across derived clusters without requiring them to redefine attributes that are already specified in their base counterparts.</p> <p>Expected Outcome: The parser should successfully interpret the <code>derivedFrom</code> attribute and apply all the relevant properties from the base cluster to the derived cluster. For instance, <code>ClusterB</code> should inherit settings from <code>ClusterA</code>, including but not limited to description, access permissions, protection level, and reset values. The properties like <code>alternateCluster</code>, <code>headerStructName</code>, and size should also be correctly propagated, ensuring <code>ClusterB</code> maintains the same effective behavior as <code>ClusterA</code> unless explicitly overridden. Furthermore, nested structures within the clusters, such as registers, should also reflect inherited attributes, demonstrating the parser\u2019s ability to resolve and apply complex inheritance patterns. This behavior mirrors the expected output of <code>svdconv</code>, which processes these scenarios correctly, reinforcing the parser's robustness in dealing with value inheritance via <code>derivedFrom</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_cluster_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_value_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case focuses on the inheritance of properties within clusters when utilizing the `derivedFrom`\n    attribute. Specifically, it examines how a derived cluster can inherit various attributes\u2014such as description,\n    alternate clusters, header structure names, access permissions, and reset configurations\u2014from a base cluster.\n    The goal is to ensure that the parser accurately handles the propagation of these values, maintaining\n    consistency across derived clusters without requiring them to redefine attributes that are already specified\n    in their base counterparts.\n\n    **Expected Outcome:** The parser should successfully interpret the `derivedFrom` attribute and apply all the\n    relevant properties from the base cluster to the derived cluster. For instance, `ClusterB` should inherit\n    settings from `ClusterA`, including but not limited to description, access permissions, protection level, and\n    reset values. The properties like `alternateCluster`, `headerStructName`, and size should also be correctly\n    propagated, ensuring `ClusterB` maintains the same effective behavior as `ClusterA` unless explicitly\n    overridden. Furthermore, nested structures within the clusters, such as registers, should also reflect\n    inherited attributes, demonstrating the parser\u2019s ability to resolve and apply complex inheritance patterns.\n    This behavior mirrors the expected output of `svdconv`, which processes these scenarios correctly, reinforcing\n    the parser's robustness in dealing with value inheritance via `derivedFrom`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"cluster_inheritance_via_derivedfrom/value_inheritance.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].description == \"ClusterA description\"\n    assert device.peripherals[0].registers_clusters[0].alternate_cluster == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].header_struct_name == \"HeaderStructName\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 16\n    assert device.peripherals[0].registers_clusters[0].access == AccessType.WRITE_ONLY\n    assert device.peripherals[0].registers_clusters[0].protection == ProtectionStringType.SECURE\n    assert device.peripherals[0].registers_clusters[0].reset_value == 0xDEADBEEF\n    assert device.peripherals[0].registers_clusters[0].reset_mask == 0xDEADC0DE\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 16\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].description == \"ClusterB description\"\n    assert device.peripherals[0].registers_clusters[1].alternate_cluster == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[1].header_struct_name == \"HeaderStructName\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 16\n    assert device.peripherals[0].registers_clusters[1].access == AccessType.WRITE_ONLY\n    assert device.peripherals[0].registers_clusters[1].protection == ProtectionStringType.SECURE\n    assert device.peripherals[0].registers_clusters[1].reset_value == 0xDEADBEEF\n    assert device.peripherals[0].registers_clusters[1].reset_mask == 0xDEADC0DE\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 16\n</code></pre> SVD file: <code>cluster_inheritance_via_derivedfrom/value_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;value_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterA&lt;/alternateCluster&gt;\n          &lt;headerStructName&gt;HeaderStructName&lt;/headerStructName&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n          &lt;access&gt;write-only&lt;/access&gt;\n          &lt;protection&gt;s&lt;/protection&gt;\n          &lt;resetValue&gt;0xDEADBEEF&lt;/resetValue&gt;\n          &lt;resetMask&gt;0xDEADC0DE&lt;/resetMask&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html","title":"test_derived_from_path_resolving","text":"<p>The <code>derivedFrom</code> attribute in SVD is a powerful feature that allows reuse of elements (like registers, clusters, and fields) across different parts of a peripheral definition. It is used to reference existing definitions and inherit their attributes without having to redefine them. This reduces redundancy and helps maintain consistency within complex device descriptions.</p> <p>The <code>derivedFrom</code> path resolving mechanism is crucial in determining how references are processed. Paths can vary in complexity, ranging from simple names to more intricate, nested references within clusters. A robust parser implementation must correctly interpret these paths, supporting multiple levels of hierarchy while handling any scope ambiguities. Additionally, the parser should gracefully handle errors when the paths are incorrect, issuing clear diagnostic messages to aid debugging.</p> <p>According to this, the deriving algorithm works as follows:</p> <ol> <li> <p>Initialization: - Split the deriving path (the string in the <code>derivedFrom</code> attribute) by <code>.</code> and store it in array $P$. For example, if the path is <code>x.y.z</code>, then $P_0 =     ext{x}$, $P_1 =         ext{y}$, and $P_2 =     ext{z}$. - Set index $i = 0$. - Store the deriving element (the element with the <code>derivedFrom</code> attribute) in variable $D$. - Store the deriving element $D$ in variable $C$ (i.e., $C = D$). - Get the parent of the current element $C$ and set it as the current node (i.e., $C = C.     ext{parent()}$).</p> </li> <li> <p>Search in the current scope: - For each child of $C$, do the following: - Ignore the child if it is the same as $D$, to not match the deriving element itself. - Check if the child\u2019s name matches $P_i$. - If a match is found: 1. Check if $P_{i+1}$ exists (i.e., there is a next element in the path). - If $P_{i+1}$ does not exist: - Verify if the child has the same type as $D$ (e.g., both are registers): - If it does, the base element is found. Stop the search. - If it does not, continue the algorithm (go to step 3). - If $P_{i+1}$ exists: - Increment $i$ (i.e., move to the next part of the path). - Set $C$ to the child element that matched $P_i$ and proceed to step 2 to continue searching down the hierarchy.</p> </li> <li> <p>Fallback search at the top level (peripherals): - If no match was found within the current scope, start searching from the top-level container (referred to as <code>peripherals</code>): - Set $C$ to the <code>peripherals</code> container, which is the container that holds all peripherals. - Set $i = 0$ (start over from the beginning of the path). - Repeat step 2 from the <code>peripherals</code> container: - Check if there is a child of $C$ that matches $P_i$. - Proceed with the same logic as in step 2, following the path $P$.</p> </li> <li> <p>Termination: - If the algorithm finds a match at any point, stop the search and return the base element. - If no match is found after searching through both the local scope and the top-level container, conclude that the base element could not be found.</p> </li> </ol> <p>In this chapter, we focus on test cases that validate the path resolving mechanism of <code>derivedFrom</code>. Each test case involves substituting the <code>derivedFrom</code> path with multiple variations, and then testing whether the parser can correctly process or reject each of these paths. Importantly, each test file is not a single test case; instead, each test file contains exactly one <code>derivedFrom</code> attribute, and multiple paths are tested against it. This approach allows us to thoroughly validate path resolving in different scenarios using the same base SVD setup.</p> <p>In the provided implementation examples, the <code>pytest</code> parameterization feature is utilized to test these paths. Paths that are expected to be valid and processable are not marked with <code>pytest</code>'s xmark, while paths that are expected to raise errors are marked with <code>pytest.mark.xfail</code>. Furthermore, test cases which are marked with <code>pytest.mark.xfail</code> are not processable with <code>svdconv</code>, whereas the others can be processed with <code>svdconv</code> if not statet otherwise.</p>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_1","title":"<code>test_test_setup_1</code>","text":"<p>This test setup explores <code>derivedFrom</code> path resolution within a single peripheral that contains nested clusters. The setup verifies whether the parser can correctly resolve paths to registers located within different levels of nested clusters. Additionally, it ensures that invalid paths are properly flagged as errors.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue. This mimics <code>svdconv</code>'s behavior.</p> <p>Processable with svdconv: partly</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(\n            \"PeripheralA.ClusterA.ClusterB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"ClusterA.ClusterB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralAA.ClusterA.ClusterB.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterAA.ClusterB.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterA.ClusterBB.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterA.ClusterB.RegisterAA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterB.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterA.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"PeripheralA.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"ClusterB.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"ClusterA.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_1(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    This test setup explores `derivedFrom` path resolution within a single peripheral that contains nested\n    clusters. The setup verifies whether the parser can correctly resolve paths to registers located within\n    different levels of nested clusters. Additionally, it ensures that invalid paths are properly flagged as\n    errors.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue. This mimics\n    `svdconv`'s behavior.\n\n    **Processable with svdconv:** partly\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_1.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"ClusterB\"\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters[0].registers_clusters) == 1\n\n    registera = device.peripherals[0].registers_clusters[0].registers_clusters[0].registers_clusters[0]\n    assert isinstance(registera, Register)\n    assert registera.name == \"RegisterA\"\n    assert registera.address_offset == 0x0\n    assert registera.size == 32\n    assert len(registera.fields) == 1\n\n    assert registera.fields[0].name == \"FieldA\"\n    assert registera.fields[0].lsb == 0\n    assert registera.fields[0].msb == 0\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 0\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_1.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_1&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;cluster&gt;\n            &lt;name&gt;ClusterB&lt;/name&gt;\n            &lt;description&gt;ClusterB description&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;register&gt;\n              &lt;name&gt;RegisterA&lt;/name&gt;\n              &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n              &lt;fields&gt;\n                &lt;field&gt;\n                  &lt;name&gt;FieldA&lt;/name&gt;\n                  &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n                  &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n                &lt;/field&gt;\n              &lt;/fields&gt;\n            &lt;/register&gt;\n          &lt;/cluster&gt;\n        &lt;/cluster&gt;\n        &lt;register derivedFrom=\"PATH\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_2","title":"<code>test_test_setup_2</code>","text":"<p>This test setup explores <code>derivedFrom</code> path resolution within a single peripheral that contains nested clusters and each element is named with the same name. Without the derivation, <code>svdconv</code> would be able to parse the file without any warnings or erros. However, <code>svdconv</code> contains a known bug, which prevents name resolving, if a parent has the same name as the child. The setup verifies whether the parser can correctly resolve paths to registers located within different levels of nested clusters, if they have the same names. Additionally, it ensures that invalid paths are properly flagged as errors.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(  # can't be processed with svdconv\n            \"SameA.SameA.SameA.SameA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(  # can't be processed with svdconv\n            \"SameA.SameA.SameA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"SameA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"SameA.SameA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"SameA.SameA.SameA.SameA.SameA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_2(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    This test setup explores `derivedFrom` path resolution within a single peripheral that contains nested\n    clusters and each element is named with the same name. Without the derivation, `svdconv` would be able to\n    parse the file without any warnings or erros. However, `svdconv` contains a [known\n    bug](https://github.com/Open-CMSIS-Pack/devtools/issues/815#issuecomment-1495681319), which prevents name\n    resolving, if a parent has the same name as the child. The setup verifies whether the parser can correctly\n    resolve paths to registers located within different levels of nested clusters, if they have the same names.\n    Additionally, it ensures that invalid paths are properly flagged as errors.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_2.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 1\n    assert device.peripherals[0].name == \"SameA\"\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"SameA\"\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"SameA\"\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters[0].registers_clusters) == 1\n\n    registera = device.peripherals[0].registers_clusters[0].registers_clusters[0].registers_clusters[0]\n    assert isinstance(registera, Register)\n    assert registera.name == \"SameA\"\n    assert registera.address_offset == 0x0\n    assert registera.size == 32\n    assert len(registera.fields) == 1\n\n    assert registera.fields[0].name == \"SameA\"\n    assert registera.fields[0].lsb == 0\n    assert registera.fields[0].msb == 0\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"SameA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 0\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_2.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_2&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;SameA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;SameA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;cluster&gt;\n            &lt;name&gt;SameA&lt;/name&gt;\n            &lt;description&gt;ClusterB description&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;register&gt;\n              &lt;name&gt;SameA&lt;/name&gt;\n              &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n              &lt;fields&gt;\n                &lt;field&gt;\n                  &lt;name&gt;SameA&lt;/name&gt;\n                  &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n                  &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n                &lt;/field&gt;\n              &lt;/fields&gt;\n            &lt;/register&gt;\n          &lt;/cluster&gt;\n        &lt;/cluster&gt;\n        &lt;register derivedFrom=\"PATH\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_3","title":"<code>test_test_setup_3</code>","text":"<p>In this test setup, the path <code>ElementA.RegisterA</code> can be resolved in multiple valid ways. Depending on how the algorithm is implemented, it could return <code>RegisterA</code> located within the <code>ElementA</code> peripheral or the <code>RegisterA</code> within <code>PeripheralA</code>. Since the parser should implement the same algorithm as <code>svdconv</code>, the expected behavior is that <code>RegisterA</code> within <code>PeripheralA</code> is found. This is because the search process first looks within the same scope, and if no match is found, it expands to all peripherals. Ultimately, <code>RegisterB</code> should inherit from <code>RegisterA</code> located in <code>PeripheralA</code>, meaning it must include <code>FieldB</code> instead of <code>FieldA</code>.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue.</p> <p>Processable with svdconv: partly</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(\n            \"ElementA.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"ElementA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_3(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    In this test setup, the path `ElementA.RegisterA` can be resolved in multiple valid ways. Depending on how the\n    algorithm is implemented, it could return `RegisterA` located within the `ElementA` peripheral or the\n    `RegisterA` within `PeripheralA`. Since the parser should implement the same algorithm as `svdconv`, the\n    expected behavior is that `RegisterA` within `PeripheralA` is found. This is because the search process first\n    looks within the same scope, and if no match is found, it expands to all peripherals. Ultimately, `RegisterB`\n    should inherit from `RegisterA` located in `PeripheralA`, meaning it must include `FieldB` instead of\n    `FieldA`.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue.\n\n    **Processable with svdconv:** partly\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_3.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 2\n\n    assert device.peripherals[1].name == \"PeripheralA\"\n    assert len(device.peripherals[1].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[1].registers_clusters[1], Register)\n    assert device.peripherals[1].registers_clusters[1].name == \"RegisterB\"\n    assert len(device.peripherals[1].registers_clusters[1].fields) == 1\n    assert device.peripherals[1].registers_clusters[1].fields[0].name == \"FieldB\"\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_3.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_3&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;ElementA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ElementA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;fields&gt;\n              &lt;field&gt;\n                &lt;name&gt;FieldB&lt;/name&gt;\n                &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n                &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;/field&gt;\n            &lt;/fields&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;register derivedFrom=\"PATH\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_4","title":"<code>test_test_setup_4</code>","text":"<p>In this test setup, the path <code>ElementA.RegisterA</code> can be resolved in multiple valid ways, similar to the previous setup. However, this time there is an additional <code>dim</code> configuration, which creates two clusters <code>ElementA</code> and <code>ElementB</code> within <code>PeripheralA</code>. Depending on how the algorithm is implemented, it could return <code>RegisterA</code> from either the <code>ElementA</code> peripheral or of the <code>ElementA</code> cluster within <code>PeripheralA</code>. Since the parser should follow the same resolution rules as <code>svdconv</code>, the expected behavior is that <code>RegisterA</code> within <code>PeripheralA</code> is found. The search should prioritize finding matches within the same scope first, and only expand to all peripherals if no match is found. Ultimately, <code>RegisterB</code> should inherit from <code>RegisterA</code> within <code>PeripheralA</code>, and it must therefore include <code>FieldB</code> instead of <code>FieldA</code>.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue.</p> <p>Processable with svdconv: partly</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(\n            \"ElementA.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"ElementB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"ElementA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_4(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    In this test setup, the path `ElementA.RegisterA` can be resolved in multiple valid ways, similar to the\n    previous setup. However, this time there is an additional `dim` configuration, which creates two clusters\n    `ElementA` and `ElementB` within `PeripheralA`. Depending on how the algorithm is implemented, it could return\n    `RegisterA` from either the `ElementA` peripheral or of the `ElementA` cluster within `PeripheralA`. Since the\n    parser should follow the same resolution rules as `svdconv`, the expected behavior is that `RegisterA` within\n    `PeripheralA` is found. The search should prioritize finding matches within the same scope first, and only\n    expand to all peripherals if no match is found. Ultimately, `RegisterB` should inherit from `RegisterA` within\n    `PeripheralA`, and it must therefore include `FieldB` instead of `FieldA`.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue.\n\n    **Processable with svdconv:** partly\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_4.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 2\n\n    assert device.peripherals[1].name == \"PeripheralA\"\n    assert len(device.peripherals[1].registers_clusters) == 3\n\n    assert isinstance(device.peripherals[1].registers_clusters[2], Register)\n    assert device.peripherals[1].registers_clusters[2].name == \"RegisterB\"\n    assert len(device.peripherals[1].registers_clusters[2].fields) == 1\n    assert device.peripherals[1].registers_clusters[2].fields[0].name == \"FieldB\"\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_4.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_4&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;ElementA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A,B&lt;/dimIndex&gt;\n          &lt;name&gt;Element%s&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;fields&gt;\n              &lt;field&gt;\n                &lt;name&gt;FieldB&lt;/name&gt;\n                &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n                &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;/field&gt;\n            &lt;/fields&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;register derivedFrom=\"PATH\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_5","title":"<code>test_test_setup_5</code>","text":"<p>Elements that use <code>dim</code> can be referenced in two ways: either by their name before the <code>dim</code> expansion (with <code>%s</code> within the name or <code>[%s]</code> at the end) or by their resolved name after the <code>dim</code> expansion. This test setup examines both methods of referencing <code>dim</code>-based elements. The test verifies whether the parser correctly identifies paths using both the pre-expansion placeholder (<code>Cluster%s</code>) and the fully expanded names (<code>ClusterA</code>, <code>ClusterB</code>). Paths that correctly reference the target elements should be processed without errors, while incorrect paths should trigger clear diagnostic messages. This setup ensures that the parser handles <code>dim</code>-expanded elements flexibly, similar to how <code>svdconv</code> resolves these references.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue.</p> <p>Processable with svdconv: partly</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(\n            \"PeripheralA.Cluster%s.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterA.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_5(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    Elements that use `dim` can be referenced in two ways: either by their name before the `dim` expansion (with\n    `%s` within the name or `[%s]` at the end) or by their resolved name after the `dim` expansion. This test\n    setup examines both methods of referencing `dim`-based elements. The test verifies whether the parser\n    correctly identifies paths using both the pre-expansion placeholder (`Cluster%s`) and the fully expanded names\n    (`ClusterA`, `ClusterB`). Paths that correctly reference the target elements should be processed without\n    errors, while incorrect paths should trigger clear diagnostic messages. This setup ensures that the parser\n    handles `dim`-expanded elements flexibly, similar to how `svdconv` resolves these references.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue.\n\n    **Processable with svdconv:** partly\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_5.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 2\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert len(device.peripherals[1].registers_clusters[0].fields) == 1\n    assert device.peripherals[1].registers_clusters[0].fields[0].name == \"FieldA\"\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_5.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_5&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A,B&lt;/dimIndex&gt;\n          &lt;name&gt;Cluster%s&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;fields&gt;\n              &lt;field&gt;\n                &lt;name&gt;FieldA&lt;/name&gt;\n                &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n                &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;/field&gt;\n            &lt;/fields&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"PATH\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_6","title":"<code>test_test_setup_6</code>","text":"<p>This test setup examines how the parser handles resolving paths for enumerated values within nested clusters.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue.</p> <p>Processable with svdconv: partly</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(\n            \"PeripheralA.ClusterA.ClusterB.RegisterA.FieldA.FieldAEnumeratedValue\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"ClusterA.ClusterB.RegisterA.FieldA.FieldAEnumeratedValue\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"ClusterB.RegisterA.FieldA.FieldAEnumeratedValue\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"RegisterA.FieldA.FieldAEnumeratedValue\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"FieldA.FieldAEnumeratedValue\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"FieldAEnumeratedValue\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_6(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    This test setup examines how the parser handles resolving paths for enumerated values within nested clusters.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue.\n\n    **Processable with svdconv:** partly\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_6.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"ClusterB\"\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters[0].registers_clusters) == 1\n    registera = device.peripherals[0].registers_clusters[0].registers_clusters[0].registers_clusters[0]\n    assert isinstance(registera, Register)\n    assert registera.name == \"RegisterA\"\n    assert len(registera.fields) == 2\n\n    assert registera.fields[0].name == \"FieldA\"\n    assert len(registera.fields[0].enumerated_value_containers) == 1\n    assert registera.fields[0].enumerated_value_containers[0].name == \"FieldAEnumeratedValue\"\n    assert len(registera.fields[0].enumerated_value_containers[0].enumerated_values) == 2\n\n    assert registera.fields[1].name == \"FieldB\"\n    assert len(registera.fields[1].enumerated_value_containers) == 1\n    assert registera.fields[1].enumerated_value_containers[0].name == \"FieldAEnumeratedValue\"\n    assert len(registera.fields[1].enumerated_value_containers[0].enumerated_values) == 2\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_6.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_6&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;cluster&gt;\n            &lt;name&gt;ClusterB&lt;/name&gt;\n            &lt;description&gt;ClusterB description&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;register&gt;\n              &lt;name&gt;RegisterA&lt;/name&gt;\n              &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n              &lt;fields&gt;\n                &lt;field&gt;\n                  &lt;name&gt;FieldA&lt;/name&gt;\n                  &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n                  &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n                  &lt;enumeratedValues&gt;\n                    &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                    &lt;usage&gt;read-write&lt;/usage&gt;\n                    &lt;enumeratedValue&gt;\n                      &lt;name&gt;0b0&lt;/name&gt;\n                      &lt;description&gt;Description for 0b0&lt;/description&gt;\n                      &lt;value&gt;0b0&lt;/value&gt;\n                    &lt;/enumeratedValue&gt;\n                    &lt;enumeratedValue&gt;\n                      &lt;name&gt;0b1&lt;/name&gt;\n                      &lt;description&gt;Description for 0b1&lt;/description&gt;\n                      &lt;value&gt;0b1&lt;/value&gt;\n                    &lt;/enumeratedValue&gt;\n                  &lt;/enumeratedValues&gt;\n                &lt;/field&gt;\n                &lt;field&gt;\n                  &lt;name&gt;FieldB&lt;/name&gt;\n                  &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n                  &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n                  &lt;enumeratedValues derivedFrom=\"PATH\"&gt;\n                  &lt;/enumeratedValues&gt;\n                &lt;/field&gt;\n              &lt;/fields&gt;\n            &lt;/register&gt;\n          &lt;/cluster&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_7","title":"<code>test_test_setup_7</code>","text":"<p>This test setup focuses on how the parser resolves <code>derivedFrom</code> paths when dealing with registers that have <code>alternateGroup</code> attributes. The <code>alternateGroup</code> is used to group registers that can function as alternatives to each other, and this test ensures that the parser correctly interprets and differentiates these alternate groups during path resolution. In this setup, <code>RegisterA</code> in <code>PeripheralB</code> is marked with an <code>alternateGroup</code> named <code>RegisterX</code>, while the same-named register in <code>PeripheralA</code> does not have this attribute. The goal is to verify that when the parser encounters a path pointing to <code>PeripheralB.RegisterA</code>, it can correctly identify <code>RegisterA</code> and handle the <code>alternateGroup</code> reference. Paths that explicitly specify <code>RegisterA_RegisterX</code> should resolve to <code>PeripheralB.RegisterA</code>, reflecting its alternate group, while paths that point to <code>PeripheralA.RegisterA</code> should reference the original register without any alternate association. <code>svdconv</code> can't resolve <code>alternateGroup</code> paths, if they are named equal as a element outside of the alternate group. A robust parser should be able to do so.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue.</p> <p>Processable with svdconv: partly</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(\n            \"PeripheralA.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralC.RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"PeripheralA.RegisterB\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n        pytest.param(\n            \"PeripheralB.RegisterB\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_7(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    This test setup focuses on how the parser resolves `derivedFrom` paths when dealing with registers that have\n    `alternateGroup` attributes. The `alternateGroup` is used to group registers that can function as alternatives\n    to each other, and this test ensures that the parser correctly interprets and differentiates these alternate\n    groups during path resolution. In this setup, `RegisterA` in `PeripheralB` is marked with an `alternateGroup`\n    named `RegisterX`, while the same-named register in `PeripheralA` does not have this attribute. The goal is to\n    verify that when the parser encounters a path pointing to `PeripheralB.RegisterA`, it can correctly identify\n    `RegisterA` and handle the `alternateGroup` reference. Paths that explicitly specify `RegisterA_RegisterX`\n    should resolve to `PeripheralB.RegisterA`, reflecting its alternate group, while paths that point to\n    `PeripheralA.RegisterA` should reference the original register without any alternate association. `svdconv`\n    can't resolve `alternateGroup` paths, if they are named equal as a element outside of the alternate group. A\n    robust parser should be able to do so.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue.\n\n    **Processable with svdconv:** partly\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_7.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 3\n\n    assert device.peripherals[2].name == \"PeripheralC\"\n    assert len(device.peripherals[2].registers_clusters) == 1\n    assert isinstance(device.peripherals[2].registers_clusters[0], Register)\n    assert device.peripherals[2].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[2].registers_clusters[0].description == \"PeripheralA_RegisterA\"\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_7.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_7&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;description&gt;PeripheralA_RegisterA&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;description&gt;PeripheralB_RegisterA&lt;/description&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"PATH\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_8","title":"<code>test_test_setup_8</code>","text":"<p>This test setup examines how the parser resolves <code>derivedFrom</code> references when inheritance cascades within clusters, specifically focusing on paths that ultimately reference a register created through inheritance. Here, <code>RegisterA</code> is initially defined within <code>ClusterA</code>. The second cluster, <code>ClusterB</code>, inherits properties from <code>ClusterA</code>, effectively creating an inherited version of <code>RegisterA</code> within <code>ClusterB</code>. Thus, while <code>RegisterA</code> is not explicitly present in <code>ClusterB</code> in the original SVD file, it becomes accessible there due to inheritance.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue.</p> <p>Processable with svdconv: partly</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(\n            \"ClusterA.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"ClusterB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterA.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_8(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    This test setup examines how the parser resolves `derivedFrom` references when inheritance cascades within\n    clusters, specifically focusing on paths that ultimately reference a register created through inheritance.\n    Here, `RegisterA` is initially defined within `ClusterA`. The second cluster, `ClusterB`, inherits properties\n    from `ClusterA`, effectively creating an inherited version of `RegisterA` within `ClusterB`. Thus, while\n    `RegisterA` is not explicitly present in `ClusterB` in the original SVD file, it becomes accessible there due\n    to inheritance.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue.\n\n    **Processable with svdconv:** partly\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_8.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterC\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0xC\n    assert device.peripherals[0].registers_clusters[2].size == 32\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_8.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_8&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;register derivedFrom=\"PATH\"&gt;\n          &lt;name&gt;RegisterC&lt;/name&gt;\n          &lt;addressOffset&gt;0xc&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_derived_from_path_resolving.html#tests.test_process.test_derived_from_path_resolving.test_test_setup_9","title":"<code>test_test_setup_9</code>","text":"<p>Same as Test Setup 8, but with a forward reference.</p> <p>Expected Outcome: Paths that correctly reference the target should be processed successfully. Invalid paths should raise an error, and the parser should provide clear diagnostics indicating the issue.</p> <p>Processable with svdconv: partly</p> Source code in <code>tests/test_process/test_derived_from_path_resolving.py</code> <pre><code>@pytest.mark.parametrize(\n    \"path\",\n    [\n        pytest.param(\n            \"ClusterA.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"ClusterB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterA.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"PeripheralA.ClusterB.RegisterA\",\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"RegisterA\",\n            marks=pytest.mark.xfail(strict=True, raises=ProcessException),\n        ),\n    ],\n)\ndef test_test_setup_9(path: str, get_test_svd_file_content: Callable[[str], bytes]):\n    \"\"\"\n    Same as Test Setup 8, but with a forward reference.\n\n    **Expected Outcome:** Paths that correctly reference the target should be processed successfully. Invalid paths\n    should raise an error, and the parser should provide clear diagnostics indicating the issue.\n\n    **Processable with svdconv:** partly\n    \"\"\"\n\n    file_name = \"derivedfrom_path_resolving/test_setup_9.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"PATH\", path.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterC\"\n    assert device.peripherals[0].registers_clusters[2].description == \"RegisterA description\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0xC\n    assert device.peripherals[0].registers_clusters[2].size == 32\n</code></pre> SVD file: <code>derivedfrom_path_resolving/test_setup_9.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test_setup_9&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"PATH\"&gt;\n          &lt;name&gt;RegisterC&lt;/name&gt;\n          &lt;addressOffset&gt;0xc&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;description&gt;RegisterA description&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster derivedFrom=\"ClusterA\"&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_development.html","title":"test_development","text":"<p>TODO Add description</p>"},{"location":"test_development.html#tests.test_process.test_development.test_algorithm","title":"<code>test_algorithm</code>","text":"<p>TODO: Add description</p> <p>Expected Outcome: TODO</p> <p>Processable with svdconv: TODO</p> Source code in <code>tests/test_process/test_development.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_algorithm(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    TODO: Add description\n\n    **Expected Outcome:** TODO\n\n    **Processable with svdconv:** TODO\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"development/algorithm.svd\")\n\n    assert len(device.peripherals) == 6\n\n    assert device.peripherals[0].name == \"ElementA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    fielda = device.peripherals[0].registers_clusters[0].registers_clusters[0].fields[0]\n    assert len(fielda.enumerated_value_containers) == 1\n    assert fielda.enumerated_value_containers[0].name is None\n\n    assert device.peripherals[1].name == \"PeripheralA\"\n    assert device.peripherals[1].base_address == 0x40002000\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Cluster)\n    assert device.peripherals[1].registers_clusters[0].name == \"ElementA\"\n    assert len(device.peripherals[1].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0].registers_clusters[0], Cluster)\n    assert device.peripherals[1].registers_clusters[0].registers_clusters[0].name == \"ClusterA\"\n    clustera = device.peripherals[1].registers_clusters[0].registers_clusters[0]\n    assert len(clustera.registers_clusters) == 1\n    assert isinstance(clustera.registers_clusters[0], Register)\n    assert clustera.registers_clusters[0].name == \"RegisterB\"\n    assert len(clustera.registers_clusters[0].fields) == 1\n    assert clustera.registers_clusters[0].fields[0].name == \"FieldA\"\n    assert len(clustera.registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    assert clustera.registers_clusters[0].fields[0].enumerated_value_containers[0].name is None\n\n    assert device.peripherals[2].name == \"Peripheral0\"\n    assert device.peripherals[2].base_address == 0x40003000\n    assert len(device.peripherals[2].registers_clusters) == 2\n    assert isinstance(device.peripherals[2].registers_clusters[0], Cluster)\n    assert device.peripherals[2].registers_clusters[0].name == \"ElementA\"\n    assert len(device.peripherals[2].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[2].registers_clusters[0].registers_clusters[0], Cluster)\n    assert device.peripherals[2].registers_clusters[0].registers_clusters[0].name == \"ClusterA\"\n    clustera = device.peripherals[2].registers_clusters[0].registers_clusters[0]\n    assert len(clustera.registers_clusters) == 1\n    assert isinstance(clustera.registers_clusters[0], Register)\n    assert clustera.registers_clusters[0].name == \"RegisterB\"\n    assert len(clustera.registers_clusters[0].fields) == 1\n    assert clustera.registers_clusters[0].fields[0].name == \"FieldA\"\n    assert len(clustera.registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    assert clustera.registers_clusters[0].fields[0].enumerated_value_containers[0].name is None\n    assert isinstance(device.peripherals[2].registers_clusters[1], Cluster)\n    assert device.peripherals[2].registers_clusters[1].name == \"ClusterA\"\n    assert len(device.peripherals[2].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[2].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[2].registers_clusters[1].registers_clusters[0].name == \"RegisterB\"\n    assert len(device.peripherals[2].registers_clusters[1].registers_clusters[0].fields) == 1\n    assert device.peripherals[2].registers_clusters[1].registers_clusters[0].fields[0].name == \"FieldA\"\n    fielda = device.peripherals[2].registers_clusters[1].registers_clusters[0].fields[0]\n    assert len(fielda.enumerated_value_containers) == 1\n    assert fielda.enumerated_value_containers[0].name is None\n\n    assert device.peripherals[3].name == \"Peripheral1\"\n    assert device.peripherals[3].base_address == 0x40004000\n    assert len(device.peripherals[3].registers_clusters) == 2\n    assert isinstance(device.peripherals[3].registers_clusters[0], Cluster)\n    assert device.peripherals[3].registers_clusters[0].name == \"ElementA\"\n    assert len(device.peripherals[3].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[3].registers_clusters[0].registers_clusters[0], Cluster)\n    assert device.peripherals[3].registers_clusters[0].registers_clusters[0].name == \"ClusterA\"\n    clustera = device.peripherals[3].registers_clusters[0].registers_clusters[0]\n    assert len(clustera.registers_clusters) == 1\n    assert isinstance(clustera.registers_clusters[0], Register)\n    assert clustera.registers_clusters[0].name == \"RegisterB\"\n    assert len(clustera.registers_clusters[0].fields) == 1\n    assert clustera.registers_clusters[0].fields[0].name == \"FieldA\"\n    assert len(clustera.registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    assert clustera.registers_clusters[0].fields[0].enumerated_value_containers[0].name is None\n    assert isinstance(device.peripherals[3].registers_clusters[1], Cluster)\n    assert device.peripherals[3].registers_clusters[1].name == \"ClusterA\"\n    assert len(device.peripherals[3].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[3].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[3].registers_clusters[1].registers_clusters[0].name == \"RegisterB\"\n    assert len(device.peripherals[3].registers_clusters[1].registers_clusters[0].fields) == 1\n    assert device.peripherals[3].registers_clusters[1].registers_clusters[0].fields[0].name == \"FieldA\"\n    fielda = device.peripherals[3].registers_clusters[1].registers_clusters[0].fields[0]\n    assert len(fielda.enumerated_value_containers) == 1\n    assert fielda.enumerated_value_containers[0].name is None\n\n    assert device.peripherals[4].name == \"PeripheralB\"\n    assert device.peripherals[4].base_address == 0x40005000\n    assert len(device.peripherals[4].registers_clusters) == 1\n    assert isinstance(device.peripherals[4].registers_clusters[0], Register)\n    assert device.peripherals[4].registers_clusters[0].name == \"RegisterA\"\n    assert len(device.peripherals[4].registers_clusters[0].fields) == 1\n    assert device.peripherals[4].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert len(device.peripherals[4].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    assert device.peripherals[4].registers_clusters[0].fields[0].enumerated_value_containers[0].name is None\n\n    assert device.peripherals[5].name == \"PeripheralC\"\n    assert device.peripherals[5].base_address == 0x40006000\n    assert len(device.peripherals[5].registers_clusters) == 1\n    assert isinstance(device.peripherals[5].registers_clusters[0], Register)\n    assert device.peripherals[5].registers_clusters[0].name == \"RegisterA\"\n    assert len(device.peripherals[5].registers_clusters[0].fields) == 1\n    assert device.peripherals[5].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert len(device.peripherals[5].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    assert device.peripherals[5].registers_clusters[0].fields[0].enumerated_value_containers[0].name is None\n</code></pre> SVD file: <code>development/algorithm.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;algorithm&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;ElementA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;fields&gt;\n              &lt;field&gt;\n                &lt;name&gt;FieldA&lt;/name&gt;\n                &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n                &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n                &lt;enumeratedValues&gt;\n                  &lt;enumeratedValue&gt;\n                    &lt;name&gt;ValueA&lt;/name&gt;\n                    &lt;description&gt;ValueA description&lt;/description&gt;\n                    &lt;value&gt;0&lt;/value&gt;\n                  &lt;/enumeratedValue&gt;\n                  &lt;enumeratedValue&gt;\n                    &lt;name&gt;ValueB&lt;/name&gt;\n                    &lt;description&gt;ValueB description&lt;/description&gt;\n                    &lt;value&gt;1&lt;/value&gt;\n                  &lt;/enumeratedValue&gt;\n                &lt;/enumeratedValues&gt;\n              &lt;/field&gt;\n            &lt;/fields&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ElementA&lt;/name&gt;\n          &lt;description&gt;ElementA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;cluster&gt;\n            &lt;name&gt;ClusterA&lt;/name&gt;\n            &lt;description&gt;ClusterA description&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;register derivedFrom=\"ElementA.ClusterA.RegisterA\"&gt;\n              &lt;name&gt;RegisterB&lt;/name&gt;\n              &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;/register&gt;\n          &lt;/cluster&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;dim&gt;2&lt;/dim&gt;\n      &lt;dimIncrement&gt;0x1000&lt;/dimIncrement&gt;\n      &lt;name&gt;Peripheral[%s]&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster derivedFrom=\"ElementA.ClusterA\"&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40005000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"Peripheral1.ClusterA.RegisterB\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;baseAddress&gt;0x40006000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"Peripheral[%s].ClusterA.RegisterB\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_development.html#tests.test_process.test_development.test_peripheral_level","title":"<code>test_peripheral_level</code>","text":"<p>TODO: Add description</p> <p>Expected Outcome: TODO</p> <p>Processable with svdconv: TODO</p> Source code in <code>tests/test_process/test_development.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_peripheral_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    TODO: Add description\n\n    **Expected Outcome:** TODO\n\n    **Processable with svdconv:** TODO\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"development/peripheral_level.svd\")\n\n    assert len(device.peripherals) == 14\n\n    assert device.peripherals[0].name == \"PeripheralA0\"\n    assert device.peripherals[0].base_address == 0x40001000\n\n    assert device.peripherals[1].name == \"PeripheralA1\"\n    assert device.peripherals[1].base_address == 0x40002000\n\n    assert device.peripherals[2].name == \"PeripheralB\"\n    assert device.peripherals[2].base_address == 0x40003000\n\n    assert device.peripherals[3].name == \"PeripheralC0\"\n    assert device.peripherals[3].base_address == 0x40004000\n\n    assert device.peripherals[4].name == \"PeripheralC1\"\n    assert device.peripherals[4].base_address == 0x40005000\n\n    assert device.peripherals[5].name == \"PeripheralD\"\n    assert device.peripherals[5].base_address == 0x40006000\n\n    assert device.peripherals[6].name == \"PeripheralE0\"\n    assert device.peripherals[6].base_address == 0x40007000\n\n    assert device.peripherals[7].name == \"PeripheralE1\"\n    assert device.peripherals[7].base_address == 0x40008000\n\n    assert device.peripherals[8].name == \"PeripheralF\"\n    assert device.peripherals[8].base_address == 0x40009000\n\n    assert device.peripherals[9].name == \"PeripheralG0\"\n    assert device.peripherals[9].base_address == 0x4000A000\n\n    assert device.peripherals[10].name == \"PeripheralG1\"\n    assert device.peripherals[10].base_address == 0x4000B000\n\n    assert device.peripherals[11].name == \"PeripheralH\"\n    assert device.peripherals[11].base_address == 0x4000C000\n\n    assert device.peripherals[12].name == \"PeripheralI\"\n    assert device.peripherals[12].base_address == 0x4000D000\n\n    assert device.peripherals[13].name == \"PeripheralJ\"\n    assert device.peripherals[13].base_address == 0x4000E000\n</code></pre> SVD file: <code>development/peripheral_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;test&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;dim&gt;2&lt;/dim&gt;\n      &lt;dimIncrement&gt;0x1000&lt;/dimIncrement&gt;\n      &lt;name&gt;PeripheralA[%s]&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralE1\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralE[%s]\"&gt;\n      &lt;name&gt;PeripheralC[%s]&lt;/name&gt;\n      &lt;baseAddress&gt;0x40004000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralD&lt;/name&gt;\n      &lt;baseAddress&gt;0x40006000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralG[%s]\"&gt;\n      &lt;name&gt;PeripheralE[%s]&lt;/name&gt;\n      &lt;baseAddress&gt;0x40007000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralC0\"&gt;\n      &lt;name&gt;PeripheralF&lt;/name&gt;\n      &lt;baseAddress&gt;0x40009000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;dim&gt;2&lt;/dim&gt;\n      &lt;dimIncrement&gt;0x1000&lt;/dimIncrement&gt;\n      &lt;name&gt;PeripheralG[%s]&lt;/name&gt;\n      &lt;baseAddress&gt;0x4000a000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralE1\"&gt;\n      &lt;name&gt;PeripheralH&lt;/name&gt;\n      &lt;baseAddress&gt;0x4000c000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralI&lt;/name&gt;\n      &lt;baseAddress&gt;0x4000d000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralI\"&gt;\n      &lt;name&gt;PeripheralJ&lt;/name&gt;\n      &lt;baseAddress&gt;0x4000e000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html","title":"test_dim_handling","text":"<p>The <code>dim</code> element in the CMSIS SVD standard is a powerful feature used to define arrays or lists of repeated elements such as peripherals, registers, clusters, or fields. It enables the efficient creation of multiple instances of an object by using a few key attributes rather than duplicating entries.</p> <p>When working with arrays or lists, the <code>dim</code> element specifies the number of instances, while <code>dimIncrement</code> defines the memory address offset between consecutive elements. The <code>dimIndex</code> placeholder is used to provide custom names for each instance, making it possible to generate meaningful and distinct names for each list element. Additionally, the <code>dimName</code> can be defined to specify custom C-type structures if needed.</p> <p>This chapter tests the parser\u2019s ability to handle <code>dim</code> lists and arrays across various hierarchical levels, ensuring correct expansion and interpretation of arrays and lists at the peripheral, register, cluster, and field levels. The test cases ensure that all elements are properly expanded, their addresses are correctly calculated, and the parser processes arrays and lists as specified by the <code>dim</code> attributes, while adhering to the memory layout requirements.</p>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_array_displayname_with_dim","title":"<code>test_array_displayname_with_dim</code>","text":"<p>This test case checks how the parser handles an array of registers where each register is assigned a distinct <code>displayName</code> that follows the <code>dim</code> definition. The <code>dim</code> element is used to create an array of registers, and the <code>displayName</code> field should update accordingly for each register instance. <code>svdconv</code> processes this case without issues, and the parser is expected to follow similar behavior, correctly assigning the appropriate <code>displayName</code> to each register in the array.</p> <p>Expected Outcome: The parser should successfully process the file, creating an array of registers. For each register, the <code>displayName</code> should match the respective register name. In this case, <code>Register0</code> and <code>Register1</code> should be created, with corresponding <code>displayName</code> values of \"Register0\" and \"Register1\". The <code>addressOffset</code> and <code>size</code> values for both registers should also be correctly set to <code>0x0</code> and <code>0x4</code> respectively, with a size of 32 bits.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_array_displayname_with_dim(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case checks how the parser handles an array of registers where each register is assigned a distinct\n    `displayName` that follows the `dim` definition. The `dim` element is used to create an array of registers,\n    and the `displayName` field should update accordingly for each register instance. `svdconv` processes this\n    case without issues, and the parser is expected to follow similar behavior, correctly assigning the\n    appropriate `displayName` to each register in the array.\n\n    **Expected Outcome:** The parser should successfully process the file, creating an array of registers. For each\n    register, the `displayName` should match the respective register name. In this case, `Register0` and\n    `Register1` should be created, with corresponding `displayName` values of \"Register0\" and \"Register1\". The\n    `addressOffset` and `size` values for both registers should also be correctly set to `0x0` and `0x4`\n    respectively, with a size of 32 bits.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"dim_handling/array_displayname_with_dim.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"Register0\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].display_name == \"Register0\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"Register1\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].display_name == \"Register1\"\n</code></pre> SVD file: <code>dim_handling/array_displayname_with_dim.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;array_displayname_with_dim&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;name&gt;Register[%s]&lt;/name&gt;\n          &lt;displayName&gt;Register[%s]&lt;/displayName&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_array_displayname_without_dim","title":"<code>test_array_displayname_without_dim</code>","text":"<p>This test case verifies that the parser correctly identifies a misconfiguration where a <code>displayName</code> contains an expression marker (<code>[%s]</code>) without the corresponding <code>dim</code> element. In such cases, <code>svdconv</code> raises an error because the <code>displayName</code> expects a <code>dim</code> array to provide the necessary index substitutions. The parser should similarly detect this issue and raise an appropriate error, as the <code>displayName</code> cannot be processed without the <code>dim</code> element.</p> <p>Expected Outcome: The parser should raise an error indicating that an expression marker (<code>[%s]</code>) was found in the <code>displayName</code>, but no corresponding <code>dim</code> element was provided. This behavior mirrors the error raised by <code>svdconv</code> in such situations. The peripheral should not be created, and the parser should stop processing this file due to the configuration error.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Expression marker [%s] found in displayName but no &lt;dim&gt; specified\",\n)\ndef test_array_displayname_without_dim(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case verifies that the parser correctly identifies a misconfiguration where a `displayName` contains\n    an expression marker (`[%s]`) without the corresponding `dim` element. In such cases, `svdconv` raises an\n    error because the `displayName` expects a `dim` array to provide the necessary index substitutions. The parser\n    should similarly detect this issue and raise an appropriate error, as the `displayName` cannot be processed\n    without the `dim` element.\n\n    **Expected Outcome:** The parser should raise an error indicating that an expression marker (`[%s]`) was found in\n    the `displayName`, but no corresponding `dim` element was provided. This behavior mirrors the error raised by\n    `svdconv` in such situations. The peripheral should not be created, and the parser should stop processing this\n    file due to the configuration error.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/array_displayname_without_dim.svd\")\n</code></pre> SVD file: <code>dim_handling/array_displayname_without_dim.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;array_displayname_without_dim&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;displayName&gt;Register[%s]&lt;/displayName&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_array_without_dim_cluster_level","title":"<code>test_dim_array_without_dim_cluster_level</code>","text":"<p>This test checks how the parser handles a cluster with an array-like naming convention but without the corresponding <code>dim</code> element. The array naming style is present, but the <code>dim</code> element is missing. The parser should detect this and raise an error, as arrays require the <code>dim</code> element to define the instances. <code>svdconv</code> does not print an error or warning for this test case, but ignores the cluster. This seems to be a bug in <code>svdconv</code>.</p> <p>Expected Outcome: The parser should fail to process the SVD file, raising an error because a cluster name indicates an array, but the <code>dim</code> element is missing. This behavior is not consistent with the outcome in <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Found dim-array in name without dim\",\n)\ndef test_dim_array_without_dim_cluster_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles a cluster with an array-like naming convention but without the\n    corresponding `dim` element. The array naming style is present, but the `dim` element is missing. The parser\n    should detect this and raise an error, as arrays require the `dim` element to define the instances. `svdconv`\n    does not print an error or warning for this test case, but ignores the cluster. This seems to be a bug in\n    `svdconv`.\n\n    **Expected Outcome:** The parser should fail to process the SVD file, raising an error because a cluster name\n    indicates an array, but the `dim` element is missing. This behavior is **not** consistent with the outcome in\n    `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_array_without_dim_cluster_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_array_without_dim_cluster_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_array_without_dim_cluster_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;Cluster[%s]&lt;/name&gt;\n          &lt;description&gt;Cluster description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_array_without_dim_peripheral_level","title":"<code>test_dim_array_without_dim_peripheral_level</code>","text":"<p>This test verifies how the parser handles a situation where an array-like naming convention is used at the peripheral level without defining the <code>dim</code> element. In this SVD file, a <code>dim</code>-style array name is present, but the corresponding <code>dim</code> element is missing. The parser must detect this inconsistency and raise an error, as arrays require the <code>dim</code> element to define the number of instances.</p> <p>Expected Outcome: The parser should fail to process the SVD file and raise an error. The reason for this error is the presence of an array-like name at the peripheral level without a corresponding <code>dim</code> element, which is necessary to define the array's structure. This behavior is consistent with the expected outcome in <code>svdconv</code>.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Found dim-array in name without dim\",\n)\ndef test_dim_array_without_dim_peripheral_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies how the parser handles a situation where an array-like naming convention is used at the\n    peripheral level without defining the `dim` element. In this SVD file, a `dim`-style array name is present,\n    but the corresponding `dim` element is missing. The parser must detect this inconsistency and raise an error,\n    as arrays require the `dim` element to define the number of instances.\n\n    **Expected Outcome:** The parser should fail to process the SVD file and raise an error. The reason for this error\n    is the presence of an array-like name at the peripheral level without a corresponding `dim` element, which is\n    necessary to define the array's structure. This behavior is consistent with the expected outcome in `svdconv`.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_array_without_dim_peripheral_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_array_without_dim_peripheral_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_array_without_dim_peripheral_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;Peripheral[%s]&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_array_without_dim_register_level","title":"<code>test_dim_array_without_dim_register_level</code>","text":"<p>This test evaluates how the parser handles registers named as arrays without the corresponding <code>dim</code> element. The array-like naming convention is used without defining the <code>dim</code> element, and the parser should raise an error.</p> <p>Expected Outcome: The parser should raise an error when processing the file, as a register name implies an array but lacks the <code>dim</code> element. The behavior should match <code>svdconv</code> expectations.</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Found dim-array in name without dim\",\n)\ndef test_dim_array_without_dim_register_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the parser handles registers named as arrays without the corresponding `dim` element.\n    The array-like naming convention is used without defining the `dim` element, and the parser should raise an\n    error.\n\n    **Expected Outcome:** The parser should raise an error when processing the file, as a register name implies an\n    array but lacks the `dim` element. The behavior should match `svdconv` expectations.\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_array_without_dim_register_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_array_without_dim_register_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_array_without_dim_register_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;Register[%s]&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_list_without_dim_cluster_level","title":"<code>test_dim_list_without_dim_cluster_level</code>","text":"<p>This test checks how the parser handles clusters that are named as lists without defining the <code>dim</code> element. The list-like naming convention without <code>dim</code> should result in an error. <code>svdconv</code> does not print an error or warning for this test case, but ignores the cluster. This seems to be a bug in <code>svdconv</code>.</p> <p>Expected Outcome: The parser should raise an error due to the missing <code>dim</code> element for a list-style cluster name. This does not align with <code>svdconv</code> behavior.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Found dim-list in name without dim\",\n)\ndef test_dim_list_without_dim_cluster_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles clusters that are named as lists without defining the `dim` element.\n    The list-like naming convention without `dim` should result in an error. `svdconv` does not print an error or\n    warning for this test case, but ignores the cluster. This seems to be a bug in `svdconv`.\n\n    **Expected Outcome:** The parser should raise an error due to the missing `dim` element for a list-style cluster\n    name. This **does not** align with `svdconv` behavior.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_list_without_dim_cluster_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_list_without_dim_cluster_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_list_without_dim_cluster_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;Cluster%s&lt;/name&gt;\n          &lt;description&gt;Cluster description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_list_without_dim_field_level","title":"<code>test_dim_list_without_dim_field_level</code>","text":"<p>This test checks how the parser handles fields named as lists without the <code>dim</code> element. The parser should raise an error for list-style fields lacking the <code>dim</code> element. <code>svdconv</code> does not print an error or warning for this test case, but ignores the field. This seems to be a bug in <code>svdconv</code>.</p> <p>Expected Outcome: The parser should raise an error due to the absence of a <code>dim</code> element for a list-style field name. This behavior is not consistent with <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Found dim-list in name without dim\",\n)\ndef test_dim_list_without_dim_field_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles fields named as lists without the `dim` element. The parser should\n    raise an error for list-style fields lacking the `dim` element. `svdconv` does not print an error or warning\n    for this test case, but ignores the field. This seems to be a bug in `svdconv`.\n\n    **Expected Outcome:** The parser should raise an error due to the absence of a `dim` element for a list-style\n    field name. This behavior is **not** consistent with `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_list_without_dim_field_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_list_without_dim_field_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_list_without_dim_field_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;Field%s&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;2&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_list_without_dim_register_level","title":"<code>test_dim_list_without_dim_register_level</code>","text":"<p>This test verifies how the parser handles registers named as lists without a <code>dim</code> element. The list-style naming convention without <code>dim</code> should result in an error.</p> <p>Expected Outcome: The parser should raise an error due to the absence of a <code>dim</code> element for a list-style register name, consistent with <code>svdconv</code>.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Found dim-list in name without dim\",\n)\ndef test_dim_list_without_dim_register_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies how the parser handles registers named as lists without a `dim` element. The list-style\n    naming convention without `dim` should result in an error.\n\n    **Expected Outcome:** The parser should raise an error due to the absence of a `dim` element for a list-style\n    register name, consistent with `svdconv`.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_list_without_dim_register_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_list_without_dim_register_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_list_without_dim_register_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_list_wrong_dimindex_cluster_level","title":"<code>test_dim_list_wrong_dimindex_cluster_level</code>","text":"<p>This test checks how the parser handles a situation where the <code>dim</code> and <code>dimIndex</code> elements at the cluster level are inconsistent. In this case, the number of elements defined in <code>dimIndex</code> does not match the number of <code>dim</code> instances. This mismatch should result in an error, as the parser expects the number of <code>dimIndex</code> elements to exactly match the <code>dim</code> count.</p> <p>Expected Outcome: The parser should fail to process the SVD file and raise an error. The error should clearly state that the number of <code>dimIndex</code> elements is different from the number of <code>dim</code> instances, which is consistent with how <code>svdconv</code> handles this type of error.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Number of &lt;dimIndex&gt; Elements is different to number of &lt;dim&gt; instances\",\n)\ndef test_dim_list_wrong_dimindex_cluster_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles a situation where the `dim` and `dimIndex` elements at the cluster\n    level are inconsistent. In this case, the number of elements defined in `dimIndex` does not match the number\n    of `dim` instances. This mismatch should result in an error, as the parser expects the number of `dimIndex`\n    elements to exactly match the `dim` count.\n\n    **Expected Outcome:** The parser should fail to process the SVD file and raise an error. The error should clearly\n    state that the number of `dimIndex` elements is different from the number of `dim` instances, which is\n    consistent with how `svdconv` handles this type of error.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_list_wrong_dimindex_cluster_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_list_wrong_dimindex_cluster_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_list_wrong_dimindex_cluster_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x8&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A,B,C&lt;/dimIndex&gt;\n          &lt;name&gt;Cluster%s&lt;/name&gt;\n          &lt;description&gt;Cluster description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_list_wrong_dimindex_field_level","title":"<code>test_dim_list_wrong_dimindex_field_level</code>","text":"<p>This test evaluates how the parser handles a situation where the number of <code>dimIndex</code> elements does not match the number of <code>dim</code> instances at the field level. Such a mismatch between the <code>dim</code> and <code>dimIndex</code> lists should cause an error, as the parser requires the number of entries in both lists to be consistent.</p> <p>Expected Outcome: The parser should raise an error, signaling that the number of <code>dimIndex</code> elements is different from the number of <code>dim</code> instances. This outcome matches the behavior expected from <code>svdconv</code>, which also raises an error when encountering such a discrepancy in the <code>dim</code> and <code>dimIndex</code> configuration at the field level.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Number of &lt;dimIndex&gt; Elements is different to number of &lt;dim&gt; instances\",\n)\ndef test_dim_list_wrong_dimindex_field_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the parser handles a situation where the number of `dimIndex` elements does not match\n    the number of `dim` instances at the field level. Such a mismatch between the `dim` and `dimIndex` lists\n    should cause an error, as the parser requires the number of entries in both lists to be consistent.\n\n    **Expected Outcome:** The parser should raise an error, signaling that the number of `dimIndex` elements is\n    different from the number of `dim` instances. This outcome matches the behavior expected from `svdconv`, which\n    also raises an error when encountering such a discrepancy in the `dim` and `dimIndex` configuration at the\n    field level.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_list_wrong_dimindex_field_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_list_wrong_dimindex_field_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_list_wrong_dimindex_field_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;dim&gt;2&lt;/dim&gt;\n              &lt;dimIncrement&gt;0x2&lt;/dimIncrement&gt;\n              &lt;dimIndex&gt;A,B,C&lt;/dimIndex&gt;\n              &lt;name&gt;Field%s&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;2&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_dim_list_wrong_dimindex_register_level","title":"<code>test_dim_list_wrong_dimindex_register_level</code>","text":"<p>This test examines the behavior of the parser when the <code>dim</code> and <code>dimIndex</code> elements at the register level are inconsistent. Specifically, the number of elements in the <code>dimIndex</code> list does not match the number of instances defined by the <code>dim</code> element. This mismatch should cause an error, as the parser requires the number of <code>dimIndex</code> elements to correspond exactly to the <code>dim</code> count.</p> <p>Expected Outcome: The parser should fail to process the SVD file and raise an error, indicating that the number of <code>dimIndex</code> elements is different from the number of <code>dim</code> instances. This error is expected to align with the behavior of <code>svdconv</code>, which also raises an error for this type of discrepancy.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Number of &lt;dimIndex&gt; Elements is different to number of &lt;dim&gt; instances\",\n)\ndef test_dim_list_wrong_dimindex_register_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test examines the behavior of the parser when the `dim` and `dimIndex` elements at the register level are\n    inconsistent. Specifically, the number of elements in the `dimIndex` list does not match the number of\n    instances defined by the `dim` element. This mismatch should cause an error, as the parser requires the number\n    of `dimIndex` elements to correspond exactly to the `dim` count.\n\n    **Expected Outcome:** The parser should fail to process the SVD file and raise an error, indicating that the\n    number of `dimIndex` elements is different from the number of `dim` instances. This error is expected to align\n    with the behavior of `svdconv`, which also raises an error for this type of discrepancy.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/dim_list_wrong_dimindex_register_level.svd\")\n</code></pre> SVD file: <code>dim_handling/dim_list_wrong_dimindex_register_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;dim_list_wrong_dimindex_register_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A,B,C&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_list_displayname_with_dim","title":"<code>test_list_displayname_with_dim</code>","text":"<p>This test case examines how the parser handles a list of registers using the <code>dim</code> element, where each register has a unique <code>displayName</code>. The <code>dim</code> and <code>dimIndex</code> elements are used to generate multiple instances of registers, and the parser must ensure that the correct <code>displayName</code> is applied to each instance based on its corresponding entry in the <code>dimIndex</code>. <code>svdconv</code> processes this case correctly, and the parser is expected to do the same, creating the appropriate registers with distinct <code>displayName</code> fields.</p> <p>Expected Outcome: The parser should successfully process the file and create two registers with the names <code>RegisterA</code> and <code>RegisterB</code>, using the <code>dimIndex</code> to distinguish between them. Both registers should have correct <code>addressOffset</code> values of <code>0x0</code> and <code>0x4</code> respectively, and a size of 32 bits. Additionally, the <code>displayName</code> for <code>RegisterA</code> should be \"RegisterA\", and for <code>RegisterB</code> it should be \"RegisterB\", matching their names and offsets.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_list_displayname_with_dim(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines how the parser handles a list of registers using the `dim` element, where each\n    register has a unique `displayName`. The `dim` and `dimIndex` elements are used to generate multiple instances\n    of registers, and the parser must ensure that the correct `displayName` is applied to each instance based on\n    its corresponding entry in the `dimIndex`. `svdconv` processes this case correctly, and the parser is expected\n    to do the same, creating the appropriate registers with distinct `displayName` fields.\n\n    **Expected Outcome:** The parser should successfully process the file and create two registers with the names\n    `RegisterA` and `RegisterB`, using the `dimIndex` to distinguish between them. Both registers should have\n    correct `addressOffset` values of `0x0` and `0x4` respectively, and a size of 32 bits. Additionally, the\n    `displayName` for `RegisterA` should be \"RegisterA\", and for `RegisterB` it should be \"RegisterB\", matching\n    their names and offsets.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"dim_handling/list_displayname_with_dim.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].display_name == \"RegisterA\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].display_name == \"RegisterB\"\n</code></pre> SVD file: <code>dim_handling/list_displayname_with_dim.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;list_displayname_with_dim&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A,B&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;displayName&gt;Register%s&lt;/displayName&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_list_displayname_without_dim","title":"<code>test_list_displayname_without_dim</code>","text":"<p>This test case verifies that the parser correctly identifies a misconfiguration where a <code>displayName</code> contains an expression marker (<code>%s</code>) without the corresponding <code>dim</code> element. In such cases, <code>svdconv</code> raises an error because the <code>displayName</code> expects a <code>dim</code> list to provide the necessary index substitutions. The parser should similarly detect this issue and raise an appropriate error, as the <code>displayName</code> cannot be processed without the <code>dim</code> element.</p> <p>Expected Outcome: The parser should raise an error indicating that an expression marker (<code>%s</code>) was found in the <code>displayName</code>, but no corresponding <code>dim</code> element was provided. This behavior mirrors the error raised by <code>svdconv</code> in such situations. The peripheral should not be created, and the parser should stop processing this file due to the configuration error.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Expression marker [%s] found in displayName but no &lt;dim&gt; specified\",\n)\ndef test_list_displayname_without_dim(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case verifies that the parser correctly identifies a misconfiguration where a `displayName` contains\n    an expression marker (`%s`) without the corresponding `dim` element. In such cases, `svdconv` raises an error\n    because the `displayName` expects a `dim` list to provide the necessary index substitutions. The parser should\n    similarly detect this issue and raise an appropriate error, as the `displayName` cannot be processed without\n    the `dim` element.\n\n    **Expected Outcome:** The parser should raise an error indicating that an expression marker (`%s`) was found in\n    the `displayName`, but no corresponding `dim` element was provided. This behavior mirrors the error raised by\n    `svdconv` in such situations. The peripheral should not be created, and the parser should stop processing this\n    file due to the configuration error.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/list_displayname_without_dim.svd\")\n</code></pre> SVD file: <code>dim_handling/list_displayname_without_dim.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;list_displayname_without_dim&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;displayName&gt;Register%s&lt;/displayName&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_simple_array_cluster_level","title":"<code>test_simple_array_cluster_level</code>","text":"<p>This test case checks the parser's ability to correctly handle arrays defined at the cluster level. The <code>dim</code> element is used to generate multiple instances of clusters, with each cluster containing a set of registers. The parser must correctly expand the array, calculate the memory offsets, and ensure that all registers within each cluster are properly processed.</p> <p>Expected Outcome: The parser should successfully generate two instances of the cluster, each containing two registers. The first cluster should be named <code>Cluster0</code> with a base address offset of <code>0x0</code>, and the second cluster should be named <code>Cluster1</code> with a base address offset of <code>0x8</code>. Each cluster should contain two registers: <code>RegisterA</code> and <code>RegisterB</code>, with correct memory offsets.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_array_cluster_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case checks the parser's ability to correctly handle arrays defined at the cluster level. The `dim`\n    element is used to generate multiple instances of clusters, with each cluster containing a set of registers.\n    The parser must correctly expand the array, calculate the memory offsets, and ensure that all registers within\n    each cluster are properly processed.\n\n    **Expected Outcome:** The parser should successfully generate two instances of the cluster, each containing two\n    registers. The first cluster should be named `Cluster0` with a base address offset of `0x0`, and the second\n    cluster should be named `Cluster1` with a base address offset of `0x8`. Each cluster should contain two\n    registers: `RegisterA` and `RegisterB`, with correct memory offsets.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"dim_handling/simple_array_cluster_level.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"Cluster0\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"Cluster1\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>dim_handling/simple_array_cluster_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_array_cluster_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x8&lt;/dimIncrement&gt;\n          &lt;name&gt;Cluster[%s]&lt;/name&gt;\n          &lt;description&gt;Cluster description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_simple_array_field_level","title":"<code>test_simple_array_field_level</code>","text":"<p>This test examines whether the parser correctly handles arrays defined at the field level within a register. In the SVD file, the <code>dim</code> element is used to define an array of fields inside a register. However, in <code>svdconv</code>, fields cannot be arrays, which results in an error. The parser should likewise detect and handle this case, raising an appropriate exception or error.</p> <p>Expected Outcome: The parser should fail to process the file, raising an exception due to the invalid use of a <code>dim</code> array at the field level. The error message should indicate that fields cannot be defined as arrays, mirroring the behavior of <code>svdconv</code>.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Field cannot be an array\",\n)\ndef test_simple_array_field_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test examines whether the parser correctly handles arrays defined at the field level within a register.\n    In the SVD file, the `dim` element is used to define an array of fields inside a register. However, in\n    `svdconv`, fields cannot be arrays, which results in an error. The parser should likewise detect and handle\n    this case, raising an appropriate exception or error.\n\n    **Expected Outcome:** The parser should fail to process the file, raising an exception due to the invalid use of a\n    `dim` array at the field level. The error message should indicate that fields cannot be defined as arrays,\n    mirroring the behavior of `svdconv`.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/simple_array_field_level.svd\")\n</code></pre> SVD file: <code>dim_handling/simple_array_field_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_array_field_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;dim&gt;2&lt;/dim&gt;\n              &lt;dimIncrement&gt;0x2&lt;/dimIncrement&gt;\n              &lt;name&gt;Field[%s]&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;2&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_simple_array_peripheral_level","title":"<code>test_simple_array_peripheral_level</code>","text":"<p>This test validates whether the parser correctly handles arrays at the peripheral level using <code>dim</code> and <code>dimIncrement</code>. The SVD file defines an array of peripherals, each containing registers with identical configurations. The test ensures that the array is expanded correctly, with the proper base addresses for each peripheral and the corresponding registers.</p> <p>Expected Outcome: The parser should process the array defined at the peripheral level, resulting in two peripherals, <code>Peripheral0</code> and <code>Peripheral1</code>, each having a base address and identical register configurations. <code>Peripheral0</code> should have a base address of <code>0x40001000</code>, while <code>Peripheral1</code> should have a base address of <code>0x40002000</code>. Both peripherals should contain two registers, <code>RegisterA</code> at address offset <code>0x0</code> and <code>RegisterB</code> at address offset <code>0x4</code>. The parser must expand the peripheral array as expected and assign the correct addresses to each register without any errors.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_array_peripheral_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test validates whether the parser correctly handles arrays at the peripheral level using `dim` and\n    `dimIncrement`. The SVD file defines an array of peripherals, each containing registers with identical\n    configurations. The test ensures that the array is expanded correctly, with the proper base addresses for each\n    peripheral and the corresponding registers.\n\n    **Expected Outcome:** The parser should process the array defined at the peripheral level, resulting in two\n    peripherals, `Peripheral0` and `Peripheral1`, each having a base address and identical register\n    configurations. `Peripheral0` should have a base address of `0x40001000`, while `Peripheral1` should have a\n    base address of `0x40002000`. Both peripherals should contain two registers, `RegisterA` at address offset\n    `0x0` and `RegisterB` at address offset `0x4`. The parser must expand the peripheral array as expected and\n    assign the correct addresses to each register without any errors.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"dim_handling/simple_array_peripheral_level.svd\")\n\n    assert len(device.peripherals) == 2\n\n    assert device.peripherals[0].name == \"Peripheral0\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert device.peripherals[0].size == 32\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n\n    assert device.peripherals[1].name == \"Peripheral1\"\n    assert device.peripherals[1].base_address == 0x40002000\n    assert device.peripherals[1].size == 32\n    assert len(device.peripherals[1].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[1].registers_clusters[1], Register)\n    assert device.peripherals[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[1].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[1].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>dim_handling/simple_array_peripheral_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_array_peripheral_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;dim&gt;2&lt;/dim&gt;\n      &lt;dimIncrement&gt;0x1000&lt;/dimIncrement&gt;\n      &lt;name&gt;Peripheral[%s]&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_simple_array_register_level","title":"<code>test_simple_array_register_level</code>","text":"<p>This test checks the parser's ability to handle arrays defined at the register level. The <code>dim</code> element is used to create an array of registers within a peripheral, where each register is automatically assigned a unique name and address offset based on the <code>dimIncrement</code> value. The parser should expand this array correctly, ensuring that the registers are sequentially named and have appropriate memory offsets.</p> <p>Expected Outcome: The parser should successfully process the array of registers, creating two distinct registers named <code>Register0</code> and <code>Register1</code>. <code>Register0</code> should have a base address offset of <code>0x0</code> and a size of 32 bits, while <code>Register1</code> should have a base address offset of <code>0x4</code> and also a size of 32 bits. The <code>dimIncrement</code> should be applied correctly to ensure proper address spacing between the registers.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_array_register_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks the parser's ability to handle arrays defined at the register level. The `dim` element is\n    used to create an array of registers within a peripheral, where each register is automatically assigned a\n    unique name and address offset based on the `dimIncrement` value. The parser should expand this array\n    correctly, ensuring that the registers are sequentially named and have appropriate memory offsets.\n\n    **Expected Outcome:** The parser should successfully process the array of registers, creating two distinct\n    registers named `Register0` and `Register1`. `Register0` should have a base address offset of `0x0` and a size\n    of 32 bits, while `Register1` should have a base address offset of `0x4` and also a size of 32 bits. The\n    `dimIncrement` should be applied correctly to ensure proper address spacing between the registers.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"dim_handling/simple_array_register_level.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"Register0\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"Register1\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>dim_handling/simple_array_register_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_array_register_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;name&gt;Register[%s]&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_simple_list_cluster_level","title":"<code>test_simple_list_cluster_level</code>","text":"<p>This test verifies how the parser handles <code>dim</code> lists at the cluster level. The SVD file defines multiple clusters using a <code>dim</code> list, creating several instances of clusters within a peripheral. The parser should be able to correctly process the SVD file, generating individual clusters with proper naming, offsets, and sizes for each list item.</p> <p>Expected Outcome: The parser should successfully process the file, creating two clusters: <code>ClusterA</code> and <code>ClusterB</code>. Each cluster should contain two registers, <code>RegisterA</code> and <code>RegisterB</code>, with correct offsets and sizes. The parser should correctly handle the <code>dim</code> list at the cluster level, following the SVD structure to replicate multiple clusters, as allowed by the standard and <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_list_cluster_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies how the parser handles `dim` lists at the cluster level. The SVD file defines multiple\n    clusters using a `dim` list, creating several instances of clusters within a peripheral. The parser should be\n    able to correctly process the SVD file, generating individual clusters with proper naming, offsets, and sizes\n    for each list item.\n\n    **Expected Outcome:** The parser should successfully process the file, creating two clusters: `ClusterA` and\n    `ClusterB`. Each cluster should contain two registers, `RegisterA` and `RegisterB`, with correct offsets and\n    sizes. The parser should correctly handle the `dim` list at the cluster level, following the SVD structure to\n    replicate multiple clusters, as allowed by the standard and `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"dim_handling/simple_list_cluster_level.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>dim_handling/simple_list_cluster_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_list_cluster_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x8&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A,B&lt;/dimIndex&gt;\n          &lt;name&gt;Cluster%s&lt;/name&gt;\n          &lt;description&gt;Cluster description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_simple_list_field_level","title":"<code>test_simple_list_field_level</code>","text":"<p>This test ensures that the parser correctly handles <code>dim</code> lists at the field level within a register. The SVD file defines multiple fields inside a register using the <code>dim</code> element to generate a list of fields. Each field is created with specific bit positions, and the parser must correctly instantiate each field based on the provided list values.</p> <p>Expected Outcome: The parser should successfully process the SVD file, generating a register with two fields. The first field, <code>FieldA</code>, should occupy bits 0 to 1, while the second field, <code>FieldB</code>, should occupy bits 2 to 3. The fields should be correctly named and positioned within the register according to their respective bit positions, and the parser should handle the <code>dim</code> list without issues.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_list_field_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly handles `dim` lists at the field level within a register. The SVD\n    file defines multiple fields inside a register using the `dim` element to generate a list of fields. Each\n    field is created with specific bit positions, and the parser must correctly instantiate each field based on\n    the provided list values.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, generating a register with two fields.\n    The first field, `FieldA`, should occupy bits 0 to 1, while the second field, `FieldB`, should occupy bits 2\n    to 3. The fields should be correctly named and positioned within the register according to their respective\n    bit positions, and the parser should handle the `dim` list without issues.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"dim_handling/simple_list_field_level.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 2\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 2\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 3\n</code></pre> SVD file: <code>dim_handling/simple_list_field_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_list_field_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;dim&gt;2&lt;/dim&gt;\n              &lt;dimIncrement&gt;0x2&lt;/dimIncrement&gt;\n              &lt;dimIndex&gt;A,B&lt;/dimIndex&gt;\n              &lt;name&gt;Field%s&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;2&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_simple_list_peripheral_level","title":"<code>test_simple_list_peripheral_level</code>","text":"<p>This test examines whether the parser correctly handles the use of <code>dim</code> lists at the peripheral level. In the SVD file, a <code>dim</code> list is used to define multiple instances of a peripheral. However, <code>svdconv</code> does not allow the use of <code>dim</code> lists at the peripheral level, resulting in an error. The parser should recognize this invalid usage and raise an appropriate exception.</p> <p>Expected Outcome: The parser should fail to process the file and raise an error, as <code>dim</code> lists are not allowed at the peripheral level. The error should clearly indicate that peripherals cannot be defined as lists, mirroring the behavior of <code>svdconv</code>.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Peripheral cannot be a list\",\n)\ndef test_simple_list_peripheral_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test examines whether the parser correctly handles the use of `dim` lists at the peripheral level. In the\n    SVD file, a `dim` list is used to define multiple instances of a peripheral. However, `svdconv` does not allow\n    the use of `dim` lists at the peripheral level, resulting in an error. The parser should recognize this\n    invalid usage and raise an appropriate exception.\n\n    **Expected Outcome:** The parser should fail to process the file and raise an error, as `dim` lists are not\n    allowed at the peripheral level. The error should clearly indicate that peripherals cannot be defined as\n    lists, mirroring the behavior of `svdconv`.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/simple_list_peripheral_level.svd\")\n</code></pre> SVD file: <code>dim_handling/simple_list_peripheral_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_list_peripheral_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;dim&gt;2&lt;/dim&gt;\n      &lt;dimIncrement&gt;0x1000&lt;/dimIncrement&gt;\n      &lt;dimIndex&gt;A,B&lt;/dimIndex&gt;\n      &lt;name&gt;Peripheral%s&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_simple_list_register_level","title":"<code>test_simple_list_register_level</code>","text":"<p>This test verifies the parser's ability to handle <code>dim</code> lists at the register level, covering various ways of specifying the <code>dimIndex</code> values. The SVD file contains multiple registers created using different types of <code>dimIndex</code> definitions, including numeric, alphabetic, and custom sequences. The parser needs to process and correctly instantiate each register based on the provided list values, ensuring proper address offsets and names.</p> <p>Expected Outcome: The parser should process the SVD file successfully, generating 13 registers with the correct names, address offsets, and sizes. The registers should follow the naming conventions specified by their respective <code>dimIndex</code> values, covering all possible variations, such as numeric indices (e.g., Register0, Register1), alphabetic indices (e.g., RegisterA, RegisterB), and custom sequences (e.g., RegisterC, RegisterD). The address offsets should increment correctly for each register based on the <code>dimIncrement</code> value.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_list_register_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies the parser's ability to handle `dim` lists at the register level, covering various ways of\n    specifying the `dimIndex` values. The SVD file contains multiple registers created using different types of\n    `dimIndex` definitions, including numeric, alphabetic, and custom sequences. The parser needs to process and\n    correctly instantiate each register based on the provided list values, ensuring proper address offsets and\n    names.\n\n    **Expected Outcome:** The parser should process the SVD file successfully, generating 13 registers with the\n    correct names, address offsets, and sizes. The registers should follow the naming conventions specified by\n    their respective `dimIndex` values, covering all possible variations, such as numeric indices (e.g.,\n    Register0, Register1), alphabetic indices (e.g., RegisterA, RegisterB), and custom sequences (e.g., RegisterC,\n    RegisterD). The address offsets should increment correctly for each register based on the `dimIncrement`\n    value.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"dim_handling/simple_list_register_level.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 13\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"Register0\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"Register1\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Register)\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[2].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[3], Register)\n    assert device.peripherals[0].registers_clusters[3].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[3].address_offset == 0xC\n    assert device.peripherals[0].registers_clusters[3].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[4], Register)\n    assert device.peripherals[0].registers_clusters[4].name == \"Register2\"\n    assert device.peripherals[0].registers_clusters[4].address_offset == 0x10\n    assert device.peripherals[0].registers_clusters[4].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[5], Register)\n    assert device.peripherals[0].registers_clusters[5].name == \"Register3\"\n    assert device.peripherals[0].registers_clusters[5].address_offset == 0x14\n    assert device.peripherals[0].registers_clusters[5].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[6], Register)\n    assert device.peripherals[0].registers_clusters[6].name == \"Register4\"\n    assert device.peripherals[0].registers_clusters[6].address_offset == 0x18\n    assert device.peripherals[0].registers_clusters[6].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[7], Register)\n    assert device.peripherals[0].registers_clusters[7].name == \"RegisterC\"\n    assert device.peripherals[0].registers_clusters[7].address_offset == 0x1C\n    assert device.peripherals[0].registers_clusters[7].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[8], Register)\n    assert device.peripherals[0].registers_clusters[8].name == \"RegisterD\"\n    assert device.peripherals[0].registers_clusters[8].address_offset == 0x20\n    assert device.peripherals[0].registers_clusters[8].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[9], Register)\n    assert device.peripherals[0].registers_clusters[9].name == \"RegisterE\"\n    assert device.peripherals[0].registers_clusters[9].address_offset == 0x24\n    assert device.peripherals[0].registers_clusters[9].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[10], Register)\n    assert device.peripherals[0].registers_clusters[10].name == \"RegisterF\"\n    assert device.peripherals[0].registers_clusters[10].address_offset == 0x28\n    assert device.peripherals[0].registers_clusters[10].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[11], Register)\n    assert device.peripherals[0].registers_clusters[11].name == \"RegisterG\"\n    assert device.peripherals[0].registers_clusters[11].address_offset == 0x2C\n    assert device.peripherals[0].registers_clusters[11].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[12], Register)\n    assert device.peripherals[0].registers_clusters[12].name == \"RegisterH\"\n    assert device.peripherals[0].registers_clusters[12].address_offset == 0x30\n    assert device.peripherals[0].registers_clusters[12].size == 32\n</code></pre> SVD file: <code>dim_handling/simple_list_register_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_list_register_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A,B&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;dim&gt;3&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;2-4&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x10&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;dim&gt;3&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;C-E&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x1c&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;dim&gt;3&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;F,G, H&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x28&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_two_dim_resulting_in_same_name","title":"<code>test_two_dim_resulting_in_same_name</code>","text":"<p>This test evaluates how the parser handles cases where two <code>dim</code> lists result in conflicting register names due to overlapping <code>dimIndex</code> values. In this SVD file, two registers use separate <code>dim</code> lists, but both lists share common <code>dimIndex</code> values. The first register uses <code>dimIndex</code> values <code>A</code> and <code>B</code>, while the second register uses <code>B</code> and <code>C</code>. This leads to a naming conflict for <code>RegisterB</code>, as it is generated by both <code>dim</code> lists. The parser needs to detect this name collision.</p> <p>Expected Outcome: The parser should raise an error due to the naming conflict caused by overlapping <code>dimIndex</code> values. Both registers attempt to create a register with the name <code>RegisterB</code>, which violates the uniqueness requirement for register names within a peripheral. This error should be flagged and prevent further processing, ensuring that such conflicts are handled appropriately.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"dimIndex from first dim and dimIndex from second dim contain same value, leading to same register name\",\n)\ndef test_two_dim_resulting_in_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the parser handles cases where two `dim` lists result in conflicting register names\n    due to overlapping `dimIndex` values. In this SVD file, two registers use separate `dim` lists, but both lists\n    share common `dimIndex` values. The first register uses `dimIndex` values `A` and `B`, while the second\n    register uses `B` and `C`. This leads to a naming conflict for `RegisterB`, as it is generated by both `dim`\n    lists. The parser needs to detect this name collision.\n\n    **Expected Outcome:** The parser should raise an error due to the naming conflict caused by overlapping `dimIndex`\n    values. Both registers attempt to create a register with the name `RegisterB`, which violates the uniqueness\n    requirement for register names within a peripheral. This error should be flagged and prevent further\n    processing, ensuring that such conflicts are handled appropriately.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/two_dim_resulting_in_same_name.svd\")\n</code></pre> SVD file: <code>dim_handling/two_dim_resulting_in_same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;two_dim_resulting_in_same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A,B&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;B,C&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_dim_handling.html#tests.test_process.test_dim_handling.test_wrong_dimindex_svdconv_bug","title":"<code>test_wrong_dimindex_svdconv_bug</code>","text":"<p>This test case explores a scenario where the <code>dimIndex</code> format uses ranges like <code>A-C</code> or <code>1-3</code>, which <code>svdconv</code> does not correctly handle. Despite no error being raised by <code>svdconv</code>, the affected peripheral is not created. This appears to be a bug in <code>svdconv</code>. In contrast, a proper parser implementation must identify and report an error when the number of <code>dimIndex</code> elements does not match the number of <code>dim</code> instances, regardless of how the <code>dimIndex</code> is formatted.</p> <p>Expected Outcome: The parser should raise an error due to the mismatch between the number of <code>dimIndex</code> elements and the number of <code>dim</code> instances. Although <code>svdconv</code> fails to generate an error in this case, a correctly implemented parser must detect this issue and prevent further processing to ensure that the file structure follows the proper SVD conventions.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_dim_handling.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Number of &lt;dimIndex&gt; Elements is different to number of &lt;dim&gt; instances\",\n)\ndef test_wrong_dimindex_svdconv_bug(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case explores a scenario where the `dimIndex` format uses ranges like `A-C` or `1-3`, which\n    `svdconv` does not correctly handle. Despite no error being raised by `svdconv`, the affected peripheral is\n    not created. This appears to be a bug in `svdconv`. In contrast, a proper parser implementation must identify\n    and report an error when the number of `dimIndex` elements does not match the number of `dim` instances,\n    regardless of how the `dimIndex` is formatted.\n\n    **Expected Outcome:** The parser should raise an error due to the mismatch between the number of `dimIndex`\n    elements and the number of `dim` instances. Although `svdconv` fails to generate an error in this case, a\n    correctly implemented parser must detect this issue and prevent further processing to ensure that the file\n    structure follows the proper SVD conventions.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    get_processed_device_from_testfile(\"dim_handling/wrong_dimindex_svdconv_bug.svd\")\n</code></pre> SVD file: <code>dim_handling/wrong_dimindex_svdconv_bug.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;wrong_dimindex_no_svdconv_error&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;dimIndex&gt;A-C&lt;/dimIndex&gt;\n          &lt;name&gt;Register%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html","title":"test_enumerated_values","text":"<p>Enumerated values are used to provide human-readable names and descriptions for specific bitfields that have a limited set of possible values. These enumerations make it easier to understand and work with specific configurations of peripheral registers, since the enumerated names give meaningful descriptions instead of just raw numerical values.</p> <p>This feature contains test cases that validate how enumerated values are defined, processed, and applied in various scenarios. The test cases ensure that the parser correctly handles the definition and usage of enumerated values.</p>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_default_extension","title":"<code>test_default_extension</code>","text":"<p>This test focuses on how parsers should handle <code>enumeratedValue</code> elements marked with <code>isDefault=True</code>. In <code>svdconv</code>, such values are parsed without any special processing, essentially ignoring their purpose beyond simple recognition. However, according to the CMSIS-SVD standard, <code>isDefault</code> should define a name and description for all other values that are not explicitly listed. This means a robust parser should extend the enumerated values to include all potential values not explicitly defined, using the <code>isDefault</code> entry as a template.</p> <p>Expected Outcome: The parser should go beyond <code>svdconv</code>'s behavior by automatically identifying all values not covered by explicit <code>enumeratedValue</code> entries and adding them to the container using the <code>isDefault</code> description. For example, if the <code>isDefault</code> value is defined with a description like \"Description for default,\" the parser should generate new entries for every unlisted possible value, appending them to the existing list of enumerated values. In this case, the parser should correctly identify that <code>0b10</code> is explicitly listed, while the values <code>0</code>, <code>1</code>, and <code>3</code> are not. It should then add these values using the <code>isDefault</code> template, resulting in a complete and exhaustive set of enumerated values, ensuring that any unspecified cases are properly accounted for and described, thus enhancing clarity and usability.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_default_extension(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test focuses on how parsers should handle `enumeratedValue` elements marked with `isDefault=True`. In\n    `svdconv`, such values are parsed without any special processing, essentially ignoring their purpose beyond\n    simple recognition. However, according to the CMSIS-SVD standard, `isDefault` should define a name and\n    description for all other values that are not explicitly listed. This means a robust parser should extend the\n    enumerated values to include all potential values not explicitly defined, using the `isDefault` entry as a\n    template.\n\n    **Expected Outcome:** The parser should go beyond `svdconv`'s behavior by automatically identifying all values not\n    covered by explicit `enumeratedValue` entries and adding them to the container using the `isDefault`\n    description. For example, if the `isDefault` value is defined with a description like \"Description for\n    default,\" the parser should generate new entries for every unlisted possible value, appending them to the\n    existing list of enumerated values. In this case, the parser should correctly identify that `0b10` is\n    explicitly listed, while the values `0`, `1`, and `3` are not. It should then add these values using the\n    `isDefault` template, resulting in a complete and exhaustive set of enumerated values, ensuring that any\n    unspecified cases are properly accounted for and described, thus enhancing clarity and usability.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"enumerated_values/default_extension.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n\n    assert len(container.enumerated_values) == 4\n\n    assert container.enumerated_values[0].name == \"default_0\"\n    assert container.enumerated_values[0].description == \"Description for default\"\n    assert container.enumerated_values[0].value == 0\n\n    assert container.enumerated_values[1].name == \"default_1\"\n    assert container.enumerated_values[1].description == \"Description for default\"\n    assert container.enumerated_values[1].value == 1\n\n    assert container.enumerated_values[2].name == \"0b10\"\n    assert container.enumerated_values[2].description == \"Description for 0b10\"\n    assert container.enumerated_values[2].value == 2\n\n    assert container.enumerated_values[3].name == \"default_3\"\n    assert container.enumerated_values[3].description == \"Description for default\"\n    assert container.enumerated_values[3].value == 3\n</code></pre> SVD file: <code>enumerated_values/default_extension.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;default_extension&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b10&lt;/name&gt;\n                  &lt;description&gt;Description for 0b10&lt;/description&gt;\n                  &lt;value&gt;0b10&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;default&lt;/name&gt;\n                  &lt;description&gt;Description for default&lt;/description&gt;\n                  &lt;isDefault&gt;true&lt;/isDefault&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_default_usage","title":"<code>test_default_usage</code>","text":"<p>This test verifies the parser's handling of <code>&lt;enumeratedValues&gt;</code> containers when the <code>&lt;usage&gt;</code> attribute is not explicitly set. According to the CMSIS-SVD standard, if the <code>&lt;usage&gt;</code> attribute is omitted, the enumerated values should default to <code>read-write</code>. This behavior simplifies the definition of common cases where enumerated values apply equally to both read and write operations. The SVD file for this test omits the <code>&lt;usage&gt;</code> attribute to confirm that the parser correctly defaults to <code>read-write</code>.</p> <p>Expected Outcome: The parser should process the SVD file without errors, correctly interpreting the <code>&lt;enumeratedValues&gt;</code> container as having a <code>read-write</code> usage. It must ensure that, even when the <code>&lt;usage&gt;</code> attribute is missing, the enumerated values are accessible for both reading and writing. This behavior aligns with <code>svdconv</code>, which also treats the absence of a <code>&lt;usage&gt;</code> attribute as equivalent to <code>read-write</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_default_usage(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies the parser's handling of `&lt;enumeratedValues&gt;` containers when the `&lt;usage&gt;` attribute is\n    not explicitly set. According to the CMSIS-SVD standard, if the `&lt;usage&gt;` attribute is omitted, the enumerated\n    values should default to `read-write`. This behavior simplifies the definition of common cases where\n    enumerated values apply equally to both read and write operations. The SVD file for this test omits the\n    `&lt;usage&gt;` attribute to confirm that the parser correctly defaults to `read-write`.\n\n    **Expected Outcome:** The parser should process the SVD file without errors, correctly interpreting the\n    `&lt;enumeratedValues&gt;` container as having a `read-write` usage. It must ensure that, even when the `&lt;usage&gt;`\n    attribute is missing, the enumerated values are accessible for both reading and writing. This behavior aligns\n    with `svdconv`, which also treats the absence of a `&lt;usage&gt;` attribute as equivalent to `read-write`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"enumerated_values/default_usage.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert container.name == \"FieldAEnumeratedValue\"\n    assert container.usage == EnumUsageType.READ_WRITE\n</code></pre> SVD file: <code>enumerated_values/default_usage.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;default_usage&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b00&lt;/name&gt;\n                  &lt;description&gt;Description for 0b00&lt;/description&gt;\n                  &lt;value&gt;0b00&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_do_not_care_and_distinct_result_in_same_value","title":"<code>test_do_not_care_and_distinct_result_in_same_value</code>","text":"<p>This test focuses on scenarios where a combination of \"do not care\" bits and distinct enumerated values inadvertently leads to the same final value. This can occur when the \"do not care\" handling allows for multiple bit combinations to be interpreted as the same value, but there is also a specific, distinct enumerated value defined separately. In such cases, it is essential for the parser to correctly identify and handle these overlaps, avoiding unintended duplications.</p> <p>Expected Outcome: The parser should have the same behavior as <code>svdconv</code>, which processes the configuration but issues a warning and ignores the second, duplicated value.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>def test_do_not_care_and_distinct_result_in_same_value(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test focuses on scenarios where a combination of \"do not care\" bits and distinct enumerated values\n    inadvertently leads to the same final value. This can occur when the \"do not care\" handling allows for\n    multiple bit combinations to be interpreted as the same value, but there is also a specific, distinct\n    enumerated value defined separately. In such cases, it is essential for the parser to correctly identify and\n    handle these overlaps, avoiding unintended duplications.\n\n    **Expected Outcome:** The parser should have the same behavior as `svdconv`, which\n    processes the configuration but issues a warning and ignores the second, duplicated value.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"enumerated_values/do_not_care_and_distinct_result_in_same_value.svd\"\n        )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert len(enum_container.enumerated_values) == 2\n    assert enum_container.enumerated_values[0].name == \"0bx0_0\"\n    assert enum_container.enumerated_values[0].description == \"Description for 0bx0\"\n    assert enum_container.enumerated_values[0].value == 0\n    assert enum_container.enumerated_values[1].name == \"0bx0_2\"\n    assert enum_container.enumerated_values[1].description == \"Description for 0bx0\"\n    assert enum_container.enumerated_values[1].value == 2\n</code></pre> SVD file: <code>enumerated_values/do_not_care_and_distinct_result_in_same_value.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;do_not_care_and_distinct_result_in_same_value&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0bx0&lt;/name&gt;\n                  &lt;description&gt;Description for 0bx0&lt;/description&gt;\n                  &lt;value&gt;0bx0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;Test&lt;/name&gt;\n                  &lt;description&gt;Description for Test&lt;/description&gt;\n                  &lt;value&gt;0b10&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_do_not_care_and_distinct_values","title":"<code>test_do_not_care_and_distinct_values</code>","text":"<p>This test examines the parser's ability to handle a mix of \"do not care\" bits and distinct values within a single enumerated value container. In certain cases, bitfields may allow specific bits to be ignored or treated as irrelevant, while other values must be distinctly recognized. The parser needs to accurately interpret these scenarios, grouping together values that share a logical behavior despite differing in specific bit positions, while still uniquely identifying distinct values where necessary.</p> <p>Expected Outcome: The parser should successfully process the test file, correctly handling both \"do not care\" bits and distinct values within the same container. Enumerated values that include wildcard or ignored bits should be grouped under the same name and description, such as <code>0x00</code> and <code>0x02</code>, both treated as <code>0bx0</code>. Meanwhile, fully distinct values like <code>0x03</code> should be uniquely recognized as <code>0b11</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_do_not_care_and_distinct_values(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test examines the parser's ability to handle a mix of \"do not care\" bits and distinct values within a\n    single enumerated value container. In certain cases, bitfields may allow specific bits to be ignored or\n    treated as irrelevant, while other values must be distinctly recognized. The parser needs to accurately\n    interpret these scenarios, grouping together values that share a logical behavior despite differing in\n    specific bit positions, while still uniquely identifying distinct values where necessary.\n\n    **Expected Outcome:** The parser should successfully process the test file, correctly handling both \"do not care\"\n    bits and distinct values within the same container. Enumerated values that include wildcard or ignored bits\n    should be grouped under the same name and description, such as `0x00` and `0x02`, both treated as `0bx0`.\n    Meanwhile, fully distinct values like `0x03` should be uniquely recognized as `0b11`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"enumerated_values/do_not_care_and_distinct_values.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n\n    assert len(container.enumerated_values) == 3\n\n    assert container.enumerated_values[0].name == \"0bx0_0\"\n    assert container.enumerated_values[0].description == \"Description for 0bx0\"\n    assert container.enumerated_values[0].value == 0\n\n    assert container.enumerated_values[1].name == \"0bx0_2\"\n    assert container.enumerated_values[1].description == \"Description for 0bx0\"\n    assert container.enumerated_values[1].value == 2\n\n    assert container.enumerated_values[2].name == \"0b11\"\n    assert container.enumerated_values[2].description == \"Description for 0b11\"\n    assert container.enumerated_values[2].value == 3\n</code></pre> SVD file: <code>enumerated_values/do_not_care_and_distinct_values.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;do_not_care_and_distinct_values&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0bx0&lt;/name&gt;\n                  &lt;description&gt;Description for 0bx0&lt;/description&gt;\n                  &lt;value&gt;0bx0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b11&lt;/name&gt;\n                  &lt;description&gt;Description for 0b11&lt;/description&gt;\n                  &lt;value&gt;0b11&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_do_not_care_handling","title":"<code>test_do_not_care_handling</code>","text":"<p>This test verifies how the parser processes enumerated values when specific bits are marked as \"do not care.\" In some cases, a bitfield may have multiple possible values where certain bits are irrelevant, meaning they do not influence the final behavior of the register. This is commonly represented using wildcards or placeholders, and the parser must interpret these \"do not care\" bits correctly to allow multiple enumerations with the same description but different effective values.</p> <p>Expected Outcome: The parser should accurately interpret and process the \"do not care\" bits, allowing multiple enumerated values that represent different numeric values to share the same logical name and description. This results in a list of enumerated values that map distinct values, such as <code>0x00</code>, <code>0x04</code>, <code>0x01</code>, <code>0x05</code>, and so on, under similar names based on their functional grouping. The parser must handle this scenario without confusion or conflicts, ensuring that each enumeration is correctly represented in the output.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_do_not_care_handling(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies how the parser processes enumerated values when specific bits are marked as \"do not care.\"\n    In some cases, a bitfield may have multiple possible values where certain bits are irrelevant, meaning they do\n    not influence the final behavior of the register. This is commonly represented using wildcards or\n    placeholders, and the parser must interpret these \"do not care\" bits correctly to allow multiple enumerations\n    with the same description but different effective values.\n\n    **Expected Outcome:** The parser should accurately interpret and process the \"do not care\" bits, allowing multiple\n    enumerated values that represent different numeric values to share the same logical name and description. This\n    results in a list of enumerated values that map distinct values, such as `0x00`, `0x04`, `0x01`, `0x05`, and\n    so on, under similar names based on their functional grouping. The parser must handle this scenario without\n    confusion or conflicts, ensuring that each enumeration is correctly represented in the output.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"enumerated_values/do_not_care_handling.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n\n    assert len(container.enumerated_values) == 8\n\n    assert container.enumerated_values[0].name == \"0bx00_0\"\n    assert container.enumerated_values[0].description == \"Description for 0bx00\"\n    assert container.enumerated_values[0].value == 0\n\n    assert container.enumerated_values[1].name == \"0bx01_1\"\n    assert container.enumerated_values[1].description == \"Description for 0bx01\"\n    assert container.enumerated_values[1].value == 1\n\n    assert container.enumerated_values[2].name == \"0bx10_2\"\n    assert container.enumerated_values[2].description == \"Description for 0bx10\"\n    assert container.enumerated_values[2].value == 2\n\n    assert container.enumerated_values[3].name == \"0bx11_3\"\n    assert container.enumerated_values[3].description == \"Description for 0bx11\"\n    assert container.enumerated_values[3].value == 3\n\n    assert container.enumerated_values[4].name == \"0bx00_4\"\n    assert container.enumerated_values[4].description == \"Description for 0bx00\"\n    assert container.enumerated_values[4].value == 4\n\n    assert container.enumerated_values[5].name == \"0bx01_5\"\n    assert container.enumerated_values[5].description == \"Description for 0bx01\"\n    assert container.enumerated_values[5].value == 5\n\n    assert container.enumerated_values[6].name == \"0bx10_6\"\n    assert container.enumerated_values[6].description == \"Description for 0bx10\"\n    assert container.enumerated_values[6].value == 6\n\n    assert container.enumerated_values[7].name == \"0bx11_7\"\n    assert container.enumerated_values[7].description == \"Description for 0bx11\"\n    assert container.enumerated_values[7].value == 7\n</code></pre> SVD file: <code>enumerated_values/do_not_care_handling.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;do_not_care_handling&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[2:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0bx00&lt;/name&gt;\n                  &lt;description&gt;Description for 0bx00&lt;/description&gt;\n                  &lt;value&gt;0bx00&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0bx01&lt;/name&gt;\n                  &lt;description&gt;Description for 0bx01&lt;/description&gt;\n                  &lt;value&gt;0bx01&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0bx10&lt;/name&gt;\n                  &lt;description&gt;Description for 0bx10&lt;/description&gt;\n                  &lt;value&gt;0bx10&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0bx11&lt;/name&gt;\n                  &lt;description&gt;Description for 0bx11&lt;/description&gt;\n                  &lt;value&gt;0bx11&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_isdefault_with_value","title":"<code>test_isdefault_with_value</code>","text":"<p>The CMSIS-SVD standard specifies that <code>enumeratedValue</code> should contain either <code>isDefault</code> or <code>value</code>, but not both simultaneously. However, <code>svdconv</code> does not enforce this rule and will not flag cases where both elements are present.</p> <p>Expected Outcome: A robust parser should detect when an <code>enumeratedValue</code> entry incorrectly includes both <code>isDefault</code> and <code>value</code>, should ignore the value and raise a warning.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>def test_isdefault_with_value(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    The CMSIS-SVD standard specifies that `enumeratedValue` should contain either `isDefault` or `value`, but not\n    both simultaneously. However, `svdconv` does not enforce this rule and will not flag cases where both elements\n    are present.\n\n    **Expected Outcome:** A robust parser should detect when an `enumeratedValue` entry incorrectly includes both\n    `isDefault` and `value`, should ignore the value and raise a warning.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"enumerated_values/isdefault_with_value.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n\n    assert len(container.enumerated_values) == 4\n\n    assert container.enumerated_values[0].name == \"default_0\"\n    assert container.enumerated_values[0].description == \"Description for default\"\n    assert container.enumerated_values[0].value == 0\n\n    assert container.enumerated_values[1].name == \"default_1\"\n    assert container.enumerated_values[1].description == \"Description for default\"\n    assert container.enumerated_values[1].value == 1\n\n    assert container.enumerated_values[2].name == \"0b10\"\n    assert container.enumerated_values[2].description == \"Description for 0b10\"\n    assert container.enumerated_values[2].value == 2\n\n    assert container.enumerated_values[3].name == \"default_3\"\n    assert container.enumerated_values[3].description == \"Description for default\"\n    assert container.enumerated_values[3].value == 3\n</code></pre> SVD file: <code>enumerated_values/isdefault_with_value.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;isdefault_with_value&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b10&lt;/name&gt;\n                  &lt;description&gt;Description for 0b10&lt;/description&gt;\n                  &lt;value&gt;0b10&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;default&lt;/name&gt;\n                  &lt;description&gt;Description for default&lt;/description&gt;\n                  &lt;value&gt;0b11&lt;/value&gt;\n                  &lt;isDefault&gt;true&lt;/isDefault&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_multiple_isdefault","title":"<code>test_multiple_isdefault</code>","text":"<p>This test examines how the parser handles cases where multiple enumerated values within the same <code>&lt;enumeratedValues&gt;</code> container are marked as <code>isDefault</code>. According to logical interpretation, only one enumerated value should be designated as the default, as having multiple defaults would create ambiguity in determining which value should be prioritized or used by default. While <code>svdconv</code> processes this scenario without issuing a warning or error, this behavior appears to be a bug or oversight. A robust parser implementation should flag such cases and enforce a rule that only one enumerated value can be marked as <code>isDefault</code> within a container.</p> <p>Expected Outcome: The parser should detect when more than one enumerated value is marked as <code>isDefault</code> in the same container and raise an error to indicate this improper configuration. Unlike <code>svdconv</code>, which processes the file without complaints, the parser must ensure clarity and consistency by strictly enforcing that only one enumerated value can be assigned as the default, preventing potential conflicts or misinterpretations during peripheral configuration.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Multiple isDefault\",\n)\ndef test_multiple_isdefault(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test examines how the parser handles cases where multiple enumerated values within the same\n    `&lt;enumeratedValues&gt;` container are marked as `isDefault`. According to logical interpretation, only one\n    enumerated value should be designated as the default, as having multiple defaults would create ambiguity in\n    determining which value should be prioritized or used by default. While `svdconv` processes this scenario\n    without issuing a warning or error, this behavior appears to be a bug or oversight. A robust parser\n    implementation should flag such cases and enforce a rule that only one enumerated value can be marked as\n    `isDefault` within a container.\n\n    **Expected Outcome:** The parser should detect when more than one enumerated value is marked as `isDefault` in the\n    same container and raise an error to indicate this improper configuration. Unlike `svdconv`, which processes\n    the file without complaints, the parser must ensure clarity and consistency by strictly enforcing that only\n    one enumerated value can be assigned as the default, preventing potential conflicts or misinterpretations\n    during peripheral configuration.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    get_processed_device_from_testfile(\"enumerated_values/multiple_isdefault.svd\")\n</code></pre> SVD file: <code>enumerated_values/multiple_isdefault.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_isdefault&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b00&lt;/name&gt;\n                  &lt;description&gt;Description for 0b00&lt;/description&gt;\n                  &lt;isDefault&gt;true&lt;/isDefault&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b01&lt;/name&gt;\n                  &lt;description&gt;Description for 0b01&lt;/description&gt;\n                  &lt;isDefault&gt;true&lt;/isDefault&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_simple_read_write","title":"<code>test_simple_read_write</code>","text":"<p>This test verifies how the parser handles enumerated values associated with a field that has both read and write access. The SVD file defines a single field with an enumerated value container specifying four possible values, each with a unique description. The enumerated values allow for a human-readable interpretation of the bitfield content. The parser must accurately interpret and process these enumerations, ensuring the values are correctly mapped to their corresponding descriptions.</p> <p>Expected Outcome: The parser should successfully process the enumerated values for the field within the register. It should recognize the container name as \"FieldAEnumeratedValue\" and categorize it for both read and write access. The container should contain four enumerated values, each associated with the binary values <code>0b00</code>, <code>0b01</code>, <code>0b10</code>, and <code>0b11</code>, with their respective descriptions. The parser should not mark any of these values as default. The entire structure should be parsed without any errors, matching the expected behavior of <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_read_write(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies how the parser handles enumerated values associated with a field that has both read and\n    write access. The SVD file defines a single field with an enumerated value container specifying four possible\n    values, each with a unique description. The enumerated values allow for a human-readable interpretation of the\n    bitfield content. The parser must accurately interpret and process these enumerations, ensuring the values are\n    correctly mapped to their corresponding descriptions.\n\n    **Expected Outcome:** The parser should successfully process the enumerated values for the field within the\n    register. It should recognize the container name as \"FieldAEnumeratedValue\" and categorize it for both read\n    and write access. The container should contain four enumerated values, each associated with the binary values\n    `0b00`, `0b01`, `0b10`, and `0b11`, with their respective descriptions. The parser should not mark any of\n    these values as default. The entire structure should be parsed without any errors, matching the expected\n    behavior of `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"enumerated_values/simple_read_write.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert container.name == \"FieldAEnumeratedValue\"\n    assert container.usage == EnumUsageType.READ_WRITE\n    assert len(container.enumerated_values) == 4\n\n    assert container.enumerated_values[0].name == \"0b00\"\n    assert container.enumerated_values[0].description == \"Description for 0b00\"\n    assert container.enumerated_values[0].value == 0b00\n\n    assert container.enumerated_values[1].name == \"0b01\"\n    assert container.enumerated_values[1].description == \"Description for 0b01\"\n    assert container.enumerated_values[1].value == 0b01\n\n    assert container.enumerated_values[2].name == \"0b10\"\n    assert container.enumerated_values[2].description == \"Description for 0b10\"\n    assert container.enumerated_values[2].value == 0b10\n\n    assert container.enumerated_values[3].name == \"0b11\"\n    assert container.enumerated_values[3].description == \"Description for 0b11\"\n    assert container.enumerated_values[3].value == 0b11\n</code></pre> SVD file: <code>enumerated_values/simple_read_write.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_read_write&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b00&lt;/name&gt;\n                  &lt;description&gt;Description for 0b00&lt;/description&gt;\n                  &lt;value&gt;0b00&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b01&lt;/name&gt;\n                  &lt;description&gt;Description for 0b01&lt;/description&gt;\n                  &lt;value&gt;0b01&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b10&lt;/name&gt;\n                  &lt;description&gt;Description for 0b10&lt;/description&gt;\n                  &lt;value&gt;0b10&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b11&lt;/name&gt;\n                  &lt;description&gt;Description for 0b11&lt;/description&gt;\n                  &lt;value&gt;0b11&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_three_containers","title":"<code>test_three_containers</code>","text":"<p>This test examines the parser's handling of multiple <code>&lt;enumeratedValues&gt;</code> containers within a field. According to the CMSIS-SVD specification, a field can have one <code>&lt;enumeratedValues&gt;</code> container to define enumerated values for both read and write access, or two separate containers, one for read and one for write operations. The SVD file used in this test case deliberately includes three <code>&lt;enumeratedValues&gt;</code> containers, which exceeds the allowable configuration. This setup aims to verify that the parser correctly identifies and rejects the improper use of multiple enumerated value containers.</p> <p>Expected Outcome: The parser should raise an error due to the presence of three <code>&lt;enumeratedValues&gt;</code> containers in the SVD file. It must recognize that more than two containers are not permitted, regardless of the usage attributes specified. This behavior aligns with the CMSIS-SVD standard, which allows a maximum of two separate containers (one for read and one for write) or a single combined container for both. Since <code>svdconv</code> does not support more than two containers, a compliant parser implementation should similarly enforce this restriction, triggering an error in this scenario.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Too many &lt;enumeratedValues&gt; container specified\",\n)\ndef test_three_containers(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test examines the parser's handling of multiple `&lt;enumeratedValues&gt;` containers within a field. According\n    to the CMSIS-SVD specification, a field can have one `&lt;enumeratedValues&gt;` container to define enumerated\n    values for both read and write access, or two separate containers, one for read and one for write operations.\n    The SVD file used in this test case deliberately includes three `&lt;enumeratedValues&gt;` containers, which exceeds\n    the allowable configuration. This setup aims to verify that the parser correctly identifies and rejects the\n    improper use of multiple enumerated value containers.\n\n    **Expected Outcome:** The parser should raise an error due to the presence of three `&lt;enumeratedValues&gt;`\n    containers in the SVD file. It must recognize that more than two containers are not permitted, regardless of\n    the usage attributes specified. This behavior aligns with the CMSIS-SVD standard, which allows a maximum of\n    two separate containers (one for read and one for write) or a single combined container for both. Since\n    `svdconv` does not support more than two containers, a compliant parser implementation should similarly\n    enforce this restriction, triggering an error in this scenario.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"enumerated_values/three_containers.svd\")\n</code></pre> SVD file: <code>enumerated_values/three_containers.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;three_containers&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b00&lt;/name&gt;\n                  &lt;description&gt;Description for 0b00&lt;/description&gt;\n                  &lt;value&gt;0b00&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b01&lt;/name&gt;\n                  &lt;description&gt;Description for 0b01&lt;/description&gt;\n                  &lt;value&gt;0b01&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b10&lt;/name&gt;\n                  &lt;description&gt;Description for 0b10&lt;/description&gt;\n                  &lt;value&gt;0b10&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_usage_combinations","title":"<code>test_usage_combinations</code>","text":"<p>This test examines how the parser handles different combinations of <code>&lt;usage&gt;</code> attributes within <code>&lt;enumeratedValues&gt;</code> containers. The CMSIS-SVD standard allows certain combinations of <code>&lt;usage&gt;</code> values (such as <code>read</code> and <code>write</code>) but restricts others. The test file is set up to dynamically replace the placeholders \"FIRST_INPUT\" and \"SECOND_INPUT\" with combinations of <code>read</code>, <code>write</code>, and <code>read-write</code>, allowing multiple test cases to be evaluated. The goal is to verify if the parser correctly accepts valid combinations, like <code>read</code> and <code>write</code>, and raises errors for invalid ones, such as <code>read-write</code> paired with any other value.</p> <p>Expected Outcome: The parser should process the file successfully when the <code>&lt;usage&gt;</code> combination is <code>read</code> and <code>write</code>, creating two valid <code>&lt;enumeratedValues&gt;</code> containers with the expected <code>read</code> and <code>write</code> usage types. However, it must raise errors for all other combinations, including <code>write</code> and <code>write</code>, <code>read</code> and <code>read</code>, or any instance where <code>read-write</code> is used in conjunction with another <code>&lt;usage&gt;</code>. This behavior is consistent with <code>svdconv</code>, which also restricts most of these combinations, except for the <code>read</code> and <code>write</code> pairing.</p> <p>Processable with svdconv: the combination of read and write yes, other combinations not</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>@pytest.mark.parametrize(\n    \"first_input,second_input,expected1,expected2\",\n    [\n        pytest.param(\n            \"read\",\n            \"write\",\n            EnumUsageType.READ,\n            EnumUsageType.WRITE,\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\n            \"write\",\n            \"read\",\n            EnumUsageType.WRITE,\n            EnumUsageType.READ,\n            marks=pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\"),\n        ),\n        pytest.param(\"read\", \"read\", None, None, marks=pytest.mark.xfail(strict=True, raises=ProcessException)),\n        pytest.param(\"write\", \"write\", None, None, marks=pytest.mark.xfail(strict=True, raises=ProcessException)),\n        pytest.param(\"read\", \"read-write\", None, None, marks=pytest.mark.xfail(strict=True, raises=ProcessException)),\n        pytest.param(\"write\", \"read-write\", None, None, marks=pytest.mark.xfail(strict=True, raises=ProcessException)),\n        pytest.param(\"read-write\", \"read\", None, None, marks=pytest.mark.xfail(strict=True, raises=ProcessException)),\n        pytest.param(\"read-write\", \"write\", None, None, marks=pytest.mark.xfail(strict=True, raises=ProcessException)),\n        pytest.param(\n            \"read-write\", \"read-write\", None, None, marks=pytest.mark.xfail(strict=True, raises=ProcessException)\n        ),\n    ],\n)\ndef test_usage_combinations(\n    first_input: str,\n    second_input: str,\n    expected1: None | EnumUsageType,\n    expected2: None | EnumUsageType,\n    get_test_svd_file_content: Callable[[str], bytes],\n):\n    \"\"\"\n    This test examines how the parser handles different combinations of `&lt;usage&gt;` attributes within\n    `&lt;enumeratedValues&gt;` containers. The CMSIS-SVD standard allows certain combinations of `&lt;usage&gt;` values (such\n    as `read` and `write`) but restricts others. The test file is set up to dynamically replace the placeholders\n    \"FIRST_INPUT\" and \"SECOND_INPUT\" with combinations of `read`, `write`, and `read-write`, allowing multiple\n    test cases to be evaluated. The goal is to verify if the parser correctly accepts valid combinations, like\n    `read` and `write`, and raises errors for invalid ones, such as `read-write` paired with any other value.\n\n    **Expected Outcome:** The parser should process the file successfully when the `&lt;usage&gt;` combination is `read` and\n    `write`, creating two valid `&lt;enumeratedValues&gt;` containers with the expected `read` and `write` usage types.\n    However, it must raise errors for all other combinations, including `write` and `write`, `read` and `read`, or\n    any instance where `read-write` is used in conjunction with another `&lt;usage&gt;`. This behavior is consistent\n    with `svdconv`, which also restricts most of these combinations, except for the `read` and `write` pairing.\n\n    **Processable with svdconv:** the combination of read and write yes, other combinations not\n    \"\"\"\n\n    file_name = \"enumerated_values/usage_combinations.svd\"\n\n    file_content = get_test_svd_file_content(file_name)\n    file_content = file_content.replace(b\"FIRST_INPUT\", first_input.encode())\n    file_content = file_content.replace(b\"SECOND_INPUT\", second_input.encode())\n\n    device = Process.from_xml_content(file_content).get_processed_device()\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 2\n\n    container1 = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    container2 = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[1]\n\n    if container1.enumerated_values[0].name == \"0b00\":\n        assert container1.usage == expected1\n        assert container2.usage == expected2\n    elif container1.enumerated_values[0].name == \"0b01\":\n        assert container1.usage == expected2\n        assert container2.usage == expected1\n    else:\n        assert False\n</code></pre> SVD file: <code>enumerated_values/usage_combinations.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;usage_combinations&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;FIRST_INPUT&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b00&lt;/name&gt;\n                  &lt;description&gt;Description for 0b00&lt;/description&gt;\n                  &lt;value&gt;0b00&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;SECOND_INPUT&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b01&lt;/name&gt;\n                  &lt;description&gt;Description for 0b01&lt;/description&gt;\n                  &lt;value&gt;0b01&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_value_already_defined","title":"<code>test_value_already_defined</code>","text":"<p>This test assesses the parser's ability to handle scenarios where the same value is defined multiple times within an <code>&lt;enumeratedValues&gt;</code> container. In an SVD file, each enumerated value should represent a unique mapping between a numerical value and its descriptive name to avoid ambiguity. <code>svdconv</code> does allow such duplicate definitions but issues a warning, and ignores the value. A parser implementation should enforce the same behavior.</p> <p>Expected Outcome: The parser should identify the duplicate values within the <code>&lt;enumeratedValues&gt;</code> container and raise an error, indicating that multiple enumerations cannot share the same underlying value. Unlike <code>svdconv</code>, which warns and ignores the value, the parser must enforce uniqueness for each value definition within the container to ensure clarity and prevent conflicting interpretations of register settings.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>def test_value_already_defined(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test assesses the parser's ability to handle scenarios where the same value is defined multiple times\n    within an `&lt;enumeratedValues&gt;` container. In an SVD file, each enumerated value should represent a unique\n    mapping between a numerical value and its descriptive name to avoid ambiguity. `svdconv` does allow such\n    duplicate definitions but issues a warning, and ignores the value. A parser implementation should\n    enforce the same behavior.\n\n    **Expected Outcome:** The parser should identify the duplicate values within the `&lt;enumeratedValues&gt;` container\n    and raise an error, indicating that multiple enumerations cannot share the same underlying value. Unlike\n    `svdconv`, which warns and ignores the value, the parser must enforce uniqueness for each value definition\n    within the container to ensure clarity and prevent conflicting interpretations of register settings.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"enumerated_values/value_already_defined.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert len(enum_container.enumerated_values) == 2\n    assert enum_container.enumerated_values[0].name == \"0b00\"\n    assert enum_container.enumerated_values[0].description == \"Description for 0b00\"\n    assert enum_container.enumerated_values[0].value == 0\n    assert enum_container.enumerated_values[1].name == \"0b01\"\n    assert enum_container.enumerated_values[1].description == \"Description for 0b01\"\n    assert enum_container.enumerated_values[1].value == 1\n</code></pre> SVD file: <code>enumerated_values/value_already_defined.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;value_already_defined&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b00&lt;/name&gt;\n                  &lt;description&gt;Description for 0b00&lt;/description&gt;\n                  &lt;value&gt;0b00&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b01&lt;/name&gt;\n                  &lt;description&gt;Description for 0b01&lt;/description&gt;\n                  &lt;value&gt;0b01&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b10&lt;/name&gt;\n                  &lt;description&gt;Description for 0b10&lt;/description&gt;\n                  &lt;value&gt;0b00&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values.html#tests.test_process.test_enumerated_values.test_value_name_already_defined_same_container","title":"<code>test_value_name_already_defined_same_container</code>","text":"<p>This test verifies the parser's ability to handle situations where duplicate enumerated value names are defined within the same <code>&lt;enumeratedValues&gt;</code> container. According to best practices, each enumerated value within a container should have a unique name to avoid confusion and ensure clarity in register configurations. While <code>svdconv</code> allows this scenario, issuing only a warning and subsequently ignoring the duplicated enumerated value, a robust parser implementation should enforce stricter validation by treating it as an error. This approach prevents potential misconfigurations or ambiguity in interpreting register values.</p> <p>Expected Outcome: The parser should detect the duplicate enumerated value names within the same container and raise an error, signaling a violation of the expected naming conventions. Unlike <code>svdconv</code>, which issues a warning and ignores the conflicting value, the parser should ensure strict enforcement of unique enumerated value names within each container, thereby promoting consistency and clear register definitions.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values.py</code> <pre><code>def test_value_name_already_defined_same_container(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies the parser's ability to handle situations where duplicate enumerated value names are\n    defined within the same `&lt;enumeratedValues&gt;` container. According to best practices, each enumerated value\n    within a container should have a unique name to avoid confusion and ensure clarity in register configurations.\n    While `svdconv` allows this scenario, issuing only a warning and subsequently ignoring the duplicated\n    enumerated value, a robust parser implementation should enforce stricter validation by treating it as an\n    error. This approach prevents potential misconfigurations or ambiguity in interpreting register values.\n\n    **Expected Outcome:** The parser should detect the duplicate enumerated value names within the same container and\n    raise an error, signaling a violation of the expected naming conventions. Unlike `svdconv`, which issues a\n    warning and ignores the conflicting value, the parser should ensure strict enforcement of unique enumerated\n    value names within each container, thereby promoting consistency and clear register definitions.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"enumerated_values/value_name_already_defined_same_container.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert len(enum_container.enumerated_values) == 2\n    assert enum_container.enumerated_values[0].name == \"0b00\"\n    assert enum_container.enumerated_values[0].description == \"Description for 0b00\"\n    assert enum_container.enumerated_values[0].value == 0\n    assert enum_container.enumerated_values[1].name == \"0b01\"\n    assert enum_container.enumerated_values[1].description == \"Description for 0b01\"\n    assert enum_container.enumerated_values[1].value == 1\n</code></pre> SVD file: <code>enumerated_values/value_name_already_defined_same_container.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;value_name_already_defined_same_container&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[1:0]&lt;/bitRange&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b00&lt;/name&gt;\n                  &lt;description&gt;Description for 0b00&lt;/description&gt;\n                  &lt;value&gt;0b00&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b01&lt;/name&gt;\n                  &lt;description&gt;Description for 0b01&lt;/description&gt;\n                  &lt;value&gt;0b01&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b00&lt;/name&gt;\n                  &lt;description&gt;Description for 0b10&lt;/description&gt;\n                  &lt;value&gt;0b10&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values_copy_via_derived_from.html","title":"test_enumerated_values_copy_via_derived_from","text":"<p>For this feature, test cases cover scenarios where a enumerated values container (<code>enumeratedValues</code>) is copied from a base container with <code>derivedFrom</code>. An <code>enumeratedValues</code> entry is referenced by its name. Although the CMSIS SVD standard states, that the name is resolved by uniques or further qualifiecation by specifying the associated field, register, and peripheral, <code>svdconv</code> can only resolve references by the same rules as the referencing <code>derivedFrom</code> works on peripheral, cluster, register, and field level. Since the validity of SVD files is primarily verified using <code>svdconv</code>, any parser implementation should ensure that its name resolution mechanism at the <code>enumeratedValues</code> level is consistent with that of <code>svdconv</code>. To maintain compatibility, the parser should adopt the same approach to name resolution, following the same rules and hierarchy used by <code>svdconv</code>.</p>"},{"location":"test_enumerated_values_copy_via_derived_from.html#tests.test_process.test_enumerated_values_copy_via_derived_from.test_backward_reference_different_scope","title":"<code>test_backward_reference_different_scope</code>","text":"<p>This test case verifies that an enumerated values container can be correctly copied from another field. In the SVD file, <code>FieldA</code> defines an enumerated values container named <code>FieldAEnumeratedValue</code>, while <code>FieldB</code> copies this container using the <code>derivedFrom</code> attribute. This allows <code>FieldB</code> to reuse the same set of enumerated values as <code>FieldA</code>, ensuring consistency across fields.</p> <p>Expected Outcome: The parser should successfully process the SVD file, allowing <code>FieldB</code> to copy the enumerated values from <code>FieldA</code>'s <code>FieldAEnumeratedValue</code>. The enumerated values should be identical for both <code>FieldA</code> and <code>FieldB</code>, and no conflicts or errors should arise during parsing.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_enumerated_values_copy_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_backward_reference_different_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case verifies that an enumerated values container can be correctly copied from another field. In the\n    SVD file, `FieldA` defines an enumerated values container named `FieldAEnumeratedValue`, while `FieldB` copies\n    this container using the `derivedFrom` attribute. This allows `FieldB` to reuse the same set of enumerated\n    values as `FieldA`, ensuring consistency across fields.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, allowing `FieldB` to copy the\n    enumerated values from `FieldA`'s `FieldAEnumeratedValue`. The enumerated values should be identical for both\n    `FieldA` and `FieldB`, and no conflicts or errors should arise during parsing.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"enum_copy_via_derivedfrom/backward_reference_different_scope.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 2\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    fielda_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert fielda_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fielda_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fielda_enum_container.enumerated_values) == 2\n    assert fielda_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fielda_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fielda_enum_container.enumerated_values[0].value == 0b0\n    assert fielda_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fielda_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fielda_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers) == 1\n    fieldb_enum_container = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[0]\n    assert fieldb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldb_enum_container.enumerated_values) == 2\n    assert fieldb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>enum_copy_via_derivedfrom/backward_reference_different_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;backward_reference_different_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues derivedFrom=\"PeripheralA.RegisterA.FieldA.FieldAEnumeratedValue\"&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values_copy_via_derived_from.html#tests.test_process.test_enumerated_values_copy_via_derived_from.test_backward_reference_same_scope","title":"<code>test_backward_reference_same_scope</code>","text":"<p>This test case examines a scenario where the <code>derivedFrom</code> attribute is used within the same scope to refer directly by name to another <code>enumeratedValues</code> container, without providing a fully qualified path. Technically, this is allowed by the SVD standard, but it is not feasible to implement. The only situation where two <code>enumeratedValues</code> containers can coexist within the same field is if one has a <code>read</code> usage and the other has a <code>write</code> usage. The SVD standard specifies that no modifications are allowed when deriving from an <code>enumeratedValues</code> container. Therefore, it is not possible to change the <code>usage</code> attribute when using <code>derivedFrom</code>. Consequently, attempting to derive in this way results in an error, as <code>svdconv</code> correctly detects. A robust parser implementation should behave similarly, rejecting this configuration and raising an appropriate error to ensure compliance with the standard's technical limitations.</p> <p>Expected Outcome: The parser should raise an error, indicating that two <code>enumeratedValues</code> containers cannot coexist within the same field unless they have distinct <code>read</code> and <code>write</code> usage types. This behavior matches that of <code>svdconv</code>.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_enumerated_values_copy_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Two containers require usage types read and write\")\ndef test_backward_reference_same_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines a scenario where the `derivedFrom` attribute is used within the same scope to refer\n    directly by name to another `enumeratedValues` container, without providing a fully qualified path.\n    Technically, this is allowed by the SVD standard, but it is not feasible to implement. The only situation\n    where two `enumeratedValues` containers can coexist within the same field is if one has a `read` usage and the\n    other has a `write` usage. The SVD standard specifies that no modifications are allowed when deriving from an\n    `enumeratedValues` container. Therefore, it is not possible to change the `usage` attribute when using\n    `derivedFrom`. Consequently, attempting to derive in this way results in an error, as `svdconv` correctly\n    detects. A robust parser implementation should behave similarly, rejecting this configuration and raising an\n    appropriate error to ensure compliance with the standard's technical limitations.\n\n    **Expected Outcome:** The parser should raise an error, indicating that two `enumeratedValues` containers cannot\n    coexist within the same field unless they have distinct `read` and `write` usage types. This behavior matches\n    that of `svdconv`.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"enum_copy_via_derivedfrom/backward_reference_same_scope.svd\")\n</code></pre> SVD file: <code>enum_copy_via_derivedfrom/backward_reference_same_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;backward_reference_same_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n              &lt;enumeratedValues derivedFrom=\"FieldAEnumeratedValue\"&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_enumerated_values_copy_via_derived_from.html#tests.test_process.test_enumerated_values_copy_via_derived_from.test_forward_reference_different_scope","title":"<code>test_forward_reference_different_scope</code>","text":"<p>This test case verifies that an enumerated values container can be correctly copied from another field, although the base container is defined lateron in the file. In the SVD file, <code>FieldB</code> defines an enumerated values container named <code>FieldAEnumeratedValue</code>, while <code>FieldA</code> copies this container using the <code>derivedFrom</code> attribute. This allows <code>FieldA</code> to reuse the same set of enumerated values as <code>FieldB</code>, ensuring consistency across fields.</p> <p>Expected Outcome: The parser should successfully process the SVD file, allowing <code>FieldA</code> to copy the enumerated values from <code>FieldB</code>'s <code>FieldAEnumeratedValue</code>. The enumerated values should be identical for both <code>FieldA</code> and <code>FieldB</code>, and no conflicts or errors should arise during parsing. <code>svdconv</code> can't parse the file since it does not support forward references.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_enumerated_values_copy_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_forward_reference_different_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case verifies that an enumerated values container can be correctly copied from another field,\n    although the base container is defined lateron in the file. In the SVD file, `FieldB` defines an enumerated\n    values container named `FieldAEnumeratedValue`, while `FieldA` copies this container using the `derivedFrom`\n    attribute. This allows `FieldA` to reuse the same set of enumerated values as `FieldB`, ensuring consistency\n    across fields.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, allowing `FieldA` to copy the\n    enumerated values from `FieldB`'s `FieldAEnumeratedValue`. The enumerated values should be identical for both\n    `FieldA` and `FieldB`, and no conflicts or errors should arise during parsing. `svdconv` can't parse the file\n    since it does not support forward references.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"enum_copy_via_derivedfrom/forward_reference_different_scope.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 2\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    fielda_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert fielda_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fielda_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fielda_enum_container.enumerated_values) == 2\n    assert fielda_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fielda_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fielda_enum_container.enumerated_values[0].value == 0b0\n    assert fielda_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fielda_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fielda_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers) == 1\n    fieldb_enum_container = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[0]\n    assert fieldb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldb_enum_container.enumerated_values) == 2\n    assert fieldb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>enum_copy_via_derivedfrom/forward_reference_different_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;forward_reference_different_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues derivedFrom=\"PeripheralA.RegisterA.FieldB.FieldAEnumeratedValue\"&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html","title":"test_field_inheritance_via_derived_from","text":"<p>For this feature, test cases cover scenarios where a derived field inherits properties from a base field, ensuring correct behavior when values are inherited.</p>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_circular_inheritance","title":"<code>test_circular_inheritance</code>","text":"<p>This test case examines a scenario where circular inheritance occurs between two fields within the same register (<code>FieldA</code> and <code>FieldB</code>). In the SVD file, <code>FieldA</code> is defined to derive from <code>FieldB</code>, and <code>FieldB</code> is set to derive from <code>FieldA</code>. This creates a circular dependency, which a robust parser should detect and prevent from causing infinite loops or incorrect behavior. Circular inheritance should be considered invalid and should raise an appropriate error during processing.</p> <p>Expected Outcome: The parser should identify the circular dependency between <code>FieldA</code> and <code>FieldB</code> and raise an error, indicating that circular inheritance is not supported. This ensures that the system correctly handles such invalid configurations by stopping further processing and notifying the user of the issue.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Circular inheritance is not supported\")\ndef test_circular_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines a scenario where circular inheritance occurs between two fields within the same\n    register (`FieldA` and `FieldB`). In the SVD file, `FieldA` is defined to derive from `FieldB`, and `FieldB`\n    is set to derive from `FieldA`. This creates a circular dependency, which a robust parser should detect and\n    prevent from causing infinite loops or incorrect behavior. Circular inheritance should be considered invalid\n    and should raise an appropriate error during processing.\n\n    **Expected Outcome:** The parser should identify the circular dependency between `FieldA` and `FieldB` and raise\n    an error, indicating that circular inheritance is not supported. This ensures that the system correctly\n    handles such invalid configurations by stopping further processing and notifying the user of the issue.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"field_inheritance_via_derivedfrom/circular_inheritance.svd\")\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/circular_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;circular_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field derivedFrom=\"FieldB\"&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_derive_from_self","title":"<code>test_derive_from_self</code>","text":"<p>This test case evaluates a scenario where a field attempts to derive from itself, creating an invalid configuration. In the SVD file, <code>FieldA</code> is defined with a <code>derivedFrom</code> attribute pointing to its own name. Such configurations should be detected as erroneous because a field cannot logically inherit properties from itself. This kind of self-reference should lead to a parsing error.</p> <p>Expected Outcome: The parser should detect the invalid self-referential inheritance and raise an error, indicating that a field cannot derive from itself. This ensures that the system handles such configurations correctly by stopping further processing and informing the user of the issue.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Can't derive from self\")\ndef test_derive_from_self(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates a scenario where a field attempts to derive from itself, creating an invalid\n    configuration. In the SVD file, `FieldA` is defined with a `derivedFrom` attribute pointing to its own name.\n    Such configurations should be detected as erroneous because a field cannot logically inherit properties from\n    itself. This kind of self-reference should lead to a parsing error.\n\n    **Expected Outcome:** The parser should detect the invalid self-referential inheritance and raise an error,\n    indicating that a field cannot derive from itself. This ensures that the system handles such configurations\n    correctly by stopping further processing and informing the user of the issue.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"field_inheritance_via_derivedfrom/derive_from_self.svd\")\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/derive_from_self.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;derive_from_self&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_enumerated_value_inheritance_error","title":"<code>test_enumerated_value_inheritance_error</code>","text":"<p>This test case examines a situation where a derived field (<code>FieldB</code>) inherits properties from a base field (<code>FieldA</code>) but also attempts to redefine enumerated values that are incompatible with the inherited ones. The SVD file presents <code>FieldB</code> using the <code>derivedFrom</code> attribute to inherit from <code>FieldA</code>, but it adds a new set of enumerated values under the same usage type (<code>read-write</code>), which causes a conflict.</p> <p>Expected Outcome: The parser should detect the conflict and raise an error because <code>FieldB</code> is attempting to redefine enumerated values that already exist under the <code>read-write</code> usage inherited from <code>FieldA</code>. <code>svdconv</code> correctly identifies this issue and generates an error, stating that the enumerated value container for <code>read- write</code> is already defined. A robust parser should replicate this behavior, ensuring that redefinition of inherited enumerated values does not occur without explicitly overriding the existing container.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Field 'FieldB' (&lt;enumeratedValues&gt; 'FieldAEnumeratedValue'): 'read-write' container already defined\",\n)\ndef test_enumerated_value_inheritance_error(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines a situation where a derived field (`FieldB`) inherits properties from a base field\n    (`FieldA`) but also attempts to redefine enumerated values that are incompatible with the inherited ones. The\n    SVD file presents `FieldB` using the `derivedFrom` attribute to inherit from `FieldA`, but it adds a new set\n    of enumerated values under the same usage type (`read-write`), which causes a conflict.\n\n    **Expected Outcome:** The parser should detect the conflict and raise an error because `FieldB` is attempting to\n    redefine enumerated values that already exist under the `read-write` usage inherited from `FieldA`. `svdconv`\n    correctly identifies this issue and generates an error, stating that the enumerated value container for `read-\n    write` is already defined. A robust parser should replicate this behavior, ensuring that redefinition of\n    inherited enumerated values does not occur without explicitly overriding the existing container.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"field_inheritance_via_derivedfrom/enumerated_value_inheritance_error.svd\")\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/enumerated_value_inheritance_error.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;enumerated_value_inheritance_error&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldBEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_multiple_inheritance_backward_reference","title":"<code>test_multiple_inheritance_backward_reference</code>","text":"<p>This test case focuses on a scenario where multiple fields (<code>FieldB</code> and <code>FieldC</code>) inherit properties from a base field (<code>FieldA</code>) within the same register, using the <code>derivedFrom</code> attribute. <code>FieldB</code> is derived from <code>FieldA</code>, and <code>FieldC</code> is further derived from <code>FieldB</code>. The purpose is to verify that the parser correctly handles this chain of inheritance, ensuring that inherited attributes, such as enumerated values, are properly applied.</p> <p>Expected Outcome: The parser should correctly process the SVD file, allowing <code>FieldB</code> to inherit attributes from <code>FieldA</code> and <code>FieldC</code> to inherit from <code>FieldB</code>. Each of the fields (<code>FieldA</code>, <code>FieldB</code>, and <code>FieldC</code>) should have the same enumerated value container as defined in <code>FieldA</code>. The attributes such as <code>bitOffset</code> and <code>bitWidth</code> should be overridden as defined for each field. The parser should handle this without issues, consistent with <code>svdconv</code>, which successfully processes this file.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_backward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case focuses on a scenario where multiple fields (`FieldB` and `FieldC`) inherit properties from a\n    base field (`FieldA`) within the same register, using the `derivedFrom` attribute. `FieldB` is derived from\n    `FieldA`, and `FieldC` is further derived from `FieldB`. The purpose is to verify that the parser correctly\n    handles this chain of inheritance, ensuring that inherited attributes, such as enumerated values, are properly\n    applied.\n\n    **Expected Outcome:** The parser should correctly process the SVD file, allowing `FieldB` to inherit attributes\n    from `FieldA` and `FieldC` to inherit from `FieldB`. Each of the fields (`FieldA`, `FieldB`, and `FieldC`)\n    should have the same enumerated value container as defined in `FieldA`. The attributes such as `bitOffset` and\n    `bitWidth` should be overridden as defined for each field. The parser should handle this without issues,\n    consistent with `svdconv`, which successfully processes this file.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"field_inheritance_via_derivedfrom/multiple_inheritance_backward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 3\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    fielda_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert fielda_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fielda_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fielda_enum_container.enumerated_values) == 2\n    assert fielda_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fielda_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fielda_enum_container.enumerated_values[0].value == 0b0\n    assert fielda_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fielda_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fielda_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers) == 1\n    fieldb_enum_container = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[0]\n    assert fieldb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldb_enum_container.enumerated_values) == 2\n    assert fieldb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[2].name == \"FieldC\"\n    assert device.peripherals[0].registers_clusters[0].fields[2].lsb == 2\n    assert device.peripherals[0].registers_clusters[0].fields[2].msb == 2\n    assert len(device.peripherals[0].registers_clusters[0].fields[2].enumerated_value_containers) == 1\n    fieldc_enum_container = device.peripherals[0].registers_clusters[0].fields[2].enumerated_value_containers[0]\n    assert fieldc_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldc_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldc_enum_container.enumerated_values) == 2\n    assert fieldc_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldc_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldc_enum_container.enumerated_values[0].value == 0b0\n    assert fieldc_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldc_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldc_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/multiple_inheritance_backward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_inheritance_backward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldB\"&gt;\n              &lt;name&gt;FieldC&lt;/name&gt;\n              &lt;bitOffset&gt;2&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_multiple_inheritance_forward_reference","title":"<code>test_multiple_inheritance_forward_reference</code>","text":"<p>This test case involves multiple fields (<code>FieldA</code>, <code>FieldB</code>, <code>FieldC</code>) where <code>FieldA</code> is derived from <code>FieldB</code>, and <code>FieldB</code> is derived from <code>FieldC</code>, using forward references within the same register. Despite <code>svdconv</code>'s inability to handle forward references, a robust parser should correctly resolve these references and apply the inherited properties as expected. The goal is to ensure that the parser can accurately manage such chains of inheritance and still process the register and its fields without errors.</p> <p>Expected Outcome: The parser should successfully handle the forward references, allowing <code>FieldA</code> to inherit attributes from <code>FieldB</code>, and <code>FieldB</code> to inherit from <code>FieldC</code>. All three fields should ultimately share the same enumerated value container, defined in <code>FieldC</code>. Each field should also correctly override attributes like <code>bitOffset</code> as specified in the SVD file. This ensures compatibility and robustness beyond <code>svdconv</code>'s current limitations.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case involves multiple fields (`FieldA`, `FieldB`, `FieldC`) where `FieldA` is derived from\n    `FieldB`, and `FieldB` is derived from `FieldC`, using forward references within the same register. Despite\n    `svdconv`'s inability to handle forward references, a robust parser should correctly resolve these references\n    and apply the inherited properties as expected. The goal is to ensure that the parser can accurately manage\n    such chains of inheritance and still process the register and its fields without errors.\n\n    **Expected Outcome:** The parser should successfully handle the forward references, allowing `FieldA` to inherit\n    attributes from `FieldB`, and `FieldB` to inherit from `FieldC`. All three fields should ultimately share the\n    same enumerated value container, defined in `FieldC`. Each field should also correctly override attributes\n    like `bitOffset` as specified in the SVD file. This ensures compatibility and robustness beyond `svdconv`'s\n    current limitations.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"field_inheritance_via_derivedfrom/multiple_inheritance_forward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 3\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    fielda_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert fielda_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fielda_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fielda_enum_container.enumerated_values) == 2\n    assert fielda_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fielda_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fielda_enum_container.enumerated_values[0].value == 0b0\n    assert fielda_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fielda_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fielda_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers) == 1\n    fieldb_enum_container = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[0]\n    assert fieldb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldb_enum_container.enumerated_values) == 2\n    assert fieldb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[2].name == \"FieldC\"\n    assert device.peripherals[0].registers_clusters[0].fields[2].lsb == 2\n    assert device.peripherals[0].registers_clusters[0].fields[2].msb == 2\n    assert len(device.peripherals[0].registers_clusters[0].fields[2].enumerated_value_containers) == 1\n    fieldc_enum_container = device.peripherals[0].registers_clusters[0].fields[2].enumerated_value_containers[0]\n    assert fieldc_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldc_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldc_enum_container.enumerated_values) == 2\n    assert fieldc_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldc_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldc_enum_container.enumerated_values[0].value == 0b0\n    assert fieldc_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldc_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldc_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/multiple_inheritance_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_inheritance_forward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field derivedFrom=\"FieldB\"&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldC\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldC&lt;/name&gt;\n              &lt;bitOffset&gt;2&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_overlap_bit_range","title":"<code>test_overlap_bit_range</code>","text":"<p>This test case examines a scenario where two fields within a register are defined to have overlapping bit ranges. In the SVD file provided, <code>FieldA</code> is explicitly defined with a bit offset of <code>0</code> and a width of <code>2</code>, while <code>FieldB</code> is derived from <code>FieldA</code> but is redefined with a bit offset of <code>1</code> and a width of <code>1</code>. This configuration causes <code>FieldB</code> to overlap with the range occupied by <code>FieldA</code>, leading to an invalid layout.</p> <p>Expected Outcome: The parser should detect the overlapping bit ranges between <code>FieldA</code> and <code>FieldB</code> and raise an error. This behavior ensures that fields are uniquely positioned within a register, preventing any conflicts in field interpretation or usage. Notably, <code>svdconv</code> exhibits the same behavior, issuing an error when it encounters this type of overlap.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"FieldA overlaps with FieldB\")\ndef test_overlap_bit_range(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines a scenario where two fields within a register are defined to have overlapping bit\n    ranges. In the SVD file provided, `FieldA` is explicitly defined with a bit offset of `0` and a width of `2`,\n    while `FieldB` is derived from `FieldA` but is redefined with a bit offset of `1` and a width of `1`. This\n    configuration causes `FieldB` to overlap with the range occupied by `FieldA`, leading to an invalid layout.\n\n    **Expected Outcome:** The parser should detect the overlapping bit ranges between `FieldA` and `FieldB` and raise\n    an error. This behavior ensures that fields are uniquely positioned within a register, preventing any\n    conflicts in field interpretation or usage. Notably, `svdconv` exhibits the same behavior, issuing an error\n    when it encounters this type of overlap.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"field_inheritance_via_derivedfrom/overlap_bit_range.svd\")\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/overlap_bit_range.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;overlap_bit_range&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;2&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_override_behavior","title":"<code>test_override_behavior</code>","text":"<p>This test case evaluates the behavior of field inheritance where a derived field (<code>FieldB</code>) inherits properties from a base field (<code>FieldA</code>) and overrides certain attributes. The SVD file illustrates how <code>FieldB</code> utilizes the <code>derivedFrom</code> attribute to inherit from <code>FieldA</code> while customizing some of its properties such as the description, access type, and enumerated values.</p> <p>Expected Outcome: The parser should correctly handle the inheritance, allowing <code>FieldB</code> to override the specified attributes without affecting the inherited properties. The test verifies that <code>FieldB</code> successfully overrides the required fields and adds its own enumerated value set without duplicating or conflicting with those of <code>FieldA</code>. This behavior is consistent with <code>svdconv</code>. The parsing should complete without errors, and the attributes should match the expected results based on the SVD definitions.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_override_behavior(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates the behavior of field inheritance where a derived field (`FieldB`) inherits\n    properties from a base field (`FieldA`) and overrides certain attributes. The SVD file illustrates how\n    `FieldB` utilizes the `derivedFrom` attribute to inherit from `FieldA` while customizing some of its\n    properties such as the description, access type, and enumerated values.\n\n    **Expected Outcome:** The parser should correctly handle the inheritance, allowing `FieldB` to override the\n    specified attributes without affecting the inherited properties. The test verifies that `FieldB` successfully\n    overrides the required fields and adds its own enumerated value set without duplicating or conflicting with\n    those of `FieldA`. This behavior is consistent with `svdconv`. The parsing should complete without errors, and\n    the attributes should match the expected results based on the SVD definitions.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"field_inheritance_via_derivedfrom/override_behavior.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 2\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].description == \"FieldA description\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].access == AccessType.READ_WRITE\n    assert (\n        device.peripherals[0].registers_clusters[0].fields[0].modified_write_values\n        == ModifiedWriteValuesType.ONE_TO_CLEAR\n    )\n    assert device.peripherals[0].registers_clusters[0].fields[0].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[0].fields[0].write_constraint.write_as_read is True\n    assert device.peripherals[0].registers_clusters[0].fields[0].read_action == ReadActionType.MODIFY\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    fielda_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert fielda_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fielda_enum_container.usage == EnumUsageType.READ\n    assert len(fielda_enum_container.enumerated_values) == 2\n    assert fielda_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fielda_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fielda_enum_container.enumerated_values[0].value == 0b0\n    assert fielda_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fielda_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fielda_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].description == \"FieldB description\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].access == AccessType.READ_ONLY\n    assert (\n        device.peripherals[0].registers_clusters[0].fields[1].modified_write_values\n        == ModifiedWriteValuesType.ONE_TO_SET\n    )\n    assert device.peripherals[0].registers_clusters[0].fields[1].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[0].fields[1].write_constraint.use_enumerated_values is True\n    assert device.peripherals[0].registers_clusters[0].fields[1].read_action == ReadActionType.CLEAR\n    assert len(device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers) == 2\n\n    fieldb_enum_container1 = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[0]\n    assert fieldb_enum_container1.name == \"FieldAEnumeratedValue\"\n    assert fieldb_enum_container1.usage == EnumUsageType.READ\n    assert len(fieldb_enum_container1.enumerated_values) == 2\n    assert fieldb_enum_container1.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container1.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container1.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container1.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container1.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container1.enumerated_values[1].value == 0b1\n\n    fieldb_enum_container2 = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[1]\n    assert fieldb_enum_container2.name == \"FieldBEnumeratedValue\"\n    assert fieldb_enum_container2.usage == EnumUsageType.WRITE\n    assert len(fieldb_enum_container2.enumerated_values) == 2\n    assert fieldb_enum_container2.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container2.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container2.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container2.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container2.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container2.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/override_behavior.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;override_behavior&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;description&gt;FieldA description&lt;/description&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;access&gt;read-write&lt;/access&gt;\n              &lt;modifiedWriteValues&gt;oneToClear&lt;/modifiedWriteValues&gt;\n              &lt;writeConstraint&gt;\n                &lt;writeAsRead&gt;true&lt;/writeAsRead&gt;\n              &lt;/writeConstraint&gt;\n              &lt;readAction&gt;modify&lt;/readAction&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;description&gt;FieldB description&lt;/description&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;access&gt;read-only&lt;/access&gt;\n              &lt;modifiedWriteValues&gt;oneToSet&lt;/modifiedWriteValues&gt;\n              &lt;writeConstraint&gt;\n                &lt;useEnumeratedValues&gt;true&lt;/useEnumeratedValues&gt;\n              &lt;/writeConstraint&gt;\n              &lt;readAction&gt;clear&lt;/readAction&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldBEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_same_bit_range","title":"<code>test_same_bit_range</code>","text":"<p>This test case addresses a scenario where two fields in a register are defined to occupy the same bit range. In the provided SVD file, <code>FieldA</code> is explicitly defined with a bit offset of <code>0</code> and a width of <code>1</code>, and <code>FieldB</code> is derived from <code>FieldA</code>, also attempting to use the same bit offset and width. This creates an overlap, which is not allowed as it leads to conflicting field definitions within the same register.</p> <p>Expected Outcome: The parser should detect the overlap between <code>FieldA</code> and <code>FieldB</code> and raise an error, indicating that both fields are trying to occupy the same bit range. This behavior aligns with <code>svdconv</code>, which also detects and reports such conflicts as error.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"FieldA overlaps with FieldB\")\ndef test_same_bit_range(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case addresses a scenario where two fields in a register are defined to occupy the same bit range.\n    In the provided SVD file, `FieldA` is explicitly defined with a bit offset of `0` and a width of `1`, and\n    `FieldB` is derived from `FieldA`, also attempting to use the same bit offset and width. This creates an\n    overlap, which is not allowed as it leads to conflicting field definitions within the same register.\n\n    **Expected Outcome:** The parser should detect the overlap between `FieldA` and `FieldB` and raise an error,\n    indicating that both fields are trying to occupy the same bit range. This behavior aligns with `svdconv`,\n    which also detects and reports such conflicts as error.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"field_inheritance_via_derivedfrom/same_bit_range.svd\")\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/same_bit_range.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;same_bit_range&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_simple_inheritance_backward_reference_different_scope","title":"<code>test_simple_inheritance_backward_reference_different_scope</code>","text":"<p>This test case examines field inheritance using the <code>derivedFrom</code> attribute, where the field being inherited from (<code>FieldA</code>) is defined within a different register (<code>RegisterA</code>) scope, but in the same peripheral, which requires the full qualifying path (<code>PeripheralA.RegisterA.FieldA</code>). In the SVD file, <code>RegisterA</code> explicitly defines <code>FieldA</code> with bit properties and enumerated values. <code>RegisterB</code> defines a field also named <code>FieldA</code>, which uses the <code>derivedFrom</code> attribute to inherit properties from the previously defined <code>FieldA</code> in <code>RegisterA</code>.</p> <p>Expected Outcome: The parser should correctly process the SVD file, allowing <code>RegisterB.FieldA</code> to inherit all properties, including enumerated values, from <code>RegisterA.FieldA</code>. This should include identical bit positioning, usage, and enumerated values. Parsing should complete without any issues, consistent with the expected behavior of <code>svdconv</code>, which successfully handles backward references across different registers in the same peripheral scope.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_backward_reference_different_scope(\n    get_processed_device_from_testfile: Callable[[str], Device],\n):\n    \"\"\"\n    This test case examines field inheritance using the `derivedFrom` attribute, where the field being inherited\n    from (`FieldA`) is defined within a different register (`RegisterA`) scope, but in the same peripheral, which\n    requires the full qualifying path (`PeripheralA.RegisterA.FieldA`). In the SVD file, `RegisterA` explicitly\n    defines `FieldA` with bit properties and enumerated values. `RegisterB` defines a field also named `FieldA`,\n    which uses the `derivedFrom` attribute to inherit properties from the previously defined `FieldA` in\n    `RegisterA`.\n\n    **Expected Outcome:** The parser should correctly process the SVD file, allowing `RegisterB.FieldA` to inherit all\n    properties, including enumerated values, from `RegisterA.FieldA`. This should include identical bit\n    positioning, usage, and enumerated values. Parsing should complete without any issues, consistent with the\n    expected behavior of `svdconv`, which successfully handles backward references across different registers in\n    the same peripheral scope.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"field_inheritance_via_derivedfrom/simple_inheritance_backward_reference_different_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    rega_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert rega_enum_container.name == \"FieldAEnumeratedValue\"\n    assert rega_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(rega_enum_container.enumerated_values) == 2\n    assert rega_enum_container.enumerated_values[0].name == \"0b0\"\n    assert rega_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert rega_enum_container.enumerated_values[0].value == 0b0\n    assert rega_enum_container.enumerated_values[1].name == \"0b1\"\n    assert rega_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert rega_enum_container.enumerated_values[1].value == 0b1\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[1].fields[0].enumerated_value_containers) == 1\n    regb_enum_container = device.peripherals[0].registers_clusters[1].fields[0].enumerated_value_containers[0]\n    assert regb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert regb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(regb_enum_container.enumerated_values) == 2\n    assert regb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert regb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert regb_enum_container.enumerated_values[0].value == 0b0\n    assert regb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert regb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert regb_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/simple_inheritance_backward_reference_different_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_backward_reference_different_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field derivedFrom=\"PeripheralA.RegisterA.FieldA\"&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_simple_inheritance_backward_reference_same_scope","title":"<code>test_simple_inheritance_backward_reference_same_scope</code>","text":"<p>This test case focuses on field inheritance using the <code>derivedFrom</code> attribute within the same register. Here, <code>FieldB</code> inherits properties from <code>FieldA</code>, which is defined earlier within the same register. In the SVD file, <code>FieldA</code> is explicitly set up with bit offset <code>0</code> and width <code>1</code>, along with enumerated values for <code>read- write</code> usage. <code>FieldB</code> is derived from <code>FieldA</code>, meaning it should inherit all attributes, including the enumerated values, while being positioned at a different bit offset (<code>1</code>).</p> <p>Expected Outcome: The parser should correctly interpret the inheritance, processing <code>FieldB</code> as a field that inherits all attributes from <code>FieldA</code>, including its enumerated values. The result should show <code>FieldA</code> at bit offset <code>0</code> and <code>FieldB</code> at bit offset <code>1</code>, both sharing the same enumerated value containers. Parsing should complete without issues, consistent with <code>svdconv</code>, which handles this scenario correctly.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_backward_reference_same_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case focuses on field inheritance using the `derivedFrom` attribute within the same register. Here,\n    `FieldB` inherits properties from `FieldA`, which is defined earlier within the same register. In the SVD\n    file, `FieldA` is explicitly set up with bit offset `0` and width `1`, along with enumerated values for `read-\n    write` usage. `FieldB` is derived from `FieldA`, meaning it should inherit all attributes, including the\n    enumerated values, while being positioned at a different bit offset (`1`).\n\n    **Expected Outcome:** The parser should correctly interpret the inheritance, processing `FieldB` as a field that\n    inherits all attributes from `FieldA`, including its enumerated values. The result should show `FieldA` at bit\n    offset `0` and `FieldB` at bit offset `1`, both sharing the same enumerated value containers. Parsing should\n    complete without issues, consistent with `svdconv`, which handles this scenario correctly.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"field_inheritance_via_derivedfrom/simple_inheritance_backward_reference_same_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 2\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    fielda_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert fielda_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fielda_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fielda_enum_container.enumerated_values) == 2\n    assert fielda_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fielda_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fielda_enum_container.enumerated_values[0].value == 0b0\n    assert fielda_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fielda_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fielda_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers) == 1\n    fieldb_enum_container = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[0]\n    assert fieldb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldb_enum_container.enumerated_values) == 2\n    assert fieldb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/simple_inheritance_backward_reference_same_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_backward_reference_same_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_simple_inheritance_forward_reference_different_scope","title":"<code>test_simple_inheritance_forward_reference_different_scope</code>","text":"<p>This test case evaluates field inheritance using the <code>derivedFrom</code> attribute, where the field being inherited (<code>FieldA</code>) is defined in a different register (<code>RegisterB</code>) within the same peripheral. However, the field in <code>RegisterA</code> uses a forward reference, meaning it tries to derive properties from <code>RegisterB.FieldA</code> before <code>RegisterB</code> is defined. In the provided SVD file, <code>RegisterB.FieldA</code> is explicitly defined with bit properties and enumerated values. <code>RegisterA.FieldA</code> attempts to inherit these properties via a forward reference.</p> <p>Expected Outcome: The parser should inherit successfully from <code>RegisterB.FieldA</code>. <code>svdconv</code> does not handle forward references and raises an error.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_forward_reference_different_scope(\n    get_processed_device_from_testfile: Callable[[str], Device],\n):\n    \"\"\"\n    This test case evaluates field inheritance using the `derivedFrom` attribute, where the field being inherited\n    (`FieldA`) is defined in a different register (`RegisterB`) within the same peripheral. However, the field in\n    `RegisterA` uses a forward reference, meaning it tries to derive properties from `RegisterB.FieldA` before\n    `RegisterB` is defined. In the provided SVD file, `RegisterB.FieldA` is explicitly defined with bit properties\n    and enumerated values. `RegisterA.FieldA` attempts to inherit these properties via a forward reference.\n\n    **Expected Outcome:** The parser should inherit successfully from `RegisterB.FieldA`. `svdconv` does not handle\n    forward references and raises an error.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"field_inheritance_via_derivedfrom/simple_inheritance_forward_reference_different_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    rega_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert rega_enum_container.name == \"FieldAEnumeratedValue\"\n    assert rega_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(rega_enum_container.enumerated_values) == 2\n    assert rega_enum_container.enumerated_values[0].name == \"0b0\"\n    assert rega_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert rega_enum_container.enumerated_values[0].value == 0b0\n    assert rega_enum_container.enumerated_values[1].name == \"0b1\"\n    assert rega_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert rega_enum_container.enumerated_values[1].value == 0b1\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[1].fields[0].enumerated_value_containers) == 1\n    regb_enum_container = device.peripherals[0].registers_clusters[1].fields[0].enumerated_value_containers[0]\n    assert regb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert regb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(regb_enum_container.enumerated_values) == 2\n    assert regb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert regb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert regb_enum_container.enumerated_values[0].value == 0b0\n    assert regb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert regb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert regb_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/simple_inheritance_forward_reference_different_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_forward_reference_different_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field derivedFrom=\"PeripheralA.RegisterB.FieldA\"&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_simple_inheritance_forward_reference_same_scope","title":"<code>test_simple_inheritance_forward_reference_same_scope</code>","text":"<p>This test case examines field inheritance using the <code>derivedFrom</code> attribute within the same register, where the field being inherited from (<code>FieldB</code>) is defined later in the register than the derived field (<code>FieldA</code>). In the SVD file, <code>FieldA</code> uses the <code>derivedFrom</code> attribute to reference <code>FieldB</code>, which is defined afterward, with its enumerated values and other attributes.</p> <p>Expected Outcome: The parser should correctly resolve the forward reference, allowing <code>FieldA</code> to inherit all properties from <code>FieldB</code>, including enumerated values. Both <code>FieldA</code> and <code>FieldB</code> should be processed, with <code>FieldA</code> at bit offset <code>0</code> and <code>FieldB</code> at bit offset <code>1</code>, sharing the same enumerated value containers. Parsing should proceed without issues if the parser handles forward references properly. Unlike <code>svdconv</code>, which raises an error due to its inability to handle such cases, a more robust parser should accommodate this scenario seamlessly.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_forward_reference_same_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines field inheritance using the `derivedFrom` attribute within the same register, where\n    the field being inherited from (`FieldB`) is defined later in the register than the derived field (`FieldA`).\n    In the SVD file, `FieldA` uses the `derivedFrom` attribute to reference `FieldB`, which is defined afterward,\n    with its enumerated values and other attributes.\n\n    **Expected Outcome:** The parser should correctly resolve the forward reference, allowing `FieldA` to inherit all\n    properties from `FieldB`, including enumerated values. Both `FieldA` and `FieldB` should be processed, with\n    `FieldA` at bit offset `0` and `FieldB` at bit offset `1`, sharing the same enumerated value containers.\n    Parsing should proceed without issues if the parser handles forward references properly. Unlike `svdconv`,\n    which raises an error due to its inability to handle such cases, a more robust parser should accommodate this\n    scenario seamlessly.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"field_inheritance_via_derivedfrom/simple_inheritance_forward_reference_same_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 2\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    fielda_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert fielda_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fielda_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fielda_enum_container.enumerated_values) == 2\n    assert fielda_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fielda_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fielda_enum_container.enumerated_values[0].value == 0b0\n    assert fielda_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fielda_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fielda_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 1\n    assert len(device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers) == 1\n    fieldb_enum_container = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[0]\n    assert fieldb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldb_enum_container.enumerated_values) == 2\n    assert fieldb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/simple_inheritance_forward_reference_same_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_forward_reference_same_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field derivedFrom=\"FieldB\"&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_field_inheritance_via_derived_from.html#tests.test_process.test_field_inheritance_via_derived_from.test_value_inheritance","title":"<code>test_value_inheritance</code>","text":"<p>This test case examines field inheritance through the <code>derivedFrom</code> attribute, ensuring that all the properties from a base field (<code>FieldA</code>) are correctly inherited by a derived field (<code>FieldB</code>). In the provided SVD file, <code>FieldA</code> is defined with various attributes, including description, access type, write constraint, and enumerated value. <code>FieldB</code> is set to inherit all these properties from <code>FieldA</code>, while adjusting its position within the register.</p> <p>Expected Outcome: The parser should correctly process the SVD file, allowing <code>FieldB</code> to inherit all properties from <code>FieldA</code>, such as the description, access type, modified write value, write constraint, and enumerated value. The only changes should be the <code>bitOffset</code> and <code>bitWidth</code> adjustments as specified for <code>FieldB</code>. This behavior is consistent with <code>svdconv</code>, which successfully handles such backward inheritance cases within the same register scope. The parsing should complete without errors, and the inherited properties should be accurately reflected in <code>FieldB</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_field_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_value_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines field inheritance through the `derivedFrom` attribute, ensuring that all the\n    properties from a base field (`FieldA`) are correctly inherited by a derived field (`FieldB`). In the provided\n    SVD file, `FieldA` is defined with various attributes, including description, access type, write constraint,\n    and enumerated value. `FieldB` is set to inherit all these properties from `FieldA`, while adjusting its\n    position within the register.\n\n    **Expected Outcome:** The parser should correctly process the SVD file, allowing `FieldB` to inherit all\n    properties from `FieldA`, such as the description, access type, modified write value, write constraint, and\n    enumerated value. The only changes should be the `bitOffset` and `bitWidth` adjustments as specified for\n    `FieldB`. This behavior is consistent with `svdconv`, which successfully handles such backward inheritance\n    cases within the same register scope. The parsing should complete without errors, and the inherited properties\n    should be accurately reflected in `FieldB`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"field_inheritance_via_derivedfrom/value_inheritance.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 2\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].description == \"FieldA description\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].access == AccessType.READ_WRITE\n    assert (\n        device.peripherals[0].registers_clusters[0].fields[0].modified_write_values\n        == ModifiedWriteValuesType.ONE_TO_CLEAR\n    )\n    assert device.peripherals[0].registers_clusters[0].fields[0].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[0].fields[0].write_constraint.write_as_read is True\n    assert device.peripherals[0].registers_clusters[0].fields[0].read_action == ReadActionType.MODIFY\n    assert len(device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers) == 1\n    fielda_enum_container = device.peripherals[0].registers_clusters[0].fields[0].enumerated_value_containers[0]\n    assert fielda_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fielda_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fielda_enum_container.enumerated_values) == 2\n    assert fielda_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fielda_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fielda_enum_container.enumerated_values[0].value == 0b0\n    assert fielda_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fielda_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fielda_enum_container.enumerated_values[1].value == 0b1\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].description == \"FieldA description\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 1\n    assert device.peripherals[0].registers_clusters[0].fields[1].access == AccessType.READ_WRITE\n    assert (\n        device.peripherals[0].registers_clusters[0].fields[1].modified_write_values\n        == ModifiedWriteValuesType.ONE_TO_CLEAR\n    )\n    assert device.peripherals[0].registers_clusters[0].fields[1].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[0].fields[1].write_constraint.write_as_read is True\n    assert device.peripherals[0].registers_clusters[0].fields[1].read_action == ReadActionType.MODIFY\n    assert len(device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers) == 1\n    fieldb_enum_container = device.peripherals[0].registers_clusters[0].fields[1].enumerated_value_containers[0]\n    assert fieldb_enum_container.name == \"FieldAEnumeratedValue\"\n    assert fieldb_enum_container.usage == EnumUsageType.READ_WRITE\n    assert len(fieldb_enum_container.enumerated_values) == 2\n    assert fieldb_enum_container.enumerated_values[0].name == \"0b0\"\n    assert fieldb_enum_container.enumerated_values[0].description == \"Description for 0b0\"\n    assert fieldb_enum_container.enumerated_values[0].value == 0b0\n    assert fieldb_enum_container.enumerated_values[1].name == \"0b1\"\n    assert fieldb_enum_container.enumerated_values[1].description == \"Description for 0b1\"\n    assert fieldb_enum_container.enumerated_values[1].value == 0b1\n</code></pre> SVD file: <code>field_inheritance_via_derivedfrom/value_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;value_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;description&gt;FieldA description&lt;/description&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n              &lt;access&gt;read-write&lt;/access&gt;\n              &lt;modifiedWriteValues&gt;oneToClear&lt;/modifiedWriteValues&gt;\n              &lt;writeConstraint&gt;\n                &lt;writeAsRead&gt;true&lt;/writeAsRead&gt;\n              &lt;/writeConstraint&gt;\n              &lt;readAction&gt;modify&lt;/readAction&gt;\n              &lt;enumeratedValues&gt;\n                &lt;name&gt;FieldAEnumeratedValue&lt;/name&gt;\n                &lt;usage&gt;read-write&lt;/usage&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b0&lt;/name&gt;\n                  &lt;description&gt;Description for 0b0&lt;/description&gt;\n                  &lt;value&gt;0b0&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n                &lt;enumeratedValue&gt;\n                  &lt;name&gt;0b1&lt;/name&gt;\n                  &lt;description&gt;Description for 0b1&lt;/description&gt;\n                  &lt;value&gt;0b1&lt;/value&gt;\n                &lt;/enumeratedValue&gt;\n              &lt;/enumeratedValues&gt;\n            &lt;/field&gt;\n            &lt;field derivedFrom=\"FieldA\"&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;1&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;1&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html","title":"test_logical_integrity","text":"<p>This feature ensures the logical integrity of various elements within SVD processing. The test cases focus on identifying potential conflicts, ambiguities, and ordering issues that may arise during the parsing and interpretation of SVD files, ensuring that the structure and relationships between elements are processed correctly and consistently.</p>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_cluster","title":"<code>test_alternate_cluster</code>","text":"<p>This test checks whether the parser can correctly handle clusters that share the same address and are designated as alternates of each other. In this test file, <code>ClusterA</code> is defined at address offset <code>0x0</code>, and <code>ClusterB</code> is defined at the same address, but is marked as an alternate of <code>ClusterA</code>. <code>svdconv</code> processes this file without any errors or warnings, and a parser implementation should do the same, ensuring that the alternate cluster relationship is properly handled.</p> <p>Expected Outcome: The parser should successfully process the SVD file, identifying the alternate cluster relationship without any errors or warnings. The device should contain one peripheral with two clusters: <code>ClusterA</code>, which is defined at address offset <code>0x0</code> and has no alternate cluster, and <code>ClusterB</code>, which shares the same address offset of <code>0x0</code> and is marked as an alternate of <code>ClusterA</code>. Both clusters should have the correct size of 32 bits, and the parser should ensure that the alternate cluster relationship is respected and processed as intended, consistent with <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_cluster(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly handle clusters that share the same address and are\n    designated as alternates of each other. In this test file, `ClusterA` is defined at address offset `0x0`, and\n    `ClusterB` is defined at the same address, but is marked as an alternate of `ClusterA`. `svdconv` processes\n    this file without any errors or warnings, and a parser implementation should do the same, ensuring that the\n    alternate cluster relationship is properly handled.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, identifying the alternate cluster\n    relationship without any errors or warnings. The device should contain one peripheral with two clusters:\n    `ClusterA`, which is defined at address offset `0x0` and has no alternate cluster, and `ClusterB`, which\n    shares the same address offset of `0x0` and is marked as an alternate of `ClusterA`. Both clusters should have\n    the correct size of 32 bits, and the parser should ensure that the alternate cluster relationship is respected\n    and processed as intended, consistent with `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_cluster.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_cluster is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_cluster == \"ClusterA\"\n</code></pre> SVD file: <code>logical_integrity/alternate_cluster.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_cluster&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterA&lt;/alternateCluster&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_cluster_forward_reference","title":"<code>test_alternate_cluster_forward_reference</code>","text":"<p>This test checks whether the parser can correctly handle forward references in alternate cluster definitions. In this test file, <code>ClusterA</code> is defined first and references <code>ClusterB</code> as its alternate cluster, even though <code>ClusterB</code> is declared later in the file. While <code>svdconv</code> processes the file, it incorrectly issues a warning that <code>ClusterB</code> has the same address as <code>ClusterA</code>, without properly recognizing the alternate cluster relationship. A robust parser should correctly resolve the forward reference and process the file without generating any incorrect warnings.</p> <p>Expected Outcome: The parser should successfully process the SVD file without issuing any incorrect warnings. It should correctly identify <code>ClusterA</code> as being located at address offset <code>0x0</code> with a size of 32 bits and recognize <code>ClusterB</code> as its alternate cluster. Similarly, <code>ClusterB</code>, which is defined later in the file at the same address offset and with the same size, should be processed correctly as an alternate cluster of <code>ClusterA</code>. The parser should handle this forward reference without errors or misleading warnings, ensuring that the alternate cluster relationship is respected and processed accurately, unlike <code>svdconv</code>, which incorrectly generates a warning about the overlapping addresses.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_cluster_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly handle forward references in alternate cluster definitions.\n    In this test file, `ClusterA` is defined first and references `ClusterB` as its alternate cluster, even though\n    `ClusterB` is declared later in the file. While `svdconv` processes the file, it incorrectly issues a warning\n    that `ClusterB` has the same address as `ClusterA`, without properly recognizing the alternate cluster\n    relationship. A robust parser should correctly resolve the forward reference and process the file without\n    generating any incorrect warnings.\n\n    **Expected Outcome:** The parser should successfully process the SVD file without issuing any incorrect warnings.\n    It should correctly identify `ClusterA` as being located at address offset `0x0` with a size of 32 bits and\n    recognize `ClusterB` as its alternate cluster. Similarly, `ClusterB`, which is defined later in the file at\n    the same address offset and with the same size, should be processed correctly as an alternate cluster of\n    `ClusterA`. The parser should handle this forward reference without errors or misleading warnings, ensuring\n    that the alternate cluster relationship is respected and processed accurately, unlike `svdconv`, which\n    incorrectly generates a warning about the overlapping addresses.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_cluster_forward_reference.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_cluster == \"ClusterB\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_cluster is None\n</code></pre> SVD file: <code>logical_integrity/alternate_cluster_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_cluster_forward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterB&lt;/alternateCluster&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_cluster_multiple","title":"<code>test_alternate_cluster_multiple</code>","text":"<p>This test evaluates how the parser handles multiple clusters that share the same address and are designated as alternates of one another. In this test file, <code>ClusterA</code> is defined at address offset <code>0x0</code>, and <code>ClusterB</code>, <code>ClusterC</code>, and <code>ClusterD</code> are all also defined at the same address, but each is marked as an alternate of a different cluster. <code>ClusterB</code> and <code>ClusterC</code> are alternates of <code>ClusterA</code>, while <code>ClusterD</code> is an alternate of <code>ClusterC</code>. <code>svdconv</code> processes this file without any issues, and a parser implementation should also handle these relationships correctly.</p> <p>Expected Outcome: The parser should process the SVD file successfully, recognizing the alternate relationships between the clusters. The device should contain one peripheral with four clusters. <code>ClusterA</code> should be defined at address offset <code>0x0</code> with a size of 32 bits and no alternate cluster. <code>ClusterB</code> and <code>ClusterC</code> should also be defined at address offset <code>0x0</code>, both with a size of 32 bits, marked as alternates of <code>ClusterA</code>. <code>ClusterD</code>, also at address offset <code>0x0</code> with the same size, should be marked as an alternate of <code>ClusterC</code>. The parser should process this configuration without any warnings or errors, handling multiple alternate cluster relationships as intended, consistent with the behavior of <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_cluster_multiple(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the parser handles multiple clusters that share the same address and are designated as\n    alternates of one another. In this test file, `ClusterA` is defined at address offset `0x0`, and `ClusterB`,\n    `ClusterC`, and `ClusterD` are all also defined at the same address, but each is marked as an alternate of a\n    different cluster. `ClusterB` and `ClusterC` are alternates of `ClusterA`, while `ClusterD` is an alternate of\n    `ClusterC`. `svdconv` processes this file without any issues, and a parser implementation should also handle\n    these relationships correctly.\n\n    **Expected Outcome:** The parser should process the SVD file successfully, recognizing the alternate relationships\n    between the clusters. The device should contain one peripheral with four clusters. `ClusterA` should be\n    defined at address offset `0x0` with a size of 32 bits and no alternate cluster. `ClusterB` and `ClusterC`\n    should also be defined at address offset `0x0`, both with a size of 32 bits, marked as alternates of\n    `ClusterA`. `ClusterD`, also at address offset `0x0` with the same size, should be marked as an alternate of\n    `ClusterC`. The parser should process this configuration without any warnings or errors, handling multiple\n    alternate cluster relationships as intended, consistent with the behavior of `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_cluster_multiple.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 4\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_cluster is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_cluster == \"ClusterA\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Cluster)\n    assert device.peripherals[0].registers_clusters[2].name == \"ClusterC\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[2].size == 32\n    assert device.peripherals[0].registers_clusters[2].alternate_cluster == \"ClusterA\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[3], Cluster)\n    assert device.peripherals[0].registers_clusters[3].name == \"ClusterD\"\n    assert device.peripherals[0].registers_clusters[3].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[3].size == 32\n    assert device.peripherals[0].registers_clusters[3].alternate_cluster == \"ClusterC\"\n</code></pre> SVD file: <code>logical_integrity/alternate_cluster_multiple.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_cluster_multiple&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterA&lt;/alternateCluster&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterC&lt;/name&gt;\n          &lt;description&gt;ClusterC description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterA&lt;/alternateCluster&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterD&lt;/name&gt;\n          &lt;description&gt;ClusterD description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterC&lt;/alternateCluster&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_cluster_overlap","title":"<code>test_alternate_cluster_overlap</code>","text":"<p>This test checks how the parser handles clusters that overlap in memory but are designated as alternates of each other. In this test file, <code>ClusterA</code> is defined at address offset <code>0x0</code>, and <code>ClusterB</code> is defined at address offset <code>0x2</code>, causing a partial overlap in their memory space. <code>ClusterB</code> is marked as an alternate of <code>ClusterA</code>, which allows for this overlap. <code>svdconv</code> processes this file without issues, and a parser implementation should handle the overlapping memory regions correctly, considering the alternate relationship between the clusters.</p> <p>Expected Outcome: The parser should process the file successfully, identifying that <code>ClusterB</code> overlaps with <code>ClusterA</code> but is marked as an alternate cluster, which makes the overlap valid. The device should contain one peripheral with two clusters: <code>ClusterA</code> at address offset <code>0x0</code> with a size of 32 bits and no alternate cluster, and <code>ClusterB</code> at address offset <code>0x2</code> with a size of 16 bits, marked as an alternate of <code>ClusterA</code>. The parser should handle this alternate cluster relationship without any errors or warnings, ensuring that the overlap is processed correctly, similar to <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_cluster_overlap(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles clusters that overlap in memory but are designated as alternates of\n    each other. In this test file, `ClusterA` is defined at address offset `0x0`, and `ClusterB` is defined at\n    address offset `0x2`, causing a partial overlap in their memory space. `ClusterB` is marked as an alternate of\n    `ClusterA`, which allows for this overlap. `svdconv` processes this file without issues, and a parser\n    implementation should handle the overlapping memory regions correctly, considering the alternate relationship\n    between the clusters.\n\n    **Expected Outcome:** The parser should process the file successfully, identifying that `ClusterB` overlaps with\n    `ClusterA` but is marked as an alternate cluster, which makes the overlap valid. The device should contain one\n    peripheral with two clusters: `ClusterA` at address offset `0x0` with a size of 32 bits and no alternate\n    cluster, and `ClusterB` at address offset `0x2` with a size of 16 bits, marked as an alternate of `ClusterA`.\n    The parser should handle this alternate cluster relationship without any errors or warnings, ensuring that the\n    overlap is processed correctly, similar to `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_cluster_overlap.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_cluster is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].size == 16\n    assert device.peripherals[0].registers_clusters[1].alternate_cluster == \"ClusterA\"\n</code></pre> SVD file: <code>logical_integrity/alternate_cluster_overlap.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_cluster_overlap&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterB&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterA&lt;/alternateCluster&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;size&gt;16&lt;/size&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_cluster_same_name","title":"<code>test_alternate_cluster_same_name</code>","text":"<p>This test evaluates whether the parser can handle the scenario where two clusters within the same peripheral are given the same name, with one marked as an alternate of the other. In this test file, <code>ClusterA</code> is defined, and another cluster also named <code>ClusterA</code> is marked as its alternate. This creates a naming conflict, as clusters within the same peripheral must have unique names. <code>svdconv</code> raises an error in this case, and the parser should behave similarly, rejecting the file due to the name conflict.</p> <p>Expected Outcome: The parser should raise an error indicating that two clusters with the same name cannot exist within the same peripheral, even if one is designated as an alternate cluster. The file should fail to process because both clusters are named <code>ClusterA</code>, creating a naming conflict. The parser should halt further processing and notify the user about the issue, ensuring that cluster names are unique within a peripheral. This behavior is consistent with <code>svdconv</code>, which also raises an error for this kind of conflict.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Alternate cluster has same name as other cluster\",\n)\ndef test_alternate_cluster_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates whether the parser can handle the scenario where two clusters within the same peripheral\n    are given the same name, with one marked as an alternate of the other. In this test file, `ClusterA` is\n    defined, and another cluster also named `ClusterA` is marked as its alternate. This creates a naming conflict,\n    as clusters within the same peripheral must have unique names. `svdconv` raises an error in this case, and the\n    parser should behave similarly, rejecting the file due to the name conflict.\n\n    **Expected Outcome:** The parser should raise an error indicating that two clusters with the same name cannot\n    exist within the same peripheral, even if one is designated as an alternate cluster. The file should fail to\n    process because both clusters are named `ClusterA`, creating a naming conflict. The parser should halt further\n    processing and notify the user about the issue, ensuring that cluster names are unique within a peripheral.\n    This behavior is consistent with `svdconv`, which also raises an error for this kind of conflict.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/alternate_cluster_same_name.svd\")\n</code></pre> SVD file: <code>logical_integrity/alternate_cluster_same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_cluster_same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterB description&lt;/description&gt;\n          &lt;alternateCluster&gt;ClusterA&lt;/alternateCluster&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_peripheral","title":"<code>test_alternate_peripheral</code>","text":"<p>This test ensures that the parser correctly handles the scenario where two peripherals share the same base address, with one peripheral explicitly designated as an alternate of the other. In the test file, <code>PeripheralA</code> and <code>PeripheralB</code> are defined with the same base address of <code>0x40001000</code>, but <code>PeripheralB</code> specifies <code>PeripheralA</code> as its alternate peripheral. This setup allows the peripherals to share the same memory space, which must be explicitly defined to avoid conflicts. <code>svdconv</code> processes this file without errors, and a parser implementation should do the same while respecting the alternate peripheral relationship.</p> <p>Expected Outcome: The parser should process the SVD file without errors, correctly identifying <code>PeripheralA</code> and <code>PeripheralB</code> as sharing the same base address of <code>0x40001000</code>. The device should contain two peripherals. <code>PeripheralA</code> should have no alternate peripheral specified, while <code>PeripheralB</code> should correctly list <code>PeripheralA</code> as its alternate peripheral. Both peripherals should retain their respective properties, with <code>PeripheralA</code> and <code>PeripheralB</code> each containing one register. The parser should handle this configuration without any issues, ensuring that the alternate peripheral relationship is respected and processed in line with the behavior of <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly handles the scenario where two peripherals share the same base\n    address, with one peripheral explicitly designated as an alternate of the other. In the test file,\n    `PeripheralA` and `PeripheralB` are defined with the same base address of `0x40001000`, but `PeripheralB`\n    specifies `PeripheralA` as its alternate peripheral. This setup allows the peripherals to share the same\n    memory space, which must be explicitly defined to avoid conflicts. `svdconv` processes this file without\n    errors, and a parser implementation should do the same while respecting the alternate peripheral relationship.\n\n    **Expected Outcome:** The parser should process the SVD file without errors, correctly identifying `PeripheralA`\n    and `PeripheralB` as sharing the same base address of `0x40001000`. The device should contain two peripherals.\n    `PeripheralA` should have no alternate peripheral specified, while `PeripheralB` should correctly list\n    `PeripheralA` as its alternate peripheral. Both peripherals should retain their respective properties, with\n    `PeripheralA` and `PeripheralB` each containing one register. The parser should handle this configuration\n    without any issues, ensuring that the alternate peripheral relationship is respected and processed in line\n    with the behavior of `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_peripheral.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert device.peripherals[0].alternate_peripheral is None\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001000\n    assert device.peripherals[1].alternate_peripheral == \"PeripheralA\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>logical_integrity/alternate_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_peripheral_forward_reference","title":"<code>test_alternate_peripheral_forward_reference</code>","text":"<p>This test checks how the parser handles cases where an alternate peripheral is referenced before its declaration in the SVD file. In this scenario, <code>PeripheralA</code> is defined first and lists <code>PeripheralB</code> as its alternate peripheral, even though <code>PeripheralB</code> is declared later in the file. Both peripherals share the same base address of <code>0x40001000</code>. While <code>svdconv</code> raises an error because it cannot handle forward references in alternate peripheral definitions, a more robust parser implementation should be able to process the file without any errors or warnings by correctly resolving the forward reference.</p> <p>Expected Outcome: The parser should successfully process the SVD file without raising any errors or warnings, correctly resolving the forward reference between <code>PeripheralA</code> and <code>PeripheralB</code>. <code>PeripheralA</code> should be identified with a base address of <code>0x40001000</code> and should correctly refer to <code>PeripheralB</code> as its alternate peripheral. <code>PeripheralB</code>, which is defined later in the file, should also have a base address of <code>0x40001000</code> and should not have an alternate peripheral. Both peripherals should be processed with their respective properties intact, and the parser should handle the forward reference seamlessly, ensuring a superior parsing experience compared to <code>svdconv</code>.</p> <p>Processable with svdconv: no - error (Peripheral 'PeripheralB' (@0x40001000) has same address as 'PeripheralA' (Line 18))</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_peripheral_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles cases where an alternate peripheral is referenced before its\n    declaration in the SVD file. In this scenario, `PeripheralA` is defined first and lists `PeripheralB` as its\n    alternate peripheral, even though `PeripheralB` is declared later in the file. Both peripherals share the same\n    base address of `0x40001000`. While `svdconv` raises an error because it cannot handle forward references in\n    alternate peripheral definitions, a more robust parser implementation should be able to process the file\n    without any errors or warnings by correctly resolving the forward reference.\n\n    **Expected Outcome:** The parser should successfully process the SVD file without raising any errors or warnings,\n    correctly resolving the forward reference between `PeripheralA` and `PeripheralB`. `PeripheralA` should be\n    identified with a base address of `0x40001000` and should correctly refer to `PeripheralB` as its alternate\n    peripheral. `PeripheralB`, which is defined later in the file, should also have a base address of `0x40001000`\n    and should not have an alternate peripheral. Both peripherals should be processed with their respective\n    properties intact, and the parser should handle the forward reference seamlessly, ensuring a superior parsing\n    experience compared to `svdconv`.\n\n    **Processable with svdconv:** no - error (Peripheral 'PeripheralB' (@0x40001000) has same address as 'PeripheralA'\n    (Line 18))\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_peripheral_forward_reference.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert device.peripherals[0].alternate_peripheral == \"PeripheralB\"\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001000\n    assert device.peripherals[1].alternate_peripheral is None\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>logical_integrity/alternate_peripheral_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_peripheral_forward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralB&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_peripheral_multiple","title":"<code>test_alternate_peripheral_multiple</code>","text":"<p>This test checks whether the parser can correctly handle a scenario where multiple peripherals share the same base address and are designated as alternate peripherals of the same primary peripheral. In this test file, <code>PeripheralA</code> is the primary peripheral with a base address of <code>0x40001000</code>, and both <code>PeripheralB</code> and <code>PeripheralC</code> share the same base address but are marked as alternate peripherals of <code>PeripheralA</code>. This setup is valid, and <code>svdconv</code> processes the file without any issues. A parser implementation should also handle this configuration smoothly, allowing multiple alternate peripherals without raising errors or warnings.</p> <p>Expected Outcome: The parser should successfully process the SVD file, correctly identifying that <code>PeripheralB</code> and <code>PeripheralC</code> share the same base address as <code>PeripheralA</code> and are marked as alternate peripherals. The device should contain three peripherals: <code>PeripheralA</code> with a base address of <code>0x40001000</code> and no alternate peripheral, <code>PeripheralB</code> with the same base address and marked as an alternate peripheral of <code>PeripheralA</code>, and <code>PeripheralC</code>, also with the same base address, similarly marked as an alternate peripheral of <code>PeripheralA</code>. Each peripheral should have its respective registers, and the parser should handle the alternate peripheral relationships without any errors or warnings, consistent with how <code>svdconv</code> processes such files.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_peripheral_multiple(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly handle a scenario where multiple peripherals share the same\n    base address and are designated as alternate peripherals of the same primary peripheral. In this test file,\n    `PeripheralA` is the primary peripheral with a base address of `0x40001000`, and both `PeripheralB` and\n    `PeripheralC` share the same base address but are marked as alternate peripherals of `PeripheralA`. This setup\n    is valid, and `svdconv` processes the file without any issues. A parser implementation should also handle this\n    configuration smoothly, allowing multiple alternate peripherals without raising errors or warnings.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, correctly identifying that\n    `PeripheralB` and `PeripheralC` share the same base address as `PeripheralA` and are marked as alternate\n    peripherals. The device should contain three peripherals: `PeripheralA` with a base address of `0x40001000`\n    and no alternate peripheral, `PeripheralB` with the same base address and marked as an alternate peripheral of\n    `PeripheralA`, and `PeripheralC`, also with the same base address, similarly marked as an alternate peripheral\n    of `PeripheralA`. Each peripheral should have its respective registers, and the parser should handle the\n    alternate peripheral relationships without any errors or warnings, consistent with how `svdconv` processes\n    such files.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_peripheral_multiple.svd\")\n\n    assert len(device.peripherals) == 3\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert device.peripherals[0].alternate_peripheral is None\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001000\n    assert device.peripherals[1].alternate_peripheral == \"PeripheralA\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n\n    assert device.peripherals[2].name == \"PeripheralC\"\n    assert device.peripherals[2].base_address == 0x40001000\n    assert device.peripherals[2].alternate_peripheral == \"PeripheralA\"\n    assert len(device.peripherals[2].registers_clusters) == 1\n</code></pre> SVD file: <code>logical_integrity/alternate_peripheral_multiple.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_peripheral_multiple&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_peripheral_multiple_svdconv_warning","title":"<code>test_alternate_peripheral_multiple_svdconv_warning</code>","text":"<p>This test evaluates how the parser handles a scenario where multiple peripherals share the same base address and are designated as alternates of other peripherals. In this test file, <code>PeripheralA</code>, <code>PeripheralB</code>, <code>PeripheralC</code>, and <code>PeripheralD</code> all share the same base address of <code>0x40001000</code>. <code>PeripheralB</code> and <code>PeripheralC</code> are alternates of <code>PeripheralA</code>, and <code>PeripheralD</code> is an alternate of <code>PeripheralC</code>. Although <code>svdconv</code> processes this file, it incorrectly generates a warning stating that <code>PeripheralD</code> overlaps with <code>PeripheralA</code>, without respecting the alternate peripheral relationships. A more robust parser should process this configuration without generating such an incorrect warning.</p> <p>Expected Outcome: The parser should process the file without any errors or incorrect warnings, correctly recognizing the alternate relationships. The device should contain four peripherals: <code>PeripheralA</code> with a base address of <code>0x40001000</code> and no alternate, <code>PeripheralB</code> and <code>PeripheralC</code>, both with the same base address and marked as alternates of <code>PeripheralA</code>, and <code>PeripheralD</code>, which also shares the same base address but is an alternate of <code>PeripheralC</code>. Each peripheral should have its own registers, and the parser should handle this setup seamlessly, ensuring that the alternate relationships are processed correctly without the erroneous warnings generated by <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_peripheral_multiple_svdconv_warning(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the parser handles a scenario where multiple peripherals share the same base address\n    and are designated as alternates of other peripherals. In this test file, `PeripheralA`, `PeripheralB`,\n    `PeripheralC`, and `PeripheralD` all share the same base address of `0x40001000`. `PeripheralB` and\n    `PeripheralC` are alternates of `PeripheralA`, and `PeripheralD` is an alternate of `PeripheralC`. Although\n    `svdconv` processes this file, it incorrectly generates a warning stating that `PeripheralD` overlaps with\n    `PeripheralA`, without respecting the alternate peripheral relationships. A more robust parser should process\n    this configuration without generating such an incorrect warning.\n\n    **Expected Outcome:** The parser should process the file without any errors or incorrect warnings, correctly\n    recognizing the alternate relationships. The device should contain four peripherals: `PeripheralA` with a base\n    address of `0x40001000` and no alternate, `PeripheralB` and `PeripheralC`, both with the same base address and\n    marked as alternates of `PeripheralA`, and `PeripheralD`, which also shares the same base address but is an\n    alternate of `PeripheralC`. Each peripheral should have its own registers, and the parser should handle this\n    setup seamlessly, ensuring that the alternate relationships are processed correctly without the erroneous\n    warnings generated by `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_peripheral_multiple_svdconv_warning.svd\")\n\n    assert len(device.peripherals) == 4\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert device.peripherals[0].alternate_peripheral is None\n    assert len(device.peripherals[0].registers_clusters) == 1\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001000\n    assert device.peripherals[1].alternate_peripheral == \"PeripheralA\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n\n    assert device.peripherals[2].name == \"PeripheralC\"\n    assert device.peripherals[2].base_address == 0x40001000\n    assert device.peripherals[2].alternate_peripheral == \"PeripheralA\"\n    assert len(device.peripherals[2].registers_clusters) == 1\n\n    assert device.peripherals[3].name == \"PeripheralD\"\n    assert device.peripherals[3].base_address == 0x40001000\n    assert device.peripherals[3].alternate_peripheral == \"PeripheralC\"\n    assert len(device.peripherals[3].registers_clusters) == 1\n</code></pre> SVD file: <code>logical_integrity/alternate_peripheral_multiple_svdconv_warning.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_peripheral_multiple_svdconv_warning&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralD&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralC&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_peripheral_overlap","title":"<code>test_alternate_peripheral_overlap</code>","text":"<p>This test checks whether the parser can correctly handle the scenario where two peripherals overlap in their memory address space, but one is designated as an alternate peripheral of the other. In this test file, <code>PeripheralA</code> starts at base address <code>0x40001000</code>, and <code>PeripheralB</code> starts at <code>0x40001500</code>, partially overlapping with <code>PeripheralA</code>. Since <code>PeripheralB</code> is explicitly marked as an alternate peripheral of <code>PeripheralA</code>, this overlap is allowed without raising an error or warning. <code>svdconv</code> processes this without issue, and a parser implementation should behave similarly, handling the overlap correctly when alternate peripherals are defined.</p> <p>Expected Outcome: The parser should process the SVD file successfully without raising any errors or warnings. The device should contain two peripherals: <code>PeripheralA</code> with a base address of <code>0x40001000</code> and no alternate peripheral, and <code>PeripheralB</code> with a base address of <code>0x40001500</code>, which overlaps with <code>PeripheralA</code> but is correctly marked as an alternate peripheral of <code>PeripheralA</code>. Both peripherals should contain their respective registers, and the parser should ensure that the overlap is handled correctly due to the alternate peripheral relationship, consistent with how <code>svdconv</code> handles such scenarios.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_peripheral_overlap(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly handle the scenario where two peripherals overlap in their\n    memory address space, but one is designated as an alternate peripheral of the other. In this test file,\n    `PeripheralA` starts at base address `0x40001000`, and `PeripheralB` starts at `0x40001500`, partially\n    overlapping with `PeripheralA`. Since `PeripheralB` is explicitly marked as an alternate peripheral of\n    `PeripheralA`, this overlap is allowed without raising an error or warning. `svdconv` processes this without\n    issue, and a parser implementation should behave similarly, handling the overlap correctly when alternate\n    peripherals are defined.\n\n    **Expected Outcome:** The parser should process the SVD file successfully without raising any errors or warnings.\n    The device should contain two peripherals: `PeripheralA` with a base address of `0x40001000` and no alternate\n    peripheral, and `PeripheralB` with a base address of `0x40001500`, which overlaps with `PeripheralA` but is\n    correctly marked as an alternate peripheral of `PeripheralA`. Both peripherals should contain their respective\n    registers, and the parser should ensure that the overlap is handled correctly due to the alternate peripheral\n    relationship, consistent with how `svdconv` handles such scenarios.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_peripheral_overlap.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert device.peripherals[0].alternate_peripheral is None\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001500\n    assert device.peripherals[1].alternate_peripheral == \"PeripheralA\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>logical_integrity/alternate_peripheral_overlap.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_peripheral_overlap&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001500&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_peripheral_same_name","title":"<code>test_alternate_peripheral_same_name</code>","text":"<p>This test evaluates whether the parser can correctly detect and handle the situation where a peripheral is marked as an alternate peripheral of another peripheral with the same name. In this test file, two peripherals share the same name, and one is designated as an alternate peripheral of the other. This scenario introduces ambiguity and conflicts in memory mapping and identification, as each peripheral must have a unique name. <code>svdconv</code> raises an error in this case due to the naming conflict, and a parser should similarly reject this file to prevent confusion in the device definition.</p> <p>Expected Outcome: The parser should raise an error indicating that a peripheral cannot be marked as an alternate peripheral of another peripheral with the same name. Both peripherals are named identically, which creates ambiguity and violates the requirement for unique peripheral names. The parser should halt processing and notify the user of the conflict, ensuring that each peripheral is uniquely identified. This behavior aligns with <code>svdconv</code>, which also raises an error in such cases, preventing the SVD file from being processed due to the naming conflict.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Alternate peripheral has same name as other peripheral\",\n)\ndef test_alternate_peripheral_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates whether the parser can correctly detect and handle the situation where a peripheral is\n    marked as an alternate peripheral of another peripheral with the same name. In this test file, two peripherals\n    share the same name, and one is designated as an alternate peripheral of the other. This scenario introduces\n    ambiguity and conflicts in memory mapping and identification, as each peripheral must have a unique name.\n    `svdconv` raises an error in this case due to the naming conflict, and a parser should similarly reject this\n    file to prevent confusion in the device definition.\n\n    **Expected Outcome:** The parser should raise an error indicating that a peripheral cannot be marked as an\n    alternate peripheral of another peripheral with the same name. Both peripherals are named identically, which\n    creates ambiguity and violates the requirement for unique peripheral names. The parser should halt processing\n    and notify the user of the conflict, ensuring that each peripheral is uniquely identified. This behavior\n    aligns with `svdconv`, which also raises an error in such cases, preventing the SVD file from being processed\n    due to the naming conflict.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/alternate_peripheral_same_name.svd\")\n</code></pre> SVD file: <code>logical_integrity/alternate_peripheral_same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_peripheral_same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_register","title":"<code>test_alternate_register</code>","text":"<p>This test checks whether the parser correctly handles registers that are marked as alternate registers. In this test file, <code>RegisterB</code> is defined as an alternate register of <code>RegisterA</code>, meaning that both registers share the same address but have different functionalities or configurations. The test ensures that the parser can handle the alternate register relationship without issues. <code>svdconv</code> processes this file without errors, and a parser implementation should also be able to handle this scenario correctly.</p> <p>Expected Outcome: The parser should successfully process the SVD file, correctly identifying that <code>RegisterB</code> is an alternate register of <code>RegisterA</code>. The device should contain one peripheral with two registers: <code>RegisterA</code>, which has an address offset of <code>0x0</code> and a size of 32 bits, and <code>RegisterB</code>, which also has an address offset of <code>0x0</code> and a size of 32 bits but is marked as an alternate register of <code>RegisterA</code>. The parser should accurately reflect this relationship without any warnings or errors, ensuring that the alternate register configuration is handled properly, consistent with the behavior of <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_register(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser correctly handles registers that are marked as alternate registers. In\n    this test file, `RegisterB` is defined as an alternate register of `RegisterA`, meaning that both registers\n    share the same address but have different functionalities or configurations. The test ensures that the parser\n    can handle the alternate register relationship without issues. `svdconv` processes this file without errors,\n    and a parser implementation should also be able to handle this scenario correctly.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, correctly identifying that `RegisterB`\n    is an alternate register of `RegisterA`. The device should contain one peripheral with two registers:\n    `RegisterA`, which has an address offset of `0x0` and a size of 32 bits, and `RegisterB`, which also has an\n    address offset of `0x0` and a size of 32 bits but is marked as an alternate register of `RegisterA`. The\n    parser should accurately reflect this relationship without any warnings or errors, ensuring that the alternate\n    register configuration is handled properly, consistent with the behavior of `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_register.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_register is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_register == \"RegisterA\"\n</code></pre> SVD file: <code>logical_integrity/alternate_register.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_register&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;alternateRegister&gt;RegisterA&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_register_and_alternate_group_exception","title":"<code>test_alternate_register_and_alternate_group_exception</code>","text":"<p>TODO: Add description</p> <p>Expected Outcome: TODO</p> <p>Processable with svdconv: yes - but it shouldn't since it is contrary to the SVD standard</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"alternateGroup and alternateRegister are mutually exclusive\",\n)\ndef test_alternate_register_and_alternate_group_exception(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    TODO: Add description\n\n    **Expected Outcome:** TODO\n\n    **Processable with svdconv:** yes - but it shouldn't since it is contrary to the SVD standard\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/alternate_register_and_alternate_group_exception.svd\")\n</code></pre> SVD file: <code>logical_integrity/alternate_register_and_alternate_group_exception.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_register_and_alternate_group_exception&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;alternateGroup&gt;GroupA&lt;/alternateGroup&gt;\n          &lt;alternateRegister&gt;RegisterB&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_register_forward_reference","title":"<code>test_alternate_register_forward_reference</code>","text":"<p>This test checks how the parser handles cases where a register is marked as an alternate register of another register before the latter is defined. In this test file, <code>RegisterA</code> refers to <code>RegisterB</code> as its alternate register, even though <code>RegisterB</code> is declared later in the file. While <code>svdconv</code> cannot handle forward references in alternate register definitions and raises an error, a robust parser implementation should resolve this forward reference and process the file without any issues.</p> <p>Expected Outcome: The parser should successfully process the SVD file without raising any errors or warnings, correctly resolving the forward reference between <code>RegisterA</code> and <code>RegisterB</code>. The device should contain one peripheral with two registers: <code>RegisterA</code>, which has an address offset of <code>0x0</code> and a size of 32 bits, and lists <code>RegisterB</code> as its alternate register. <code>RegisterB</code>, declared later, should also have an address offset of <code>0x0</code> and a size of 32 bits but does not have an alternate register. The parser should handle this forward reference seamlessly, ensuring that both registers are processed correctly, without any of the limitations present in <code>svdconv</code>.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_register_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles cases where a register is marked as an alternate register of another\n    register before the latter is defined. In this test file, `RegisterA` refers to `RegisterB` as its alternate\n    register, even though `RegisterB` is declared later in the file. While `svdconv` cannot handle forward\n    references in alternate register definitions and raises an error, a robust parser implementation should\n    resolve this forward reference and process the file without any issues.\n\n    **Expected Outcome:** The parser should successfully process the SVD file without raising any errors or warnings,\n    correctly resolving the forward reference between `RegisterA` and `RegisterB`. The device should contain one\n    peripheral with two registers: `RegisterA`, which has an address offset of `0x0` and a size of 32 bits, and\n    lists `RegisterB` as its alternate register. `RegisterB`, declared later, should also have an address offset\n    of `0x0` and a size of 32 bits but does not have an alternate register. The parser should handle this forward\n    reference seamlessly, ensuring that both registers are processed correctly, without any of the limitations\n    present in `svdconv`.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_register_forward_reference.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_register == \"RegisterB\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_register is None\n</code></pre> SVD file: <code>logical_integrity/alternate_register_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_register_forward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;alternateRegister&gt;RegisterB&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_register_multiple","title":"<code>test_alternate_register_multiple</code>","text":"<p>This test ensures that the parser can handle multiple registers that share the same address and are designated as alternates of one another. In this test file, <code>RegisterA</code> is defined at address offset <code>0x0</code> and serves as the primary register. <code>RegisterB</code>, <code>RegisterC</code>, and <code>RegisterD</code> are also defined at the same address, with each marked as an alternate register. <code>RegisterB</code> and <code>RegisterC</code> are alternates of <code>RegisterA</code>, and <code>RegisterD</code> is an alternate of <code>RegisterC</code>. While <code>svdconv</code> processes this file without issue, the parser should also handle the configuration without raising any errors.</p> <p>Expected Outcome: The parser should process the file successfully, correctly identifying the relationships between the registers. <code>RegisterA</code> should be recognized as the primary register, with <code>RegisterB</code> and <code>RegisterC</code> being alternates of <code>RegisterA</code>. <code>RegisterD</code> should be recognized as an alternate of <code>RegisterC</code>. All registers share the same address offset of <code>0x0</code> and have a size of 32 bits. The parser should handle this setup without issuing any warnings or errors, ensuring it processes the multiple alternate register relationships as expected, similar to <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_register_multiple(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser can handle multiple registers that share the same address and are designated\n    as alternates of one another. In this test file, `RegisterA` is defined at address offset `0x0` and serves as\n    the primary register. `RegisterB`, `RegisterC`, and `RegisterD` are also defined at the same address, with\n    each marked as an alternate register. `RegisterB` and `RegisterC` are alternates of `RegisterA`, and\n    `RegisterD` is an alternate of `RegisterC`. While `svdconv` processes this file without issue, the parser\n    should also handle the configuration without raising any errors.\n\n    **Expected Outcome:** The parser should process the file successfully, correctly identifying the relationships\n    between the registers. `RegisterA` should be recognized as the primary register, with `RegisterB` and\n    `RegisterC` being alternates of `RegisterA`. `RegisterD` should be recognized as an alternate of `RegisterC`.\n    All registers share the same address offset of `0x0` and have a size of 32 bits. The parser should handle this\n    setup without issuing any warnings or errors, ensuring it processes the multiple alternate register\n    relationships as expected, similar to `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_register_multiple.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 4\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_register is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_register == \"RegisterA\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Register)\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterC\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[2].size == 32\n    assert device.peripherals[0].registers_clusters[2].alternate_register == \"RegisterA\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[3], Register)\n    assert device.peripherals[0].registers_clusters[3].name == \"RegisterD\"\n    assert device.peripherals[0].registers_clusters[3].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[3].size == 32\n    assert device.peripherals[0].registers_clusters[3].alternate_register == \"RegisterC\"\n</code></pre> SVD file: <code>logical_integrity/alternate_register_multiple.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_register_multiple&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;alternateRegister&gt;RegisterA&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterC&lt;/name&gt;\n          &lt;alternateRegister&gt;RegisterA&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterD&lt;/name&gt;\n          &lt;alternateRegister&gt;RegisterC&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_register_overlap","title":"<code>test_alternate_register_overlap</code>","text":"<p>This test checks whether the parser can correctly handle registers that overlap in memory but are defined as alternate registers. In this test file, <code>RegisterA</code> is defined at address offset <code>0x0</code>, and <code>RegisterB</code> is defined at address offset <code>0x2</code> with overlapping memory space. <code>RegisterB</code> is marked as an alternate register of <code>RegisterA</code>, allowing for the overlap. <code>svdconv</code> processes this file without any issues or warnings, and a parser implementation should also handle this scenario smoothly without raising any warnings or errors.</p> <p>Expected Outcome: The parser should successfully process the SVD file, correctly identifying that <code>RegisterB</code> overlaps with <code>RegisterA</code> and is marked as an alternate register. The device should contain one peripheral with two registers: <code>RegisterA</code> at address offset <code>0x0</code> with a size of 32 bits and <code>RegisterB</code> at address offset <code>0x2</code> with a size of 16 bits, which overlaps with <code>RegisterA</code> but is marked as its alternate register. The parser should handle this configuration without any warnings or errors, similar to <code>svdconv</code>, ensuring that the alternate register relationship is processed correctly despite the overlapping memory addresses.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_register_overlap(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly handle registers that overlap in memory but are defined as\n    alternate registers. In this test file, `RegisterA` is defined at address offset `0x0`, and `RegisterB` is\n    defined at address offset `0x2` with overlapping memory space. `RegisterB` is marked as an alternate register\n    of `RegisterA`, allowing for the overlap. `svdconv` processes this file without any issues or warnings, and a\n    parser implementation should also handle this scenario smoothly without raising any warnings or errors.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, correctly identifying that `RegisterB`\n    overlaps with `RegisterA` and is marked as an alternate register. The device should contain one peripheral\n    with two registers: `RegisterA` at address offset `0x0` with a size of 32 bits and `RegisterB` at address\n    offset `0x2` with a size of 16 bits, which overlaps with `RegisterA` but is marked as its alternate register.\n    The parser should handle this configuration without any warnings or errors, similar to `svdconv`, ensuring\n    that the alternate register relationship is processed correctly despite the overlapping memory addresses.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/alternate_register_overlap.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_register is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].size == 16\n    assert device.peripherals[0].registers_clusters[1].alternate_register == \"RegisterA\"\n</code></pre> SVD file: <code>logical_integrity/alternate_register_overlap.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_register_overlap&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;alternateRegister&gt;RegisterA&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_alternate_register_same_name","title":"<code>test_alternate_register_same_name</code>","text":"<p>This test checks how the parser handles a situation where a register is marked as an alternate register of another register with the same name within the same peripheral. In this test file, <code>RegisterA</code> is defined as a regular register, and another <code>RegisterA</code> is defined as its alternate, causing a naming conflict. <code>svdconv</code> raises an error in this case, as registers within the same peripheral must have unique names, even if one is marked as an alternate. A parser implementation should also detect this naming conflict and raise an appropriate error.</p> <p>Expected Outcome: The parser should raise an error indicating that <code>RegisterA</code> cannot be defined as both a regular register and an alternate register with the same name within the same peripheral. The file should fail to process due to the naming conflict, as each register in a peripheral must have a unique identifier to avoid ambiguity. The parser should halt processing and notify the user of the conflict, ensuring that register names remain distinct, which aligns with the behavior of <code>svdconv</code>, which also raises an error in this case.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Alternate register has same name as other register\",\n)\ndef test_alternate_register_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles a situation where a register is marked as an alternate register of\n    another register with the same name within the same peripheral. In this test file, `RegisterA` is defined as a\n    regular register, and another `RegisterA` is defined as its alternate, causing a naming conflict. `svdconv`\n    raises an error in this case, as registers within the same peripheral must have unique names, even if one is\n    marked as an alternate. A parser implementation should also detect this naming conflict and raise an\n    appropriate error.\n\n    **Expected Outcome:** The parser should raise an error indicating that `RegisterA` cannot be defined as both a\n    regular register and an alternate register with the same name within the same peripheral. The file should fail\n    to process due to the naming conflict, as each register in a peripheral must have a unique identifier to avoid\n    ambiguity. The parser should halt processing and notify the user of the conflict, ensuring that register names\n    remain distinct, which aligns with the behavior of `svdconv`, which also raises an error in this case.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/alternate_register_same_name.svd\")\n</code></pre> SVD file: <code>logical_integrity/alternate_register_same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_register_same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;alternateRegister&gt;RegisterA&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_different_register_names_in_peripheral","title":"<code>test_different_register_names_in_peripheral</code>","text":"<p>This test ensures that the parser correctly processes a peripheral containing multiple registers, each with a unique name, but no address overlap. The test file includes a single peripheral that contains two distinct registers, <code>RegisterA</code> and <code>RegisterB</code>, each with different address offsets and properties. The purpose of the test is to verify that the parser can accurately differentiate between registers with different names within the same peripheral and correctly handle their respective properties.</p> <p>Expected Outcome: The parser should successfully process the SVD file, identifying that the peripheral contains two registers, <code>RegisterA</code> and <code>RegisterB</code>. <code>RegisterA</code> should have an address offset of <code>0x0</code> and a size of 32 bits, while <code>RegisterB</code> should have an address offset of <code>0x4</code> and a size of 32 bits. The parser should correctly handle both registers, ensuring that they are uniquely identified within the same peripheral without any naming conflicts or errors.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_different_register_names_in_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly processes a peripheral containing multiple registers, each with a\n    unique name, but no address overlap. The test file includes a single peripheral that contains two distinct\n    registers, `RegisterA` and `RegisterB`, each with different address offsets and properties. The purpose of the\n    test is to verify that the parser can accurately differentiate between registers with different names within\n    the same peripheral and correctly handle their respective properties.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, identifying that the peripheral\n    contains two registers, `RegisterA` and `RegisterB`. `RegisterA` should have an address offset of `0x0` and a\n    size of 32 bits, while `RegisterB` should have an address offset of `0x4` and a size of 32 bits. The parser\n    should correctly handle both registers, ensuring that they are uniquely identified within the same peripheral\n    without any naming conflicts or errors.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/different_register_names_in_peripheral.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>logical_integrity/different_register_names_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;different_register_names_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_field_bit_range_processing","title":"<code>test_field_bit_range_processing</code>","text":"<p>This test validates the parser's ability to process and interpret bit ranges in a field using three mutually exclusive methods defined by the CMSIS-SVD standard: bitRangeOffsetWidthStyle, bitRangeLsbMsbStyle, and bitRangePattern. Each method offers a different way to describe the position and width of a field within a register. The parser must correctly process fields defined by any of these methods and convert them into a consistent internal representation of the least significant bit (LSB) and the most significant bit (MSB) of the field.</p> <p>Expected Outcome: The parser should correctly process the SVD file and handle all three bit range formats without errors. It should translate the fields defined by bitOffset/bitWidth, lsb/msb, and bitRange into consistent LSB and MSB values. Specifically, <code>FieldA</code>, <code>FieldB</code>, and <code>FieldC</code> should have correctly processed bit positions, ensuring that the register is fully described with non-overlapping bit fields from LSB 0 to MSB 11.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_field_bit_range_processing(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test validates the parser's ability to process and interpret bit ranges in a field using three mutually\n    exclusive methods defined by the CMSIS-SVD standard: bitRangeOffsetWidthStyle, bitRangeLsbMsbStyle, and\n    bitRangePattern. Each method offers a different way to describe the position and width of a field within a\n    register. The parser must correctly process fields defined by any of these methods and convert them into a\n    consistent internal representation of the least significant bit (LSB) and the most significant bit (MSB) of\n    the field.\n\n    **Expected Outcome:** The parser should correctly process the SVD file and handle all three bit range formats\n    without errors. It should translate the fields defined by bitOffset/bitWidth, lsb/msb, and bitRange into\n    consistent LSB and MSB values. Specifically, `FieldA`, `FieldB`, and `FieldC` should have correctly processed\n    bit positions, ensuring that the register is fully described with non-overlapping bit fields from LSB 0 to MSB\n    11.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/field_bit_range_processing.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 3\n\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 3\n\n    assert device.peripherals[0].registers_clusters[0].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[0].fields[1].lsb == 4\n    assert device.peripherals[0].registers_clusters[0].fields[1].msb == 7\n\n    assert device.peripherals[0].registers_clusters[0].fields[2].name == \"FieldC\"\n    assert device.peripherals[0].registers_clusters[0].fields[2].lsb == 8\n    assert device.peripherals[0].registers_clusters[0].fields[2].msb == 11\n</code></pre> SVD file: <code>logical_integrity/field_bit_range_processing.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;field_bit_range_processing&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;4&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;lsb&gt;4&lt;/lsb&gt;\n              &lt;msb&gt;7&lt;/msb&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldC&lt;/name&gt;\n              &lt;bitRange&gt;[11:8]&lt;/bitRange&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_field_illogical_values_in_bitrangepattern","title":"<code>test_field_illogical_values_in_bitrangepattern</code>","text":"<p>This test checks if the parser correctly handles a <code>bitRangePattern</code> where the least significant bit (LSB) is greater than the most significant bit (MSB).</p> <p>Expected Outcome: The parser should raise a warning indicating that the bit range is illogical because the LSB is greater than the MSB and should switch the values of LSB and MSB.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_field_illogical_values_in_bitrangepattern(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks if the parser correctly handles a `bitRangePattern` where the least significant bit (LSB) is\n    greater than the most significant bit (MSB).\n\n    **Expected Outcome:** The parser should raise a warning indicating that the bit range is illogical because the LSB\n    is greater than the MSB and should switch the values of LSB and MSB.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/field_illogical_values_in_bitrangepattern.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 8\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 11\n</code></pre> SVD file: <code>logical_integrity/field_illogical_values_in_bitrangepattern.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;field_illogical_values_in_bitrangepattern&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[8:11]&lt;/bitRange&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_field_wrong_string_in_bitrangepattern","title":"<code>test_field_wrong_string_in_bitrangepattern</code>","text":"<p>The <code>bitRangePattern</code> must conform to the format <code>\\[([0-6])?[0-9]:([0-6])?[0-9]\\]</code>, as defined by the CMSIS- SVD standard. If the string in <code>bitRangePattern</code> does not match this pattern, an error should be raised. This test ensures that the parser validates the bit range format correctly, in line with how <code>svdconv</code> behaves when encountering invalid bit range strings.</p> <p>Expected Outcome: The parser should raise an error indicating that the string in the <code>bitRangePattern</code> is incorrect, as it does not match the required format. The test will fail if the parser does not handle this invalid format appropriately, which corresponds with the behavior seen in <code>svdconv</code>.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Wrong string in bitRangePattern\",\n)\ndef test_field_wrong_string_in_bitrangepattern(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    The `bitRangePattern` must conform to the format `\\\\[([0-6])?[0-9]:([0-6])?[0-9]\\\\]`, as defined by the CMSIS-\n    SVD standard. If the string in `bitRangePattern` does not match this pattern, an error should be raised. This\n    test ensures that the parser validates the bit range format correctly, in line with how `svdconv` behaves when\n    encountering invalid bit range strings.\n\n    **Expected Outcome:** The parser should raise an error indicating that the string in the `bitRangePattern` is\n    incorrect, as it does not match the required format. The test will fail if the parser does not handle this\n    invalid format appropriately, which corresponds with the behavior seen in `svdconv`.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/field_wrong_string_in_bitrangepattern.svd\")\n</code></pre> SVD file: <code>logical_integrity/field_wrong_string_in_bitrangepattern.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;field_wrong_string_in_bitrangepattern&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitRange&gt;[11-8]&lt;/bitRange&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_fields_overlap_bit_offset","title":"<code>test_fields_overlap_bit_offset</code>","text":"<p>This test ensures that the parser correctly identifies overlapping fields within the same register, where multiple fields are assigned the same bit offset or range. In the CMSIS-SVD standard, fields within a register must occupy unique, non-overlapping bit ranges. If two fields share the same bit offset, it creates a conflict that can lead to incorrect behavior in the device description. The parser must detect such overlaps and raise an error.</p> <p>Expected Outcome: The parser should raise an error indicating that two fields within the same register overlap in their bit offsets. The device description should not be processed further due to this conflict, ensuring that the integrity of the SVD file is maintained.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Field overlaps other field\",\n)\ndef test_fields_overlap_bit_offset(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly identifies overlapping fields within the same register, where\n    multiple fields are assigned the same bit offset or range. In the CMSIS-SVD standard, fields within a register\n    must occupy unique, non-overlapping bit ranges. If two fields share the same bit offset, it creates a conflict\n    that can lead to incorrect behavior in the device description. The parser must detect such overlaps and raise\n    an error.\n\n    **Expected Outcome:** The parser should raise an error indicating that two fields within the same register overlap\n    in their bit offsets. The device description should not be processed further due to this conflict, ensuring\n    that the integrity of the SVD file is maintained.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/fields_overlap_bit_offset.svd\")\n</code></pre> SVD file: <code>logical_integrity/fields_overlap_bit_offset.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;fields_overlap_bit_offset&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;4&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;3&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;4&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_fields_same_bit_offset","title":"<code>test_fields_same_bit_offset</code>","text":"<p>This test ensures that the parser correctly identifies fields with the same range within a register. In the CMSIS-SVD standard, fields within a register must occupy unique, non-overlapping bit ranges. If two fields share the same range, it creates a conflict that can lead to incorrect behavior in the device description. The parser must detect such overlaps and raise an error.</p> <p>Expected Outcome: The parser should raise an error indicating that two fields within the same register have the same range. The device description should not be processed further due to this conflict, ensuring that the integrity of the SVD file is maintained.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Field overlaps other field\",\n)\ndef test_fields_same_bit_offset(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly identifies fields with the same range within a register. In the\n    CMSIS-SVD standard, fields within a register must occupy unique, non-overlapping bit ranges. If two fields\n    share the same range, it creates a conflict that can lead to incorrect behavior in the device description. The\n    parser must detect such overlaps and raise an error.\n\n    **Expected Outcome:** The parser should raise an error indicating that two fields within the same register have\n    the same range. The device description should not be processed further due to this conflict, ensuring that the\n    integrity of the SVD file is maintained.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/fields_same_bit_offset.svd\")\n</code></pre> SVD file: <code>logical_integrity/fields_same_bit_offset.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;fields_same_bit_offset&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;4&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;4&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_fields_same_names","title":"<code>test_fields_same_names</code>","text":"<p>This test ensures that the parser correctly identifies and handles cases where two fields within the same register are given the same name. In the CMSIS-SVD standard, field names within a register must be unique. If two fields share the same name, it creates ambiguity, which could lead to incorrect behavior in the device description. <code>svdconv</code> correctly identifies this issue as error, whereas the parser should explicitly raise an error, preventing the creation of registers with duplicated field names.</p> <p>Expected Outcome: The parser should raise an error indicating that two fields within the same register share the same name. The device should not be processed further, and the parser must halt execution due to the field naming conflict, ensuring the integrity of the SVD description.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Field has same name as other field\",\n)\ndef test_fields_same_names(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly identifies and handles cases where two fields within the same\n    register are given the same name. In the CMSIS-SVD standard, field names within a register must be unique. If\n    two fields share the same name, it creates ambiguity, which could lead to incorrect behavior in the device\n    description. `svdconv` correctly identifies this issue as error, whereas the parser should explicitly raise an\n    error, preventing the creation of registers with duplicated field names.\n\n    **Expected Outcome:** The parser should raise an error indicating that two fields within the same register share\n    the same name. The device should not be processed further, and the parser must halt execution due to the field\n    naming conflict, ensuring the integrity of the SVD description.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/fields_same_names.svd\")\n</code></pre> SVD file: <code>logical_integrity/fields_same_names.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;fields_same_names&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;4&lt;/bitWidth&gt;\n            &lt;/field&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;4&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;4&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_ignore_empty_cluster","title":"<code>test_ignore_empty_cluster</code>","text":"<p>TODO: Add description</p> <p>Expected Outcome: TODO</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_ignore_empty_cluster(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    TODO: Add description\n\n    **Expected Outcome:** TODO\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/ignore_empty_cluster.svd\")\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x4\n</code></pre> SVD file: <code>logical_integrity/ignore_empty_cluster.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;ignore_empty_cluster&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/cluster&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_ignore_empty_cluster_two_level","title":"<code>test_ignore_empty_cluster_two_level</code>","text":"<p>TODO: Add description</p> <p>Expected Outcome: TODO</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_ignore_empty_cluster_two_level(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    TODO: Add description\n\n    **Expected Outcome:** TODO\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/ignore_empty_cluster_two_level.svd\")\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x4\n</code></pre> SVD file: <code>logical_integrity/ignore_empty_cluster_two_level.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;ignore_empty_cluster_two_level&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;cluster&gt;\n            &lt;name&gt;ClusterB&lt;/name&gt;\n            &lt;description&gt;ClusterB description&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/cluster&gt;\n        &lt;/cluster&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_ignore_empty_inner_cluster","title":"<code>test_ignore_empty_inner_cluster</code>","text":"<p>TODO: Add description</p> <p>Expected Outcome: TODO</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_ignore_empty_inner_cluster(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    TODO: Add description\n\n    **Expected Outcome:** TODO\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/ignore_empty_inner_cluster.svd\")\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n</code></pre> SVD file: <code>logical_integrity/ignore_empty_inner_cluster.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;ignore_empty_inner_cluster&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;cluster&gt;\n            &lt;name&gt;ClusterB&lt;/name&gt;\n            &lt;description&gt;ClusterB description&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/cluster&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_ignore_empty_peripheral","title":"<code>test_ignore_empty_peripheral</code>","text":"<p>TODO: Add description</p> <p>Expected Outcome: TODO</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_ignore_empty_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    TODO: Add description\n\n    **Expected Outcome:** TODO\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/ignore_empty_peripheral.svd\")\n\n    assert len(device.peripherals) == 2\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n\n    assert device.peripherals[1].name == \"PeripheralC\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n</code></pre> SVD file: <code>logical_integrity/ignore_empty_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;ignore_empty_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;32&lt;/size&gt;\n          &lt;access&gt;read-write&lt;/access&gt;\n          &lt;resetValue&gt;0x0&lt;/resetValue&gt;\n          &lt;resetMask&gt;0xFFFFFFFF&lt;/resetMask&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;32&lt;/size&gt;\n          &lt;access&gt;read-write&lt;/access&gt;\n          &lt;resetValue&gt;0x0&lt;/resetValue&gt;\n          &lt;resetMask&gt;0xFFFFFFFF&lt;/resetMask&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_overlap_register_addresses_in_peripheral","title":"<code>test_overlap_register_addresses_in_peripheral</code>","text":"<p>This test ensures that the parser correctly handles scenarios where registers within the same peripheral have overlapping address ranges. The test file defines a peripheral that contains two registers, <code>RegisterA</code> and <code>RegisterB</code>. <code>RegisterA</code> starts at address offset <code>0x0</code> with a size of 32 bits, while <code>RegisterB</code> starts at address offset <code>0x2</code> with a size of 16 bits, resulting in an overlap between their address spaces. While overlapping registers usually signal a potential conflict in memory mapping, <code>svdconv</code> processes such cases with warnings rather than errors to ensure backward compatibility.</p> <p>Expected Outcome: The parser should successfully process the file while issuing a warning indicating that <code>RegisterA</code> and <code>RegisterB</code> have overlapping address spaces. The peripheral should contain two registers: <code>RegisterA</code> with an address offset of <code>0x0</code> and a size of 32 bits, and <code>RegisterB</code> with an address offset of <code>0x2</code> and a size of 16 bits. Despite the overlap in address ranges, the parser should allow the SVD file to be processed, maintaining compatibility with <code>svdconv</code> behavior, and should alert the user to the potential issue through a warning, ensuring awareness of the address overlap without halting the process.</p> <p>Processable with svdconv: yes - with warnings</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_overlap_register_addresses_in_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly handles scenarios where registers within the same peripheral have\n    overlapping address ranges. The test file defines a peripheral that contains two registers, `RegisterA` and\n    `RegisterB`. `RegisterA` starts at address offset `0x0` with a size of 32 bits, while `RegisterB` starts at\n    address offset `0x2` with a size of 16 bits, resulting in an overlap between their address spaces. While\n    overlapping registers usually signal a potential conflict in memory mapping, `svdconv` processes such cases\n    with warnings rather than errors to ensure backward compatibility.\n\n    **Expected Outcome:** The parser should successfully process the file while issuing a warning indicating that\n    `RegisterA` and `RegisterB` have overlapping address spaces. The peripheral should contain two registers:\n    `RegisterA` with an address offset of `0x0` and a size of 32 bits, and `RegisterB` with an address offset of\n    `0x2` and a size of 16 bits. Despite the overlap in address ranges, the parser should allow the SVD file to be\n    processed, maintaining compatibility with `svdconv` behavior, and should alert the user to the potential issue\n    through a warning, ensuring awareness of the address overlap without halting the process.\n\n    **Processable with svdconv:** yes - with warnings\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/overlap_register_addresses_in_peripheral.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].size == 16\n</code></pre> SVD file: <code>logical_integrity/overlap_register_addresses_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;overlap_register_addresses_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_overlap_register_cluster_addresses_in_peripheral","title":"<code>test_overlap_register_cluster_addresses_in_peripheral</code>","text":"<p>This test ensures that the parser can handle scenarios where the address ranges of a standalone register and a cluster within the same peripheral overlap. The test file defines a peripheral containing <code>RegisterA</code>, which starts at address offset <code>0x0</code> with a size of 32 bits, and a cluster named <code>ClusterA</code>, starting at address offset <code>0x2</code>. Inside <code>ClusterA</code>, there is a register named <code>RegisterB</code> that starts at address offset <code>0x2</code> and has a size of 16 bits (<code>ClusterA</code> has therefore also a size of 16 bits). Although <code>svdconv</code> does not recognize this overlap and processes the file without a warning or an error, a parser implementation should detect this condition and issue a warning to the user, as overlapping address ranges can lead to ambiguity in register mapping and potential issues during integration.</p> <p>Expected Outcome: The parser should successfully process the SVD file while issuing a warning to inform the user that <code>RegisterA</code> and <code>ClusterA</code> have overlapping address ranges. Specifically, <code>RegisterA</code> starts at <code>0x0</code> with a size of 32 bits, and <code>ClusterA</code> starts at <code>0x2</code> with a size of 16 bits, which causes part of <code>ClusterA</code> (including <code>RegisterB</code> at offset <code>0x2</code>) to overlap with the address range covered by <code>RegisterA</code>. The peripheral should contain two top-level entities: <code>RegisterA</code>, with an address offset of <code>0x0</code> and a size of 32 bits, and <code>ClusterA</code>, with an address offset of <code>0x2</code> and a size of 16 bits. Within <code>ClusterA</code>, <code>RegisterB</code> should also have an address offset of <code>0x2</code> and a size of 16 bits, which contributes to the address overlap. The parser should handle this situation by issuing a warning, allowing the file to be processed while ensuring that users are informed of the potential conflict.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_overlap_register_cluster_addresses_in_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser can handle scenarios where the address ranges of a standalone register and a\n    cluster within the same peripheral overlap. The test file defines a peripheral containing `RegisterA`, which\n    starts at address offset `0x0` with a size of 32 bits, and a cluster named `ClusterA`, starting at address\n    offset `0x2`. Inside `ClusterA`, there is a register named `RegisterB` that starts at address offset `0x2` and\n    has a size of 16 bits (`ClusterA` has therefore also a size of 16 bits). Although `svdconv` does not recognize\n    this overlap and processes the file without a warning or an error, a parser implementation should detect this\n    condition and issue a warning to the user, as overlapping address ranges can lead to ambiguity in register\n    mapping and potential issues during integration.\n\n    **Expected Outcome:** The parser should successfully process the SVD file while issuing a warning to inform the\n    user that `RegisterA` and `ClusterA` have overlapping address ranges. Specifically, `RegisterA` starts at\n    `0x0` with a size of 32 bits, and `ClusterA` starts at `0x2` with a size of 16 bits, which causes part of\n    `ClusterA` (including `RegisterB` at offset `0x2`) to overlap with the address range covered by `RegisterA`.\n    The peripheral should contain two top-level entities: `RegisterA`, with an address offset of `0x0` and a size\n    of 32 bits, and `ClusterA`, with an address offset of `0x2` and a size of 16 bits. Within `ClusterA`,\n    `RegisterB` should also have an address offset of `0x2` and a size of 16 bits, which contributes to the\n    address overlap. The parser should handle this situation by issuing a warning, allowing the file to be\n    processed while ensuring that users are informed of the potential conflict.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"logical_integrity/overlap_register_cluster_addresses_in_peripheral.svd\"\n        )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].size == 16\n\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 16\n</code></pre> SVD file: <code>logical_integrity/overlap_register_cluster_addresses_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;overlap_register_cluster_addresses_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n            &lt;size&gt;16&lt;/size&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_peripheral_sorting","title":"<code>test_peripheral_sorting</code>","text":"<p>This test verifies whether the parser correctly sorts the peripherals based on their base addresses, and if the base addresses match, then by their names. Unlike <code>svdconv</code>, which retains the peripherals in the exact order as they appear in the SVD file, a parser implementation should sort peripherals by their base address to provide a more predictable structure for users and tools consuming the output. When peripherals have the same base address, they should be sorted by their names alphabetically. This sorting approach aims to improve consistency and ease of navigation while acknowledging the differences from <code>svdconv</code>'s default behavior.</p> <p>Expected Outcome: The parser should process the SVD file and sort the peripherals by their base addresses in ascending order. If any peripherals share the same base address, they should be sorted further by their names. For this particular test file, the device should contain four peripherals, sorted as follows: <code>PeripheralA</code> with a base address of <code>0x40001000</code>, followed by <code>PeripheralB</code> with a base address of <code>0x40002000</code>, then <code>PeripheralC</code> with a base address of <code>0x40003000</code>, and finally <code>PeripheralD</code> with a base address of <code>0x40004000</code>. Each peripheral should retain its respective properties, and the sorted order should improve predictability compared to the original file order while maintaining consistency in naming conventions.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_peripheral_sorting(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies whether the parser correctly sorts the peripherals based on their base addresses, and if\n    the base addresses match, then by their names. Unlike `svdconv`, which retains the peripherals in the exact\n    order as they appear in the SVD file, a parser implementation should sort peripherals by their base address to\n    provide a more predictable structure for users and tools consuming the output. When peripherals have the same\n    base address, they should be sorted by their names alphabetically. This sorting approach aims to improve\n    consistency and ease of navigation while acknowledging the differences from `svdconv`'s default behavior.\n\n    **Expected Outcome:** The parser should process the SVD file and sort the peripherals by their base addresses in\n    ascending order. If any peripherals share the same base address, they should be sorted further by their names.\n    For this particular test file, the device should contain four peripherals, sorted as follows: `PeripheralA`\n    with a base address of `0x40001000`, followed by `PeripheralB` with a base address of `0x40002000`, then\n    `PeripheralC` with a base address of `0x40003000`, and finally `PeripheralD` with a base address of\n    `0x40004000`. Each peripheral should retain its respective properties, and the sorted order should improve\n    predictability compared to the original file order while maintaining consistency in naming conventions.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/peripheral_sorting.svd\")\n\n    assert len(device.peripherals) == 4\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40002000\n\n    assert device.peripherals[2].name == \"PeripheralC\"\n    assert device.peripherals[2].base_address == 0x40003000\n\n    assert device.peripherals[3].name == \"PeripheralD\"\n    assert device.peripherals[3].base_address == 0x40004000\n</code></pre> SVD file: <code>logical_integrity/peripheral_sorting.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;peripheral_sorting&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralD&lt;/name&gt;\n      &lt;baseAddress&gt;0x40004000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_peripheral_unaligned_address","title":"<code>test_peripheral_unaligned_address</code>","text":"<p>This test checks whether the parser can correctly handle peripherals that are not aligned to a 4-byte boundary. The test file defines <code>PeripheralA</code>, which has a base address of <code>0x40001007</code>, an address that is not aligned to a typical 4-byte boundary. In <code>svdconv</code>, such unaligned addresses generate a warning to alert the user about the misalignment while still allowing the file to be processed. A parser implementation should replicate this behavior\u2014processing the SVD file but issuing a warning to inform the user about the unaligned address.</p> <p>Expected Outcome: The parser should successfully process the SVD file, allowing the unaligned base address of <code>PeripheralA</code>, but it should issue a warning to inform the user that the peripheral base address is not 4-byte aligned. The device should contain one peripheral named <code>PeripheralA</code> with a base address of <code>0x40001007</code> and a size of 8 bits. The peripheral should include one register, <code>RegisterA</code>, which has an address offset of <code>0x0</code> and a size of 8 bits. The parser should maintain the integrity of the data while warning the user about the address misalignment, ensuring the user is aware of the potential impact of unaligned memory addresses.</p> <p>Processable with svdconv: yes - with warning</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_peripheral_unaligned_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly handle peripherals that are not aligned to a 4-byte\n    boundary. The test file defines `PeripheralA`, which has a base address of `0x40001007`, an address that is\n    not aligned to a typical 4-byte boundary. In `svdconv`, such unaligned addresses generate a warning to alert\n    the user about the misalignment while still allowing the file to be processed. A parser implementation should\n    replicate this behavior\u2014processing the SVD file but issuing a warning to inform the user about the unaligned\n    address.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, allowing the unaligned base address of\n    `PeripheralA`, but it should issue a warning to inform the user that the peripheral base address is not 4-byte\n    aligned. The device should contain one peripheral named `PeripheralA` with a base address of `0x40001007` and\n    a size of 8 bits. The peripheral should include one register, `RegisterA`, which has an address offset of\n    `0x0` and a size of 8 bits. The parser should maintain the integrity of the data while warning the user about\n    the address misalignment, ensuring the user is aware of the potential impact of unaligned memory addresses.\n\n    **Processable with svdconv:** yes - with warning\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/peripheral_unaligned_address.svd\")\n\n    assert len(device.peripherals) == 1\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001007\n    assert device.peripherals[0].size == 8\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 8\n</code></pre> SVD file: <code>logical_integrity/peripheral_unaligned_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;peripheral_unaligned_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001007&lt;/baseAddress&gt;\n      &lt;size&gt;8&lt;/size&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_peripherals_overlap_address","title":"<code>test_peripherals_overlap_address</code>","text":"<p>This test evaluates how the parser handles cases where two peripherals have overlapping address ranges, but neither is designated as an alternate peripheral. In this test file, <code>PeripheralA</code> starts at <code>0x40001000</code>, and <code>PeripheralB</code> starts at <code>0x40001500</code>, causing their memory address blocks to overlap. While <code>svdconv</code> processes such files, it generates a warning due to the overlap. A parser should mimic this behavior by allowing the file to be processed while issuing a warning to the user about the overlapping address spaces.</p> <p>Expected Outcome: The parser should process the file successfully but issue a warning to inform the user that <code>PeripheralA</code> and <code>PeripheralB</code> have overlapping address ranges. Specifically, <code>PeripheralA</code> occupies an address range starting at <code>0x40001000</code>, and <code>PeripheralB</code> starts at <code>0x40001500</code>, leading to an overlap. The device should contain two peripherals: <code>PeripheralA</code>, which starts at <code>0x40001000</code> and has one register, and <code>PeripheralB</code>, which starts at <code>0x40001500</code> and also has one register. The parser should handle the overlap by warning the user, ensuring that the file is processed correctly while making them aware of the potential conflict, similar to <code>svdconv</code> behavior.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_peripherals_overlap_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the parser handles cases where two peripherals have overlapping address ranges, but\n    neither is designated as an alternate peripheral. In this test file, `PeripheralA` starts at `0x40001000`, and\n    `PeripheralB` starts at `0x40001500`, causing their memory address blocks to overlap. While `svdconv`\n    processes such files, it generates a warning due to the overlap. A parser should mimic this behavior by\n    allowing the file to be processed while issuing a warning to the user about the overlapping address spaces.\n\n    **Expected Outcome:** The parser should process the file successfully but issue a warning to inform the user that\n    `PeripheralA` and `PeripheralB` have overlapping address ranges. Specifically, `PeripheralA` occupies an\n    address range starting at `0x40001000`, and `PeripheralB` starts at `0x40001500`, leading to an overlap. The\n    device should contain two peripherals: `PeripheralA`, which starts at `0x40001000` and has one register, and\n    `PeripheralB`, which starts at `0x40001500` and also has one register. The parser should handle the overlap by\n    warning the user, ensuring that the file is processed correctly while making them aware of the potential\n    conflict, similar to `svdconv` behavior.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/peripherals_overlap_address.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001500\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>logical_integrity/peripherals_overlap_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;peripherals_overlap_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001500&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_peripherals_same_address","title":"<code>test_peripherals_same_address</code>","text":"<p>This test evaluates whether the parser can handle the case where two peripherals are defined with the same base address without being marked as alternate peripherals. In this test file, <code>PeripheralA</code> and <code>PeripheralB</code> both have a base address of <code>0x40001000</code>, but unlike valid alternate peripheral setups, there is no indication that one peripheral is an alternate of the other. This scenario causes <code>svdconv</code> to raise an error, as peripherals sharing the same base address without an alternate relationship are not allowed. However, a more robust parser implementation should issue a warning and continue processing.</p> <p>Expected Outcome: The parser should process the file successfully while issuing a warning to notify the user that <code>PeripheralA</code> and <code>PeripheralB</code> share the same base address of <code>0x40001000</code> without being designated as alternate peripherals. The device should contain two peripherals: <code>PeripheralA</code> and <code>PeripheralB</code>, both with the same base address, and each should have one register. The parser should allow the file to be processed while alerting the user about the address conflict, handling the situation gracefully while still providing feedback on the potential issue, unlike <code>svdconv</code>, which raises an error in this case.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_peripherals_same_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates whether the parser can handle the case where two peripherals are defined with the same\n    base address without being marked as alternate peripherals. In this test file, `PeripheralA` and `PeripheralB`\n    both have a base address of `0x40001000`, but unlike valid alternate peripheral setups, there is no indication\n    that one peripheral is an alternate of the other. This scenario causes `svdconv` to raise an error, as\n    peripherals sharing the same base address without an alternate relationship are not allowed. However, a more\n    robust parser implementation should issue a warning and continue processing.\n\n    **Expected Outcome:** The parser should process the file successfully while issuing a warning to notify the user\n    that `PeripheralA` and `PeripheralB` share the same base address of `0x40001000` without being designated as\n    alternate peripherals. The device should contain two peripherals: `PeripheralA` and `PeripheralB`, both with\n    the same base address, and each should have one register. The parser should allow the file to be processed\n    while alerting the user about the address conflict, handling the situation gracefully while still providing\n    feedback on the potential issue, unlike `svdconv`, which raises an error in this case.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/peripherals_same_address.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001000\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>logical_integrity/peripherals_same_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;peripheral_same_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_peripherals_same_names","title":"<code>test_peripherals_same_names</code>","text":"<p>This test checks whether the parser can correctly identify and handle naming conflicts when two peripherals within the same device have identical names. The test file contains two peripherals, both named <code>PeripheralA</code>. In order to maintain logical integrity and ensure that each peripheral is uniquely identifiable, the parser must detect such conflicts and prevent ambiguous definitions. Similar to <code>svdconv</code>, the parser is expected to raise an error when it encounters peripherals with the same name, as this represents a violation of the naming rules.</p> <p>Expected Outcome: The parser should raise an error indicating that there is a peripheral naming conflict because both peripherals are named <code>PeripheralA</code>. This conflict results in ambiguity, which prevents the unique identification of peripherals within the device. As a result, the parser must stop processing the SVD file and provide an appropriate error message to inform the user of the issue. This behavior is consistent with <code>svdconv</code>, which also raises an error for such cases to maintain consistency and avoid incorrect memory mappings or register configurations.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Peripheral naming conflict\",\n)\ndef test_peripherals_same_names(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly identify and handle naming conflicts when two peripherals\n    within the same device have identical names. The test file contains two peripherals, both named `PeripheralA`.\n    In order to maintain logical integrity and ensure that each peripheral is uniquely identifiable, the parser\n    must detect such conflicts and prevent ambiguous definitions. Similar to `svdconv`, the parser is expected to\n    raise an error when it encounters peripherals with the same name, as this represents a violation of the naming\n    rules.\n\n    **Expected Outcome:** The parser should raise an error indicating that there is a peripheral naming conflict\n    because both peripherals are named `PeripheralA`. This conflict results in ambiguity, which prevents the\n    unique identification of peripherals within the device. As a result, the parser must stop processing the SVD\n    file and provide an appropriate error message to inform the user of the issue. This behavior is consistent\n    with `svdconv`, which also raises an error for such cases to maintain consistency and avoid incorrect memory\n    mappings or register configurations.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/peripherals_same_names.svd\")\n</code></pre> SVD file: <code>logical_integrity/peripherals_same_names.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;peripherals_same_names&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_alternate_group","title":"<code>test_register_alternate_group</code>","text":"<p>This test evaluates whether the parser can correctly process registers that share the same address but belong to different alternate groups. In this test file, <code>RegisterA</code> is defined at address offset <code>0x0</code> without any alternate group, while a second <code>RegisterA</code> and <code>RegisterB</code>, both at the same address, are part of the alternate group <code>RegisterX</code>. <code>svdconv</code> processes this file without any issues, and the parser should be able to handle the alternate group associations properly.</p> <p>Expected Outcome: The parser should process the file correctly, identifying the alternate group relationships for the registers. <code>RegisterA</code> should be defined at address offset <code>0x0</code> with a size of 32 bits and no alternate group. The second <code>RegisterA</code>, also at the same address, should be part of the alternate group <code>RegisterX</code> and should be named <code>RegisterA_RegisterX</code>. Similarly, <code>RegisterB</code> should be at the same address with the name <code>RegisterB_RegisterX</code> and should also belong to the alternate group <code>RegisterX</code>. The parser should handle this configuration smoothly, without any errors or warnings, consistent with how <code>svdconv</code> processes this case.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_alternate_group(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates whether the parser can correctly process registers that share the same address but belong\n    to different alternate groups. In this test file, `RegisterA` is defined at address offset `0x0` without any\n    alternate group, while a second `RegisterA` and `RegisterB`, both at the same address, are part of the\n    alternate group `RegisterX`. `svdconv` processes this file without any issues, and the parser should be able\n    to handle the alternate group associations properly.\n\n    **Expected Outcome:** The parser should process the file correctly, identifying the alternate group relationships\n    for the registers. `RegisterA` should be defined at address offset `0x0` with a size of 32 bits and no\n    alternate group. The second `RegisterA`, also at the same address, should be part of the alternate group\n    `RegisterX` and should be named `RegisterA_RegisterX`. Similarly, `RegisterB` should be at the same address\n    with the name `RegisterB_RegisterX` and should also belong to the alternate group `RegisterX`. The parser\n    should handle this configuration smoothly, without any errors or warnings, consistent with how `svdconv`\n    processes this case.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/register_alternate_group.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_group is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_group == \"RegisterX\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Register)\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[2].size == 32\n    assert device.peripherals[0].registers_clusters[2].alternate_group == \"RegisterX\"\n</code></pre> SVD file: <code>logical_integrity/register_alternate_group.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_alternate_group&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_alternate_group_forward_reference","title":"<code>test_register_alternate_group_forward_reference</code>","text":"<p>This test ensures that the parser can correctly handle forward references when defining alternate register groups. In this test file, <code>RegisterA</code> is defined later in the SVD file, but other registers like <code>RegisterA_RegisterX</code> and <code>RegisterB_RegisterX</code> are part of the alternate group <code>RegisterX</code>, referencing <code>RegisterA</code>. A parser should be able to resolve these forward references without any issues.</p> <p>Expected Outcome: The parser should process the file correctly, resolving the forward reference for the alternate register group. It should recognize that <code>RegisterA_RegisterX</code> and <code>RegisterB_RegisterX</code> both belong to the alternate group <code>RegisterX</code>, while <code>RegisterA</code>, defined later in the file, is the base register with no alternate group. All registers should have the same address offset of <code>0x0</code> and a size of 32 bits. The parser should process this setup without errors, ensuring that the alternate group relationships and forward references are handled as expected.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_alternate_group_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser can correctly handle forward references when defining alternate register\n    groups. In this test file, `RegisterA` is defined later in the SVD file, but other registers like\n    `RegisterA_RegisterX` and `RegisterB_RegisterX` are part of the alternate group `RegisterX`, referencing\n    `RegisterA`. A parser should be able to resolve these forward references without any issues.\n\n    **Expected Outcome:** The parser should process the file correctly, resolving the forward reference for the\n    alternate register group. It should recognize that `RegisterA_RegisterX` and `RegisterB_RegisterX` both belong\n    to the alternate group `RegisterX`, while `RegisterA`, defined later in the file, is the base register with no\n    alternate group. All registers should have the same address offset of `0x0` and a size of 32 bits. The parser\n    should process this setup without errors, ensuring that the alternate group relationships and forward\n    references are handled as expected.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/register_alternate_group_forward_reference.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_group is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_group == \"RegisterX\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Register)\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[2].size == 32\n    assert device.peripherals[0].registers_clusters[2].alternate_group == \"RegisterX\"\n</code></pre> SVD file: <code>logical_integrity/register_alternate_group_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_alternate_group_forward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_alternate_group_overlap","title":"<code>test_register_alternate_group_overlap</code>","text":"<p>This test checks whether the parser correctly handles registers that belong to the same alternate group but have overlapping addresses. In this test file, <code>RegisterA</code> is defined at address offset <code>0x0</code> with no alternate group. <code>RegisterA_RegisterX</code> and <code>RegisterB_RegisterX</code> are both part of the alternate group <code>RegisterX</code>, but they overlap in memory. <code>svdconv</code> processes this file without issues, and the parser should also handle these overlapping alternate group registers correctly.</p> <p>Expected Outcome: The parser should process the SVD file without errors, recognizing that <code>RegisterA_RegisterX</code> and <code>RegisterB_RegisterX</code> belong to the same alternate group despite overlapping addresses. The device should contain one peripheral with three registers: <code>RegisterA</code> at address offset <code>0x0</code> with a size of 32 bits and no alternate group, <code>RegisterA_RegisterX</code> at the same address with a size of 16 bits, and <code>RegisterB_RegisterX</code> at the same address with a size of 32 bits, both belonging to <code>RegisterX</code>. The parser should handle this alternate group overlap without errors or warnings, consistent with <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_alternate_group_overlap(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser correctly handles registers that belong to the same alternate group but\n    have overlapping addresses. In this test file, `RegisterA` is defined at address offset `0x0` with no\n    alternate group. `RegisterA_RegisterX` and `RegisterB_RegisterX` are both part of the alternate group\n    `RegisterX`, but they overlap in memory. `svdconv` processes this file without issues, and the parser should\n    also handle these overlapping alternate group registers correctly.\n\n    **Expected Outcome:** The parser should process the SVD file without errors, recognizing that\n    `RegisterA_RegisterX` and `RegisterB_RegisterX` belong to the same alternate group despite overlapping\n    addresses. The device should contain one peripheral with three registers: `RegisterA` at address offset `0x0`\n    with a size of 32 bits and no alternate group, `RegisterA_RegisterX` at the same address with a size of 16\n    bits, and `RegisterB_RegisterX` at the same address with a size of 32 bits, both belonging to `RegisterX`. The\n    parser should handle this alternate group overlap without errors or warnings, consistent with `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/register_alternate_group_overlap.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert device.peripherals[0].registers_clusters[0].alternate_group is None\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert device.peripherals[0].registers_clusters[1].alternate_group == \"RegisterX\"\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Register)\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[2].size == 16\n    assert device.peripherals[0].registers_clusters[2].alternate_group == \"RegisterX\"\n</code></pre> SVD file: <code>logical_integrity/register_alternate_group_overlap.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_alternate_group_overlap&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_alternate_group_same_name","title":"<code>test_register_alternate_group_same_name</code>","text":"<p>This test verifies how the parser handles a situation where two registers in the same alternate group are given the same name. In this test file, <code>RegisterA_RegisterX</code> is defined twice within the alternate group <code>RegisterX</code>, which causes a naming conflict. While <code>svdconv</code> processes this file, it issues a warning indicating that <code>RegisterA_RegisterX</code> is already defined. The parser should similarly detect this conflict and raise an error due to the duplicate register name within the alternate group.</p> <p>Expected Outcome: The parser should raise an error, indicating that two registers in the same alternate group cannot have the same name. The file should fail to process because <code>RegisterA_RegisterX</code> is defined twice, leading to a naming conflict within <code>RegisterX</code>. The parser should halt further processing and notify the user about the issue, ensuring that register names within the same alternate group are unique, consistent with the warning behavior seen in <code>svdconv</code>.</p> <p>Processable with svdconv: no - warning (RegisterA_RegisterX already defined)</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Register in alternate group has same name as other register in same alternate group\",\n)\ndef test_register_alternate_group_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies how the parser handles a situation where two registers in the same alternate group are\n    given the same name. In this test file, `RegisterA_RegisterX` is defined twice within the alternate group\n    `RegisterX`, which causes a naming conflict. While `svdconv` processes this file, it issues a warning\n    indicating that `RegisterA_RegisterX` is already defined. The parser should similarly detect this conflict and\n    raise an error due to the duplicate register name within the alternate group.\n\n    **Expected Outcome:** The parser should raise an error, indicating that two registers in the same alternate group\n    cannot have the same name. The file should fail to process because `RegisterA_RegisterX` is defined twice,\n    leading to a naming conflict within `RegisterX`. The parser should halt further processing and notify the user\n    about the issue, ensuring that register names within the same alternate group are unique, consistent with the\n    warning behavior seen in `svdconv`.\n\n    **Processable with svdconv:** no - warning (RegisterA_RegisterX already defined)\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/register_alternate_group_same_name.svd\")\n</code></pre> SVD file: <code>logical_integrity/register_alternate_group_same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_alternate_group_same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_and_cluster_register_same_names_in_peripheral","title":"<code>test_register_and_cluster_register_same_names_in_peripheral</code>","text":"<p>This test verifies whether the parser correctly handles situations where a register and a cluster within the same peripheral share the same register name. The test file contains a peripheral with a standalone register named <code>RegisterA</code> and a cluster named <code>ClusterA</code>. The cluster <code>ClusterA</code> itself contains a register also named <code>RegisterA</code>. This scenario tests whether the parser can distinguish between registers in different contexts\u2014i.e., one as a standalone register and the other as part of a cluster\u2014without causing naming conflicts.</p> <p>Expected Outcome: The parser should successfully process the SVD file without errors, correctly identifying the register and cluster, even though both contexts contain a register with the same name, <code>RegisterA</code>. The peripheral should contain two top-level entities: the first is a standalone register named <code>RegisterA</code> with an address offset of <code>0x0</code> and a size of 32 bits. The second is a cluster named <code>ClusterA</code> with an address offset of <code>0x4</code> and a size of 32 bits. The cluster <code>ClusterA</code> contains one register named <code>RegisterA</code> with an address offset of <code>0x0</code> and a size of 32 bits. The parser should properly handle the context in which each register is defined\u2014differentiating the standalone register from the register within the cluster\u2014and process the file without raising any naming conflict errors.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_and_cluster_register_same_names_in_peripheral(\n    get_processed_device_from_testfile: Callable[[str], Device],\n):\n    \"\"\"\n    This test verifies whether the parser correctly handles situations where a register and a cluster within the\n    same peripheral share the same register name. The test file contains a peripheral with a standalone register\n    named `RegisterA` and a cluster named `ClusterA`. The cluster `ClusterA` itself contains a register also named\n    `RegisterA`. This scenario tests whether the parser can distinguish between registers in different\n    contexts\u2014i.e., one as a standalone register and the other as part of a cluster\u2014without causing naming\n    conflicts.\n\n    **Expected Outcome:** The parser should successfully process the SVD file without errors, correctly identifying\n    the register and cluster, even though both contexts contain a register with the same name, `RegisterA`. The\n    peripheral should contain two top-level entities: the first is a standalone register named `RegisterA` with an\n    address offset of `0x0` and a size of 32 bits. The second is a cluster named `ClusterA` with an address offset\n    of `0x4` and a size of 32 bits. The cluster `ClusterA` contains one register named `RegisterA` with an address\n    offset of `0x0` and a size of 32 bits. The parser should properly handle the context in which each register is\n    defined\u2014differentiating the standalone register from the register within the cluster\u2014and process the file\n    without raising any naming conflict errors.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"logical_integrity/register_and_cluster_register_same_names_in_peripheral.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>logical_integrity/register_and_cluster_register_same_names_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_and_cluster_register_same_names_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;Cluster A&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_and_cluster_same_names_in_peripheral","title":"<code>test_register_and_cluster_same_names_in_peripheral</code>","text":"<p>This test checks if the parser can correctly identify and handle naming conflicts when a register and a cluster within the same peripheral share the same name. The test file defines a peripheral that contains both a standalone register and a cluster, both named <code>RegisterA</code>. Since identifiers on the same hierarchical level must have unique identifiers within the same peripheral to avoid ambiguity, the expected behavior is for the parser to detect this naming conflict and raise an appropriate error, similar to the behavior of <code>svdconv</code>.</p> <p>Expected Outcome: The parser should raise an error indicating a naming conflict between the register and the cluster, both named <code>RegisterA</code> within the same peripheral. This conflict makes it impossible to uniquely identify the register and cluster entities. The parser should fail processing the file and notify the user of the conflict, ensuring that each element within a peripheral has a distinct and unique name, consistent with the requirements for logical integrity.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Register and cluster naming conflict\",\n)\ndef test_register_and_cluster_same_names_in_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks if the parser can correctly identify and handle naming conflicts when a register and a\n    cluster within the same peripheral share the same name. The test file defines a peripheral that contains both\n    a standalone register and a cluster, both named `RegisterA`. Since identifiers on the same hierarchical level\n    must have unique identifiers within the same peripheral to avoid ambiguity, the expected behavior is for the\n    parser to detect this naming conflict and raise an appropriate error, similar to the behavior of `svdconv`.\n\n    **Expected Outcome:** The parser should raise an error indicating a naming conflict between the register and the\n    cluster, both named `RegisterA` within the same peripheral. This conflict makes it impossible to uniquely\n    identify the register and cluster entities. The parser should fail processing the file and notify the user of\n    the conflict, ensuring that each element within a peripheral has a distinct and unique name, consistent with\n    the requirements for logical integrity.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/register_and_cluster_same_names_in_peripheral.svd\")\n</code></pre> SVD file: <code>logical_integrity/register_and_cluster_same_names_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_and_cluster_same_names_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;description&gt;Cluster A&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_and_nested_cluster_same_names_in_peripheral","title":"<code>test_register_and_nested_cluster_same_names_in_peripheral</code>","text":"<p>This test evaluates whether the parser can correctly handle situations where a standalone register and a nested cluster within the same peripheral share the same name. The test file defines a peripheral that contains a standalone register named <code>RegisterA</code> and a cluster named <code>ClusterA</code>. Within <code>ClusterA</code>, there is a nested cluster also named <code>RegisterA</code>, which itself contains a register with the same name, <code>RegisterA</code>. This test is intended to verify that the parser can differentiate between entities in different hierarchical levels despite having the same name.</p> <p>Expected Outcome: The parser should successfully process the SVD file, correctly identifying the relationships and hierarchies of the elements within the peripheral, even when a register and a nested cluster share the same name. The peripheral should contain two top-level entities: the first is a standalone register named <code>RegisterA</code> with an address offset of <code>0x0</code> and a size of 32 bits, and the second is a cluster named <code>ClusterA</code> with an address offset of <code>0x4</code> and a size of 32 bits. Inside <code>ClusterA</code>, there is a nested cluster also named <code>RegisterA</code>, which has an address offset of <code>0x0</code> and a size of 32 bits. This nested cluster contains a register, also named <code>RegisterA</code>, with an address offset of <code>0x0</code> and a size of 32 bits. The parser should accurately distinguish between the standalone register and the registers and clusters within the nested structure, processing the file without any naming conflicts or errors.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_and_nested_cluster_same_names_in_peripheral(\n    get_processed_device_from_testfile: Callable[[str], Device],\n):\n    \"\"\"\n    This test evaluates whether the parser can correctly handle situations where a standalone register and a\n    nested cluster within the same peripheral share the same name. The test file defines a peripheral that\n    contains a standalone register named `RegisterA` and a cluster named `ClusterA`. Within `ClusterA`, there is a\n    nested cluster also named `RegisterA`, which itself contains a register with the same name, `RegisterA`. This\n    test is intended to verify that the parser can differentiate between entities in different hierarchical levels\n    despite having the same name.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, correctly identifying the relationships\n    and hierarchies of the elements within the peripheral, even when a register and a nested cluster share the\n    same name. The peripheral should contain two top-level entities: the first is a standalone register named\n    `RegisterA` with an address offset of `0x0` and a size of 32 bits, and the second is a cluster named\n    `ClusterA` with an address offset of `0x4` and a size of 32 bits. Inside `ClusterA`, there is a nested cluster\n    also named `RegisterA`, which has an address offset of `0x0` and a size of 32 bits. This nested cluster\n    contains a register, also named `RegisterA`, with an address offset of `0x0` and a size of 32 bits. The parser\n    should accurately distinguish between the standalone register and the registers and clusters within the nested\n    structure, processing the file without any naming conflicts or errors.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"logical_integrity/register_and_nested_cluster_same_names_in_peripheral.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Cluster)\n    assert device.peripherals[0].registers_clusters[1].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[1].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].registers_clusters[0].size == 32\n\n    assert len(device.peripherals[0].registers_clusters[1].registers_clusters[0].registers_clusters) == 1\n    nested_rega = device.peripherals[0].registers_clusters[1].registers_clusters[0].registers_clusters[0]\n\n    assert isinstance(nested_rega, Register)\n    assert nested_rega.name == \"RegisterA\"\n    assert nested_rega.address_offset == 0x0\n    assert nested_rega.size == 32\n</code></pre> SVD file: <code>logical_integrity/register_and_nested_cluster_same_names_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_and_nested_cluster_same_names_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;Cluster A&lt;/description&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;cluster&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;description&gt;Cluster B&lt;/description&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;register&gt;\n              &lt;name&gt;RegisterA&lt;/name&gt;\n              &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;/register&gt;\n          &lt;/cluster&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_cluster_sorting_in_peripheral","title":"<code>test_register_cluster_sorting_in_peripheral</code>","text":"<p>This test checks whether the parser correctly sorts registers and clusters within a peripheral based on their address offsets, with registers and clusters sorted first by their offsets and then by their names if they share the same address. In <code>svdconv</code>, the registers and clusters are processed and retained in the order in which they are defined in the SVD file. However, a parser should sort registers and clusters by address offset for better organization and consistency. If registers or clusters have the same address, they should further be sorted by their names alphabetically to ensure predictable behavior and avoid ambiguity.</p> <p>Expected Outcome: The parser should process the SVD file and sort the registers and clusters within the peripheral by their address offsets. The peripheral should contain two entities in the sorted order: <code>ClusterA</code> should appear first with an address offset of <code>0x0</code>, followed by <code>RegisterA</code> with an address offset of <code>0x8</code>. Inside <code>ClusterA</code>, the contained registers should also be sorted by address offset, starting with <code>RegisterA</code> at offset <code>0x0</code> and then <code>RegisterB</code> at offset <code>0x4</code>. The parser should reflect this sorting order accurately, maintaining each register and cluster's respective properties while ensuring a consistent and predictable output.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_cluster_sorting_in_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser correctly sorts registers and clusters within a peripheral based on their\n    address offsets, with registers and clusters sorted first by their offsets and then by their names if they\n    share the same address. In `svdconv`, the registers and clusters are processed and retained in the order in\n    which they are defined in the SVD file. However, a parser should sort registers and clusters by address offset\n    for better organization and consistency. If registers or clusters have the same address, they should further\n    be sorted by their names alphabetically to ensure predictable behavior and avoid ambiguity.\n\n    **Expected Outcome:** The parser should process the SVD file and sort the registers and clusters within the\n    peripheral by their address offsets. The peripheral should contain two entities in the sorted order:\n    `ClusterA` should appear first with an address offset of `0x0`, followed by `RegisterA` with an address offset\n    of `0x8`. Inside `ClusterA`, the contained registers should also be sorted by address offset, starting with\n    `RegisterA` at offset `0x0` and then `RegisterB` at offset `0x4`. The parser should reflect this sorting order\n    accurately, maintaining each register and cluster's respective properties while ensuring a consistent and\n    predictable output.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"logical_integrity/register_cluster_sorting_in_peripheral.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[1].size == 32\n\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>logical_integrity/register_cluster_sorting_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_cluster_sorting_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;Cluster A&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_size_bit_width","title":"<code>test_register_size_bit_width</code>","text":"<p>This test checks whether the parser can correctly handle registers with an unsupported bit width. The test file defines <code>RegisterA</code> with a size of 23 bits, which is not a standard register size (valid sizes are typically 8, 16, 32, or 64 bits). In <code>svdconv</code>, this scenario generates a warning, indicating that the register size is non-standard but the file is still processable. A parser implementation should mimic this behavior, allowing the file to be processed while issuing a warning to alert the user of the non-standard register size.</p> <p>Expected Outcome: The parser should successfully process the SVD file, but it should issue a warning to notify the user that the size of <code>RegisterA</code> is non-standard and must be 8, 16, 32, or 64 bits. The device should contain one peripheral, <code>PeripheralA</code>, with a base address of <code>0x40001000</code>, and it should include a register, <code>RegisterA</code>, with an address offset of <code>0x0</code> and a size of 23 bits. The parser should allow the file to be processed while warning the user about the unusual bit width of the register, maintaining consistency with how <code>svdconv</code> handles this situation.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_register_size_bit_width(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly handle registers with an unsupported bit width. The test\n    file defines `RegisterA` with a size of 23 bits, which is not a standard register size (valid sizes are\n    typically 8, 16, 32, or 64 bits). In `svdconv`, this scenario generates a warning, indicating that the\n    register size is non-standard but the file is still processable. A parser implementation should mimic this\n    behavior, allowing the file to be processed while issuing a warning to alert the user of the non-standard\n    register size.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, but it should issue a warning to notify\n    the user that the size of `RegisterA` is non-standard and must be 8, 16, 32, or 64 bits. The device should\n    contain one peripheral, `PeripheralA`, with a base address of `0x40001000`, and it should include a register,\n    `RegisterA`, with an address offset of `0x0` and a size of 23 bits. The parser should allow the file to be\n    processed while warning the user about the unusual bit width of the register, maintaining consistency with how\n    `svdconv` handles this situation.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/register_size_bit_width.svd\")\n\n    assert len(device.peripherals) == 1\n    assert device.peripherals[0].name == \"PeripheralB\"\n    assert device.peripherals[0].base_address == 0x40002000\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>logical_integrity/register_size_bit_width.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_size_bit_width&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;23&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;32&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_register_unaligned_address","title":"<code>test_register_unaligned_address</code>","text":"<p>This test checks whether the parser can detect and correctly handle registers that are defined with an unaligned address offset. The test file defines <code>RegisterA</code>, with a size of 16 bit and an address offset of <code>0x00000003</code>, making it unaligned in memory. If the register's size would be 8 bit, the register would be aligned.</p> <p>Expected Outcome: The parser should raise a warning indicating that <code>RegisterA</code> is unaligned.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_register_unaligned_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can detect and correctly handle registers that are defined with an\n    unaligned address offset. The test file defines `RegisterA`, with a size of 16 bit and an address offset of\n    `0x00000003`, making it unaligned in memory. If the register's size would be 8 bit, the register would be\n    aligned.\n\n    **Expected Outcome:** The parser should raise a warning indicating that `RegisterA` is unaligned.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/register_unaligned_address.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x3\n    assert device.peripherals[0].registers_clusters[0].size == 16\n</code></pre> SVD file: <code>logical_integrity/register_unaligned_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_unaligned_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x3&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_same_register_addresses_in_peripheral","title":"<code>test_same_register_addresses_in_peripheral</code>","text":"<p>This test checks whether the parser can correctly handle the situation where two registers within the same peripheral are assigned the same address offset. The test file defines a peripheral containing two registers, <code>RegisterA</code> and <code>RegisterB</code>, both with an address offset of <code>0x0</code>. Typically, each register within a peripheral should have a unique address to ensure proper memory mapping, and <code>svdconv</code> raises an error when two registers share the same address. However, for compatibility with older versions of <code>svdconv</code>, a warning may be issued instead of an error in certain situations (e.g., when using <code>dim</code>). For a parser designed to work with both new and old SVD files, it is recommended to allow registers with the same addresses but issue a warning to the user.</p> <p>Expected Outcome: The parser should process the file successfully but should issue a warning (<code>ProcessWarning</code>) indicating that <code>RegisterA</code> and <code>RegisterB</code> have the same address offset of <code>0x0</code>. The peripheral should contain two registers, both of which are correctly parsed despite the address overlap. The first register, <code>RegisterA</code>, should have an address offset of <code>0x0</code> and a size of 32 bits, while the second register, <code>RegisterB</code>, should also have an address offset of <code>0x0</code> and a size of 32 bits. The parser should handle this scenario by allowing the registers with the same addresses but warning the user about the conflict to maintain compatibility and awareness of potential issues.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_same_register_addresses_in_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser can correctly handle the situation where two registers within the same\n    peripheral are assigned the same address offset. The test file defines a peripheral containing two registers,\n    `RegisterA` and `RegisterB`, both with an address offset of `0x0`. Typically, each register within a\n    peripheral should have a unique address to ensure proper memory mapping, and `svdconv` raises an error when\n    two registers share the same address. However, for compatibility with older versions of `svdconv`, a warning\n    may be issued instead of an error in [certain situations](https://github.com/Open-CMSIS-\n    Pack/devtools/blob/44643999691347946562c526fc0474194f865c74/tools/svdconv/SVDModel/src/SvdPeripheral.cpp#L721)\n    (e.g., when using `dim`). For a parser designed to work with both new and old SVD files, it is recommended to\n    allow registers with the same addresses but issue a warning to the user.\n\n    **Expected Outcome:** The parser should process the file successfully but should issue a warning\n    (`ProcessWarning`) indicating that `RegisterA` and `RegisterB` have the same address offset of `0x0`. The\n    peripheral should contain two registers, both of which are correctly parsed despite the address overlap. The\n    first register, `RegisterA`, should have an address offset of `0x0` and a size of 32 bits, while the second\n    register, `RegisterB`, should also have an address offset of `0x0` and a size of 32 bits. The parser should\n    handle this scenario by allowing the registers with the same addresses but warning the user about the conflict\n    to maintain compatibility and awareness of potential issues.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"logical_integrity/same_register_addresses_in_peripheral.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n</code></pre> SVD file: <code>logical_integrity/same_register_addresses_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;same_register_addresses_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_same_register_cluster_addresses_in_peripheral","title":"<code>test_same_register_cluster_addresses_in_peripheral</code>","text":"<p>This test evaluates how the parser handles cases where a standalone register and a cluster within the same peripheral share the same address offset, and further, whether the addresses within the cluster itself overlap with the standalone register. The test file defines a peripheral with a standalone register <code>RegisterA</code> at address offset <code>0x0</code> and a cluster named <code>ClusterA</code>, also starting at offset <code>0x0</code>. Within <code>ClusterA</code>, there is a register named <code>RegisterB</code> with an address offset of <code>0x0</code>. The tool <code>svdconv</code> processes this without issuing a warning or error and does not recognize that <code>RegisterA</code> and <code>ClusterA</code> effectively overlap, leading to <code>RegisterA</code> and <code>RegisterB</code> having the same absolute address. For clarity and consistency, a parser implementation should warn the user about this address conflict.</p> <p>Expected Outcome: The parser should process the file successfully but issue a warning to inform the user that <code>RegisterA</code> and <code>ClusterA</code> overlap at address offset <code>0x0</code>, and as a result, <code>RegisterB</code> within <code>ClusterA</code> ends up sharing the same absolute address as <code>RegisterA</code>. The peripheral should contain two top-level entities: <code>RegisterA</code> with an address offset of <code>0x0</code> and a size of 32 bits, and <code>ClusterA</code> also with an address offset of <code>0x0</code> and a size of 32 bits. Inside <code>ClusterA</code>, <code>RegisterB</code> should be located at an address offset of <code>0x0</code>, effectively overlapping with <code>RegisterA</code> at the peripheral level. The parser should warn the user about these overlapping absolute addresses to ensure that such potential conflicts are clearly communicated, despite being allowed during processing for compatibility reasons.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>def test_same_register_cluster_addresses_in_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the parser handles cases where a standalone register and a cluster within the same\n    peripheral share the same address offset, and further, whether the addresses within the cluster itself overlap\n    with the standalone register. The test file defines a peripheral with a standalone register `RegisterA` at\n    address offset `0x0` and a cluster named `ClusterA`, also starting at offset `0x0`. Within `ClusterA`, there\n    is a register named `RegisterB` with an address offset of `0x0`. The tool `svdconv` processes this without\n    issuing a warning or error and does not recognize that `RegisterA` and `ClusterA` effectively overlap, leading\n    to `RegisterA` and `RegisterB` having the same absolute address. For clarity and consistency, a parser\n    implementation should warn the user about this address conflict.\n\n    **Expected Outcome:** The parser should process the file successfully but issue a warning to inform the user that\n    `RegisterA` and `ClusterA` overlap at address offset `0x0`, and as a result, `RegisterB` within `ClusterA`\n    ends up sharing the same absolute address as `RegisterA`. The peripheral should contain two top-level\n    entities: `RegisterA` with an address offset of `0x0` and a size of 32 bits, and `ClusterA` also with an\n    address offset of `0x0` and a size of 32 bits. Inside `ClusterA`, `RegisterB` should be located at an address\n    offset of `0x0`, effectively overlapping with `RegisterA` at the peripheral level. The parser should warn the\n    user about these overlapping absolute addresses to ensure that such potential conflicts are clearly\n    communicated, despite being allowed during processing for compatibility reasons.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"logical_integrity/same_register_cluster_addresses_in_peripheral.svd\"\n        )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Cluster)\n    assert device.peripherals[0].registers_clusters[0].name == \"ClusterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n\n    assert len(device.peripherals[0].registers_clusters[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>logical_integrity/same_register_cluster_addresses_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;same_register_cluster_addresses_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_logical_integrity.html#tests.test_process.test_logical_integrity.test_same_register_names_in_peripheral","title":"<code>test_same_register_names_in_peripheral</code>","text":"<p>This test checks whether the parser correctly identifies and handles naming conflicts when multiple registers within the same peripheral share the same name. The test file contains a single peripheral with two registers, both named <code>RegisterA</code>. This scenario is expected to create a conflict, as registers within the same peripheral should have unique names to avoid ambiguity. The behavior of the parser should align with <code>svdconv</code>, which raises an error in the case of identical register names.</p> <p>Expected Outcome: The parser should raise an error indicating a register naming conflict when it encounters two registers within the same peripheral sharing the name <code>RegisterA</code>. This error ensures that each register is uniquely identifiable, preventing ambiguity in the peripheral's register definition. The parser should halt processing for this file and notify the user about the conflict, mirroring <code>svdconv</code> behavior, which also does not allow registers with the same name in the same peripheral.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_logical_integrity.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Register naming conflict\",\n)\ndef test_same_register_names_in_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser correctly identifies and handles naming conflicts when multiple registers\n    within the same peripheral share the same name. The test file contains a single peripheral with two registers,\n    both named `RegisterA`. This scenario is expected to create a conflict, as registers within the same\n    peripheral should have unique names to avoid ambiguity. The behavior of the parser should align with\n    `svdconv`, which raises an error in the case of identical register names.\n\n    **Expected Outcome:** The parser should raise an error indicating a register naming conflict when it encounters\n    two registers within the same peripheral sharing the name `RegisterA`. This error ensures that each register\n    is uniquely identifiable, preventing ambiguity in the peripheral's register definition. The parser should halt\n    processing for this file and notify the user about the conflict, mirroring `svdconv` behavior, which also does\n    not allow registers with the same name in the same peripheral.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"logical_integrity/same_register_names_in_peripheral.svd\")\n</code></pre> SVD file: <code>logical_integrity/same_register_names_in_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;same_register_names_in_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html","title":"test_peripheral_inheritance_via_derived_from","text":"<p>For this feature, test cases cover scenarios where a derived peripheral inherits properties from a base peripheral, ensuring correct behavior when values are inherited.</p>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_alternate_peripheral","title":"<code>test_alternate_peripheral</code>","text":"<p>By default, each address block in the memory space of a device is assigned to a unique peripheral. If multiple peripherals share the same address block, this must be explicitly defined. A peripheral that redefines an address block must specify the name of the peripheral originally associated with that block in <code>alternatePeripheral</code>. This test checks whether a derived peripheral with the same address as the base peripheral is accepted by the parser without triggering an error.</p> <p>Expected Outcome: The parser should process the file without raising an error, recognizing that <code>PeripheralB</code> shares the same base address as <code>PeripheralA</code> and correctly defines <code>PeripheralA</code> as its alternate peripheral. Both peripherals should be parsed correctly, with <code>PeripheralA</code> listed first and having a base address of <code>0x40001000</code>. <code>PeripheralB</code> should also have the same base address of <code>0x40001000</code>, with the alternate peripheral attribute correctly set to <code>PeripheralA</code>. The parser should handle this situation as expected, accepting the shared address as valid due to the explicit alternate peripheral specification.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_peripheral(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    By default, each address block in the memory space of a device is assigned to a unique peripheral. If multiple\n    peripherals share the same address block, this must be explicitly defined. A peripheral that redefines an\n    address block must specify the name of the peripheral originally associated with that block in\n    `alternatePeripheral`. This test checks whether a derived peripheral with the same address as the base\n    peripheral is accepted by the parser without triggering an error.\n\n    **Expected Outcome:** The parser should process the file without raising an error, recognizing that `PeripheralB`\n    shares the same base address as `PeripheralA` and correctly defines `PeripheralA` as its alternate peripheral.\n    Both peripherals should be parsed correctly, with `PeripheralA` listed first and having a base address of\n    `0x40001000`. `PeripheralB` should also have the same base address of `0x40001000`, with the alternate\n    peripheral attribute correctly set to `PeripheralA`. The parser should handle this situation as expected,\n    accepting the shared address as valid due to the explicit alternate peripheral specification.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/alternate_peripheral.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001000\n    assert device.peripherals[1].alternate_peripheral == \"PeripheralA\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/alternate_peripheral.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_peripheral&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_alternate_peripheral_overlap","title":"<code>test_alternate_peripheral_overlap</code>","text":"<p>By default, each address block in the memory space of a device is assigned to a unique peripheral. If multiple peripherals share the same address block, this must be explicitly defined. A peripheral that redefines an address block must specify the name of the peripheral originally associated with that block in <code>alternatePeripheral</code>. This test checks whether a derived peripheral with an overlapping address block to the base peripheral is accepted by the parser without triggering an error.</p> <p>Expected Outcome: The parser should process the file without raising an error, recognizing that <code>PeripheralB</code> shares an overlapping address block with <code>PeripheralA</code> and correctly defines <code>PeripheralA</code> as its alternate peripheral. Both peripherals should be parsed correctly, with <code>PeripheralA</code> listed first and having a base address of <code>0x40001000</code>. <code>PeripheralB</code> should have the base address of <code>0x40001004</code>, with the alternate peripheral attribute correctly set to <code>PeripheralA</code>. The parser should handle this situation as expected, accepting the shared space as valid due to the explicit alternate peripheral specification.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_alternate_peripheral_overlap(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    By default, each address block in the memory space of a device is assigned to a unique peripheral. If multiple\n    peripherals share the same address block, this must be explicitly defined. A peripheral that redefines an\n    address block must specify the name of the peripheral originally associated with that block in\n    `alternatePeripheral`. This test checks whether a derived peripheral with an overlapping address block to the\n    base peripheral is accepted by the parser without triggering an error.\n\n    **Expected Outcome:** The parser should process the file without raising an error, recognizing that `PeripheralB`\n    shares an overlapping address block with `PeripheralA` and correctly defines `PeripheralA` as its alternate\n    peripheral. Both peripherals should be parsed correctly, with `PeripheralA` listed first and having a base\n    address of `0x40001000`. `PeripheralB` should have the base address of `0x40001004`, with the alternate\n    peripheral attribute correctly set to `PeripheralA`. The parser should handle this situation as expected,\n    accepting the shared space as valid due to the explicit alternate peripheral specification.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/alternate_peripheral_overlap.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001004\n    assert device.peripherals[1].alternate_peripheral == \"PeripheralA\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/alternate_peripheral_overlap.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;alternate_peripheral_overlap&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;baseAddress&gt;0x40001004&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_block_overlap","title":"<code>test_block_overlap</code>","text":"<p>This test checks whether the parser handles cases where the address blocks of a base peripheral and a derived peripheral overlap. This test ensures that when the address ranges of two peripherals partially overlap, the parser processes the file correctly but issues a warning to the user. The behavior mirrors that of <code>svdconv</code>, where overlapping address blocks do not trigger an error but generate a warning to inform the user about the potential conflict.</p> <p>Expected Outcome: The parser should process the file successfully but issue a warning (e.g. <code>ProcessWarning</code>) to inform the user that the address blocks of <code>PeripheralA</code> and <code>PeripheralB</code> overlap. <code>PeripheralA</code> should have a base address of <code>0x40001000</code>, while <code>PeripheralB</code> should start at <code>0x40001004</code>, leading to an overlap in their address spaces. Both peripherals should be parsed correctly, and the parser should handle the overlap as expected, warning the user without halting the process.</p> <p>Processable with svdconv: yes - with warnings</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>def test_block_overlap(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether the parser handles cases where the address blocks of a base peripheral and a derived\n    peripheral overlap. This test ensures that when the address ranges of two peripherals partially overlap, the\n    parser processes the file correctly but issues a warning to the user. The behavior mirrors that of `svdconv`,\n    where overlapping address blocks do not trigger an error but generate a warning to inform the user about the\n    potential conflict.\n\n    **Expected Outcome:** The parser should process the file successfully but issue a warning (e.g. `ProcessWarning`)\n    to inform the user that the address blocks of `PeripheralA` and `PeripheralB` overlap. `PeripheralA` should\n    have a base address of `0x40001000`, while `PeripheralB` should start at `0x40001004`, leading to an overlap\n    in their address spaces. Both peripherals should be parsed correctly, and the parser should handle the overlap\n    as expected, warning the user without halting the process.\n\n    **Processable with svdconv:** yes - with warnings\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/block_overlap.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001004\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/block_overlap.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;block_overlap&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001004&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_circular_inheritance","title":"<code>test_circular_inheritance</code>","text":"<p>This test ensures that the parser correctly identifies and handles circular inheritance, where three peripherals, <code>PeripheralA</code>, <code>PeripheralB</code>, and <code>PeripheralC</code>, attempt to inherit from each other, creating a loop. Circular references should be detected, and the parser should raise an appropriate error to prevent infinite recursion or incorrect parsing.</p> <p>Expected Outcome: The parser should detect the circular inheritance between <code>PeripheralA</code>, <code>PeripheralB</code>, and <code>PeripheralC</code>, and fail with an error indicating that circular inheritance is not supported. The test should raise a <code>ProcessException</code> or an equivalent error, ensuring that the parser does not attempt to resolve the circular references and avoids potential infinite loops.</p> <p>Processable with svdconv: no - although <code>svdconv</code> fails to process this test case, it is not due to the detection of circular inheritance but because <code>svdconv</code> does not support forward references over different peripherals.</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Circular inheritance is not supported\")\ndef test_circular_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly identifies and handles circular inheritance, where three\n    peripherals, `PeripheralA`, `PeripheralB`, and `PeripheralC`, attempt to inherit from each other, creating a\n    loop. Circular references should be detected, and the parser should raise an appropriate error to prevent\n    infinite recursion or incorrect parsing.\n\n    **Expected Outcome:** The parser should detect the circular inheritance between `PeripheralA`, `PeripheralB`, and\n    `PeripheralC`, and fail with an error indicating that circular inheritance is not supported. The test should\n    raise a `ProcessException` or an equivalent error, ensuring that the parser does not attempt to resolve the\n    circular references and avoids potential infinite loops.\n\n    **Processable with svdconv:** no - although `svdconv` fails to process this test case, it is not due to the\n    detection of circular inheritance but because `svdconv` does not support forward references over different\n    peripherals.\n    \"\"\"\n\n    get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/circular_inheritance.svd\")\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/circular_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;circular_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral derivedFrom=\"PeripheralC\"&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralB\"&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_derive_from_self","title":"<code>test_derive_from_self</code>","text":"<p>This test case evaluates a scenario where a peripheral attempts to derive from itself, creating an invalid configuration. In the SVD file, <code>PeripheralA</code> is defined with a <code>derivedFrom</code> attribute pointing to its own name. Such configurations should be detected as erroneous because a peripheral cannot logically inherit properties from itself. This kind of self-reference should lead to a parsing error.</p> <p>Expected Outcome: The parser should detect the invalid self-referential inheritance and raise an error, indicating that a peripheral cannot derive from itself. This ensures that the system handles such configurations correctly by stopping further processing and informing the user of the issue.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Can't derive from self\")\ndef test_derive_from_self(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates a scenario where a peripheral attempts to derive from itself, creating an invalid\n    configuration. In the SVD file, `PeripheralA` is defined with a `derivedFrom` attribute pointing to its own\n    name. Such configurations should be detected as erroneous because a peripheral cannot logically inherit\n    properties from itself. This kind of self-reference should lead to a parsing error.\n\n    **Expected Outcome:** The parser should detect the invalid self-referential inheritance and raise an error,\n    indicating that a peripheral cannot derive from itself. This ensures that the system handles such\n    configurations correctly by stopping further processing and informing the user of the issue.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/derive_from_self.svd\")\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/derive_from_self.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;derive_from_self&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_multiple_inheritance_backward_and_forward_reference_with_value_override","title":"<code>test_multiple_inheritance_backward_and_forward_reference_with_value_override</code>","text":"<p>This test ensures that multiple inheritance involving both backward and forward references is handled correctly, with value overrides applied at each level. Specifically, PeripheralC is the base peripheral, PeripheralA inherits from PeripheralC, and PeripheralB inherits from PeripheralA. Additionally, the test verifies that the <code>size</code> value specified at the peripheral level is correctly propagated down to the registers.</p> <p>Expected Outcome: The device contains three peripherals, each correctly inheriting properties from the previous peripheral and overriding specific values where necessary. The <code>size</code> value defined at each peripheral level is inherited by the registers within those peripherals. PeripheralA inherits from PeripheralC and overrides certain values while maintaining the inheritance structure. It has the <code>name</code> \"PeripheralA\", a <code>prependToName</code> of \"Prepend\", an <code>appendToName</code> of \"Append2\", a <code>disableCondition</code> of \"1 == 1\", a <code>baseAddress</code> of <code>0x40001000</code>, and a <code>size</code> of 64 bits. It contains one address block with an offset of <code>0x0</code>, a size of <code>0x1000</code>, and usage for registers. PeripheralA also inherits the register <code>RegisterA</code> from PeripheralC, with the overridden <code>size</code> of 64 bits and an address offset of <code>0x0</code>. PeripheralB, which inherits from PeripheralA, overrides the <code>baseAddress</code>, <code>size</code>, and the size of the inherited register. It has the <code>name</code> \"PeripheralB\", a <code>prependToName</code> of \"Prepend\", an <code>appendToName</code> of \"Append2\", a <code>disableCondition</code> of \"1 == 1\", a <code>baseAddress</code> of <code>0x40002000</code>, and a <code>size</code> of 128 bits. It contains one address block with an offset of <code>0x0</code>, a size of <code>0x1000</code>, and usage for registers. The register <code>RegisterA</code> is inherited from PeripheralA, but with the size of 128 bits, correctly reflecting the peripheral-level override. PeripheralC is the base peripheral and defines the initial values. It has the <code>name</code> \"PeripheralC\", a <code>prependToName</code> of \"Prepend\", an <code>appendToName</code> of \"Append\", a <code>disableCondition</code> of \"0 == 0\", a <code>baseAddress</code> of <code>0x40003000</code>, and a <code>size</code> of 16 bits. It contains one address block with an offset of <code>0x0</code>, a size of <code>0x1000</code>, and usage for registers. The register <code>RegisterA</code> is defined at this level with an address offset of <code>0x0</code> and a size of 16 bits. The test confirms that the inheritance chain works as expected, with value overrides properly applied, and that the <code>size</code> value specified at the peripheral level is correctly propagated to the registers within those peripherals, even though <code>svdconv</code> cannot handle forward references over different peripherals.</p> <p>Processable with svdconv: no - <code>svdconv</code> can't handle forward references over different peripherals.</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_backward_and_forward_reference_with_value_override(\n    get_processed_device_from_testfile: Callable[[str], Device]\n):\n    \"\"\"\n    This test ensures that multiple inheritance involving both backward and forward references is handled\n    correctly, with value overrides applied at each level. Specifically, PeripheralC is the base peripheral,\n    PeripheralA inherits from PeripheralC, and PeripheralB inherits from PeripheralA. Additionally, the test\n    verifies that the `size` value specified at the peripheral level is correctly propagated down to the\n    registers.\n\n    **Expected Outcome:** The device contains three peripherals, each correctly inheriting properties from the\n    previous peripheral and overriding specific values where necessary. The `size` value defined at each\n    peripheral level is inherited by the registers within those peripherals. PeripheralA inherits from PeripheralC\n    and overrides certain values while maintaining the inheritance structure. It has the `name` \"PeripheralA\", a\n    `prependToName` of \"Prepend\", an `appendToName` of \"Append2\", a `disableCondition` of \"1 == 1\", a\n    `baseAddress` of `0x40001000`, and a `size` of 64 bits. It contains one address block with an offset of `0x0`,\n    a size of `0x1000`, and usage for registers. PeripheralA also inherits the register `RegisterA` from\n    PeripheralC, with the overridden `size` of 64 bits and an address offset of `0x0`. PeripheralB, which inherits\n    from PeripheralA, overrides the `baseAddress`, `size`, and the size of the inherited register. It has the\n    `name` \"PeripheralB\", a `prependToName` of \"Prepend\", an `appendToName` of \"Append2\", a `disableCondition` of\n    \"1 == 1\", a `baseAddress` of `0x40002000`, and a `size` of 128 bits. It contains one address block with an\n    offset of `0x0`, a size of `0x1000`, and usage for registers. The register `RegisterA` is inherited from\n    PeripheralA, but with the size of 128 bits, correctly reflecting the peripheral-level override. PeripheralC is\n    the base peripheral and defines the initial values. It has the `name` \"PeripheralC\", a `prependToName` of\n    \"Prepend\", an `appendToName` of \"Append\", a `disableCondition` of \"0 == 0\", a `baseAddress` of `0x40003000`,\n    and a `size` of 16 bits. It contains one address block with an offset of `0x0`, a size of `0x1000`, and usage\n    for registers. The register `RegisterA` is defined at this level with an address offset of `0x0` and a size of\n    16 bits. The test confirms that the inheritance chain works as expected, with value overrides properly\n    applied, and that the `size` value specified at the peripheral level is correctly propagated to the registers\n    within those peripherals, even though `svdconv` cannot handle forward references over different peripherals.\n\n    **Processable with svdconv:** no - `svdconv` can't handle forward references over different peripherals.\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/\"\n        \"multiple_inheritance_backward_and_forward_reference_with_value_override.svd\"\n    )\n\n    assert len(device.peripherals) == 3\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].prepend_to_name == \"Prepend\"\n    assert device.peripherals[0].append_to_name == \"Append2\"\n    assert device.peripherals[0].disable_condition == \"1 == 1\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert device.peripherals[0].size == 64\n    assert len(device.peripherals[0].address_blocks) == 1\n    assert device.peripherals[0].address_blocks[0].offset == 0x0\n    assert device.peripherals[0].address_blocks[0].size == 0x1000\n    assert device.peripherals[0].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 64\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].prepend_to_name == \"Prepend\"\n    assert device.peripherals[1].append_to_name == \"Append2\"\n    assert device.peripherals[1].disable_condition == \"1 == 1\"\n    assert device.peripherals[1].base_address == 0x40002000\n    assert device.peripherals[1].size == 128\n    assert len(device.peripherals[1].address_blocks) == 1\n    assert device.peripherals[1].address_blocks[0].offset == 0x0\n    assert device.peripherals[1].address_blocks[0].size == 0x1000\n    assert device.peripherals[1].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 128\n\n    assert device.peripherals[2].name == \"PeripheralC\"\n    assert device.peripherals[2].prepend_to_name == \"Prepend\"\n    assert device.peripherals[2].append_to_name == \"Append\"\n    assert device.peripherals[2].disable_condition == \"0 == 0\"\n    assert device.peripherals[2].base_address == 0x40003000\n    assert device.peripherals[2].size == 16\n    assert len(device.peripherals[2].address_blocks) == 1\n    assert device.peripherals[2].address_blocks[0].offset == 0x0\n    assert device.peripherals[2].address_blocks[0].size == 0x1000\n    assert device.peripherals[2].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert len(device.peripherals[2].registers_clusters) == 1\n    assert isinstance(device.peripherals[2].registers_clusters[0], Register)\n    assert device.peripherals[2].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[2].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[2].registers_clusters[0].size == 16\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_multiple_inheritance_backward_reference","title":"<code>test_multiple_inheritance_backward_reference</code>","text":"<p>This test ensures that inheritance across multiple peripherals works as expected, where PeripheralB is derived first, and only afterward, PeripheralC can be derived from PeripheralB. It verifies that PeripheralC correctly inherits from PeripheralB, which in turn inherits from a base peripheral.</p> <p>Expected Outcome: The device should contain three peripherals, with PeripheralB and PeripheralC correctly following the inheritance chain. PeripheralB inherits from the base peripheral and contains one register and one address block. PeripheralC inherits from PeripheralB, maintaining the inherited structure. PeripheralB has the name \"PeripheralB\", one register named <code>RegisterA</code>, and one address block with an offset of <code>0x0</code>, a size of <code>0x1000</code>, and usage for registers. PeripheralC, derived from PeripheralB, has the name \"PeripheralC\", also contains the register <code>RegisterA</code>, and has an identical address block with an offset of <code>0x0</code>, a size of <code>0x1000</code>, and usage for registers. The inheritance process between multiple peripherals is handled correctly.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_backward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that inheritance across multiple peripherals works as expected, where PeripheralB is derived\n    first, and only afterward, PeripheralC can be derived from PeripheralB. It verifies that PeripheralC correctly\n    inherits from PeripheralB, which in turn inherits from a base peripheral.\n\n    **Expected Outcome:** The device should contain three peripherals, with PeripheralB and PeripheralC correctly\n    following the inheritance chain. PeripheralB inherits from the base peripheral and contains one register and\n    one address block. PeripheralC inherits from PeripheralB, maintaining the inherited structure. PeripheralB has\n    the name \"PeripheralB\", one register named `RegisterA`, and one address block with an offset of `0x0`, a size\n    of `0x1000`, and usage for registers. PeripheralC, derived from PeripheralB, has the name \"PeripheralC\", also\n    contains the register `RegisterA`, and has an identical address block with an offset of `0x0`, a size of\n    `0x1000`, and usage for registers. The inheritance process between multiple peripherals is handled correctly.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/multiple_inheritance_backward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 3\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert len(device.peripherals[1].address_blocks) == 1\n    assert device.peripherals[1].address_blocks[0].offset == 0x0\n    assert device.peripherals[1].address_blocks[0].size == 0x1000\n    assert device.peripherals[1].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n\n    assert device.peripherals[2].name == \"PeripheralC\"\n    assert len(device.peripherals[2].registers_clusters) == 1\n    assert len(device.peripherals[2].address_blocks) == 1\n    assert device.peripherals[2].address_blocks[0].offset == 0x0\n    assert device.peripherals[2].address_blocks[0].size == 0x1000\n    assert device.peripherals[2].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert isinstance(device.peripherals[2].registers_clusters[0], Register)\n    assert device.peripherals[2].registers_clusters[0].name == \"RegisterA\"\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/multiple_inheritance_backward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_inheritance_backward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralB\"&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_multiple_inheritance_forward_reference","title":"<code>test_multiple_inheritance_forward_reference</code>","text":"<p>This test ensures that inheritance across multiple peripherals is correctly handled when forward references are involved, where PeripheralA inherits from PeripheralB, and PeripheralB inherits from PeripheralC.</p> <p>Expected Outcome: The device should contain three peripherals. PeripheralC is the base peripheral and contains one register named <code>RegisterA</code> and one address block with an offset of <code>0x0</code>, a size of <code>0x1000</code>, and usage for registers. PeripheralB inherits from PeripheralC and should correctly include the inherited register <code>RegisterA</code> and the address block with the same properties. Finally, PeripheralA, which inherits from PeripheralB, also includes the inherited register <code>RegisterA</code> and the same address block structure. The test verifies that forward inheritance through multiple peripherals works correctly, even though <code>svdconv</code> is not capable of processing forward references over different peripherals.</p> <p>Processable with svdconv: no - <code>svdconv</code> can't handle forward references over different peripherals.</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that inheritance across multiple peripherals is correctly handled when forward references\n    are involved, where PeripheralA inherits from PeripheralB, and PeripheralB inherits from PeripheralC.\n\n    **Expected Outcome:** The device should contain three peripherals. PeripheralC is the base peripheral and contains\n    one register named `RegisterA` and one address block with an offset of `0x0`, a size of `0x1000`, and usage\n    for registers. PeripheralB inherits from PeripheralC and should correctly include the inherited register\n    `RegisterA` and the address block with the same properties. Finally, PeripheralA, which inherits from\n    PeripheralB, also includes the inherited register `RegisterA` and the same address block structure. The test\n    verifies that forward inheritance through multiple peripherals works correctly, even though `svdconv` is not\n    capable of processing forward references over different peripherals.\n\n    **Processable with svdconv:** no - `svdconv` can't handle forward references over different peripherals.\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/multiple_inheritance_forward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 3\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert len(device.peripherals[0].address_blocks) == 1\n    assert device.peripherals[0].address_blocks[0].offset == 0x0\n    assert device.peripherals[0].address_blocks[0].size == 0x1000\n    assert device.peripherals[0].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert len(device.peripherals[1].address_blocks) == 1\n    assert device.peripherals[1].address_blocks[0].offset == 0x0\n    assert device.peripherals[1].address_blocks[0].size == 0x1000\n    assert device.peripherals[1].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/multiple_inheritance_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_inheritance_backward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral derivedFrom=\"PeripheralB\"&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralC\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_override_behavior","title":"<code>test_override_behavior</code>","text":"<p>This test checks whether specific values of a derived peripheral can override the inherited values from a base peripheral. It ensures that modifications to values like <code>name</code>, <code>version</code>, <code>description</code>, and others in the derived peripheral are applied correctly, while still inheriting the base peripheral's structure when not explicitly overridden.</p> <p>Expected Outcome: The derived peripheral, PeripheralB, correctly overrides inherited values from the base peripheral. PeripheralB should have the <code>name</code> \"PeripheralB\", <code>version</code> \"2.0\", <code>description</code> \"PeripheralB Description\", an <code>alternatePeripheral</code> of \"PeripheralD\", a <code>groupName</code> \"PeripheralsGroup2\", a <code>prependToName</code> \"Prefix2\", and a <code>appendToName</code> \"Suffix2\". Additionally, the <code>header_struct_name</code> is correctly set to \"HeaderStructName2\", and the <code>disable_condition</code> is <code>\"1 == 1\"</code>. PeripheralB should also have a base address of <code>0x40002000</code>, a <code>size</code> of 64 bits, <code>access</code> type <code>WRITE_ONCE</code>, <code>protection</code> type <code>NON_SECURE</code>, a <code>resetValue</code> of <code>0x0F0F0F0F</code>, and a <code>resetMask</code> of <code>0xABABABAB</code>. PeripheralB contains one address block starting at offset <code>0x0</code>, with a size of <code>0x2000</code> and usage for registers. It also contains one interrupt, named <code>InterruptC</code>, with a description \"InterruptC Description\" and a value of 2. Additionally, PeripheralB contains two registers: <code>RegisterA</code> with an address offset of <code>0x0</code>, and <code>RegisterB</code> with an address offset of <code>0x8</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_override_behavior(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether specific values of a derived peripheral can override the inherited values from a base\n    peripheral. It ensures that modifications to values like `name`, `version`, `description`, and others in the\n    derived peripheral are applied correctly, while still inheriting the base peripheral's structure when not\n    explicitly overridden.\n\n    **Expected Outcome:** The derived peripheral, PeripheralB, correctly overrides inherited values from the base\n    peripheral. PeripheralB should have the `name` \"PeripheralB\", `version` \"2.0\", `description` \"PeripheralB\n    Description\", an `alternatePeripheral` of \"PeripheralD\", a `groupName` \"PeripheralsGroup2\", a `prependToName`\n    \"Prefix2\", and a `appendToName` \"Suffix2\". Additionally, the `header_struct_name` is correctly set to\n    \"HeaderStructName2\", and the `disable_condition` is `\"1 == 1\"`. PeripheralB should also have a base address of\n    `0x40002000`, a `size` of 64 bits, `access` type `WRITE_ONCE`, `protection` type `NON_SECURE`, a `resetValue`\n    of `0x0F0F0F0F`, and a `resetMask` of `0xABABABAB`. PeripheralB contains one address block starting at offset\n    `0x0`, with a size of `0x2000` and usage for registers. It also contains one interrupt, named `InterruptC`,\n    with a description \"InterruptC Description\" and a value of 2. Additionally, PeripheralB contains two\n    registers: `RegisterA` with an address offset of `0x0`, and `RegisterB` with an address offset of `0x8`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/override_behavior.svd\")\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].version == \"2.0\"\n    assert device.peripherals[1].description == \"PeripheralB Description\"\n    assert device.peripherals[1].alternate_peripheral == \"PeripheralA\"\n    assert device.peripherals[1].group_name == \"PeripheralsGroup2\"\n    assert device.peripherals[1].prepend_to_name == \"Prefix2\"\n    assert device.peripherals[1].append_to_name == \"Suffix2\"\n    assert device.peripherals[1].header_struct_name == \"HeaderStructName2\"\n    assert device.peripherals[1].disable_condition == \"1 == 1\"\n    assert device.peripherals[1].base_address == 0x40002000\n    assert device.peripherals[1].size == 64\n    assert device.peripherals[1].access == AccessType.WRITE_ONCE\n    assert device.peripherals[1].protection == ProtectionStringType.NON_SECURE\n    assert device.peripherals[1].reset_value == 0x0F0F0F0F\n    assert device.peripherals[1].reset_mask == 0xABABABAB\n\n    assert len(device.peripherals[1].address_blocks) == 1\n    assert device.peripherals[1].address_blocks[0].offset == 0x0\n    assert device.peripherals[1].address_blocks[0].size == 0x2000\n    assert device.peripherals[1].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n\n    assert len(device.peripherals[1].interrupts) == 1\n    assert device.peripherals[1].interrupts[0].name == \"InterruptC\"\n    assert device.peripherals[1].interrupts[0].description == \"InterruptC Description\"\n    assert device.peripherals[1].interrupts[0].value == 2\n\n    assert len(device.peripherals[1].registers_clusters) == 2\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert isinstance(device.peripherals[1].registers_clusters[1], Register)\n    assert device.peripherals[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[1].registers_clusters[1].address_offset == 0x8\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/override_behavior.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;override_behavior&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;version&gt;1.0&lt;/version&gt;\n      &lt;description&gt;PeripheralA Description&lt;/description&gt;\n      &lt;alternatePeripheral&gt;PeripheralB&lt;/alternatePeripheral&gt;\n      &lt;groupName&gt;PeripheralsGroup&lt;/groupName&gt;\n      &lt;prependToName&gt;Prefix&lt;/prependToName&gt;\n      &lt;appendToName&gt;Suffix&lt;/appendToName&gt;\n      &lt;headerStructName&gt;HeaderStructName&lt;/headerStructName&gt;\n      &lt;disableCondition&gt;0 == 0&lt;/disableCondition&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;size&gt;16&lt;/size&gt;\n      &lt;access&gt;write-only&lt;/access&gt;\n      &lt;protection&gt;s&lt;/protection&gt;\n      &lt;resetValue&gt;0xDEADBEEF&lt;/resetValue&gt;\n      &lt;resetMask&gt;0xDEADC0DE&lt;/resetMask&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;interrupt&gt;\n        &lt;name&gt;InterruptA&lt;/name&gt;\n        &lt;description&gt;InterruptA Description&lt;/description&gt;\n        &lt;value&gt;0&lt;/value&gt;\n      &lt;/interrupt&gt;\n      &lt;interrupt&gt;\n        &lt;name&gt;InterruptB&lt;/name&gt;\n        &lt;description&gt;InterruptB Description&lt;/description&gt;\n        &lt;value&gt;1&lt;/value&gt;\n      &lt;/interrupt&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;version&gt;2.0&lt;/version&gt;\n      &lt;description&gt;PeripheralB Description&lt;/description&gt;\n      &lt;alternatePeripheral&gt;PeripheralA&lt;/alternatePeripheral&gt;\n      &lt;groupName&gt;PeripheralsGroup2&lt;/groupName&gt;\n      &lt;prependToName&gt;Prefix2&lt;/prependToName&gt;\n      &lt;appendToName&gt;Suffix2&lt;/appendToName&gt;\n      &lt;headerStructName&gt;HeaderStructName2&lt;/headerStructName&gt;\n      &lt;disableCondition&gt;1 == 1&lt;/disableCondition&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;size&gt;64&lt;/size&gt;\n      &lt;access&gt;writeOnce&lt;/access&gt;\n      &lt;protection&gt;n&lt;/protection&gt;\n      &lt;resetValue&gt;0x0F0F0F0F&lt;/resetValue&gt;\n      &lt;resetMask&gt;0xABABABAB&lt;/resetMask&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x2000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;interrupt&gt;\n        &lt;name&gt;InterruptC&lt;/name&gt;\n        &lt;description&gt;InterruptC Description&lt;/description&gt;\n        &lt;value&gt;2&lt;/value&gt;\n      &lt;/interrupt&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_register_inheritance_alternate_group","title":"<code>test_register_inheritance_alternate_group</code>","text":"<p>This test checks how the parser handles peripheral inheritance when an alternate group is involved in a register. The test file includes two peripherals, <code>PeripheralA</code> and <code>PeripheralB</code>. <code>PeripheralA</code> contains a register, <code>RegisterA</code>, without an alternate group defined. <code>PeripheralB</code> inherits <code>RegisterA</code> but defines an alternate group for another register, which is also named <code>RegisterA</code>. Both registers have the same offset address. The test ensures that the parser can process this scenario correctly.</p> <p>Expected Outcome: The parser should successfully process the SVD file, correctly handling the peripheral inheritance and alternate group settings. <code>PeripheralB</code> contains two instances of <code>RegisterA</code>, both with the same address offset of <code>0x0</code> and a size of 32 bits. The first instance of <code>RegisterA</code> has no alternate group defined, while the second instance correctly specifies an alternate group named <code>RegisterX</code> and is named <code>RegisterA_RegisterX</code>. The parser should correctly handle this difference between the two instances of the inherited register without raising errors.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_inheritance_alternate_group(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks how the parser handles peripheral inheritance when an alternate group is involved in a\n    register. The test file includes two peripherals, `PeripheralA` and `PeripheralB`. `PeripheralA` contains a\n    register, `RegisterA`, without an alternate group defined. `PeripheralB` inherits `RegisterA` but defines an\n    alternate group for another register, which is also named `RegisterA`. Both registers have the same offset\n    address. The test ensures that the parser can process this scenario correctly.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, correctly handling the peripheral\n    inheritance and alternate group settings. `PeripheralB` contains two instances of `RegisterA`, both with the\n    same address offset of `0x0` and a size of 32 bits. The first instance of `RegisterA` has no alternate group\n    defined, while the second instance correctly specifies an alternate group named `RegisterX` and is named\n    `RegisterA_RegisterX`. The parser should correctly handle this difference between the two instances of the\n    inherited register without raising errors.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/register_inheritance_alternate_group.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert len(device.peripherals[1].registers_clusters) == 2\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n    assert device.peripherals[1].registers_clusters[0].alternate_group is None\n    assert isinstance(device.peripherals[1].registers_clusters[1], Register)\n    assert device.peripherals[1].registers_clusters[1].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[1].size == 32\n    assert device.peripherals[1].registers_clusters[1].alternate_group == \"RegisterX\"\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/register_inheritance_alternate_group.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_alternate_group&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;alternateGroup&gt;RegisterX&lt;/alternateGroup&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_register_inheritance_alternate_register","title":"<code>test_register_inheritance_alternate_register</code>","text":"<p>This test evaluates the parser's ability to handle peripheral inheritance when the <code>alternateRegister</code> element is defined. The test file contains two peripherals, <code>PeripheralA</code> and <code>PeripheralB</code>. <code>PeripheralA</code> defines <code>RegisterA</code>, and <code>PeripheralB</code> inherits from <code>PeripheralA</code> while adding a new register, <code>RegisterB</code>. <code>RegisterB</code> shares the same address offset as <code>RegisterA</code> and defines <code>RegisterA</code> as its alternate register. This setup is used to ensure the parser correctly processes alternate register relationships between inherited registers.</p> <p>Expected Outcome: The parser should successfully process the SVD file, properly handling the alternate register relationships during inheritance. <code>PeripheralB</code> contains two registers: <code>RegisterA</code>, which has an address offset of <code>0x0</code> and a size of 32 bits, with no alternate register defined, and <code>RegisterB</code>, which also has an address offset of <code>0x0</code> and a size of 32 bits, but specifies <code>RegisterA</code> as its alternate register. The parser should accurately reflect this alternate register linkage without raising any errors.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_inheritance_alternate_register(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates the parser's ability to handle peripheral inheritance when the `alternateRegister` element\n    is defined. The test file contains two peripherals, `PeripheralA` and `PeripheralB`. `PeripheralA` defines\n    `RegisterA`, and `PeripheralB` inherits from `PeripheralA` while adding a new register, `RegisterB`.\n    `RegisterB` shares the same address offset as `RegisterA` and defines `RegisterA` as its alternate register.\n    This setup is used to ensure the parser correctly processes alternate register relationships between inherited\n    registers.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, properly handling the alternate\n    register relationships during inheritance. `PeripheralB` contains two registers: `RegisterA`, which has an\n    address offset of `0x0` and a size of 32 bits, with no alternate register defined, and `RegisterB`, which also\n    has an address offset of `0x0` and a size of 32 bits, but specifies `RegisterA` as its alternate register. The\n    parser should accurately reflect this alternate register linkage without raising any errors.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/register_inheritance_alternate_register.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert len(device.peripherals[1].registers_clusters) == 2\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n    assert device.peripherals[1].registers_clusters[0].alternate_register is None\n    assert isinstance(device.peripherals[1].registers_clusters[1], Register)\n    assert device.peripherals[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[1].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[1].size == 32\n    assert device.peripherals[1].registers_clusters[1].alternate_register == \"RegisterA\"\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/register_inheritance_alternate_register.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_alternate_register&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;alternateRegister&gt;RegisterA&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_register_inheritance_overlap_address","title":"<code>test_register_inheritance_overlap_address</code>","text":"<p>This test ensures that the parser correctly handles cases where a register is derived from another peripheral, resulting in two registers within the same peripheral having overlapping address spaces. For backward compatibility with older <code>svdconv</code> versions, a warning is issued when registers overlap in address space. A parser designed to work with both new and old SVD files should allow registers with overlapping addresses but issue a warning to inform the user of the conflict.</p> <p>Expected Outcome: The parser should detect the address overlap between <code>RegisterA</code> and <code>RegisterB</code> within <code>PeripheralB</code>. <code>RegisterA</code> starts at address <code>0x0</code> with a size of 32 bits, and <code>RegisterB</code> starts at address <code>0x2</code> with a size of 16 bits, creating the overlap. Instead of failing, the parser should successfully process the SVD file and issue a warning to inform the user of the overlap.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>def test_register_inheritance_overlap_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly handles cases where a register is derived from another peripheral,\n    resulting in two registers within the same peripheral having overlapping address spaces. For backward\n    compatibility with older `svdconv` versions, a warning is issued when registers overlap in address space. A\n    parser designed to work with both new and old SVD files should allow registers with overlapping addresses but\n    issue a warning to inform the user of the conflict.\n\n    **Expected Outcome:** The parser should detect the address overlap between `RegisterA` and `RegisterB` within\n    `PeripheralB`. `RegisterA` starts at address `0x0` with a size of 32 bits, and `RegisterB` starts at address\n    `0x2` with a size of 16 bits, creating the overlap. Instead of failing, the parser should successfully process\n    the SVD file and issue a warning to inform the user of the overlap.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"peripheral_inheritance_via_derivedfrom/register_inheritance_overlap_address.svd\"\n        )\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert len(device.peripherals[1].registers_clusters) == 2\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n    assert isinstance(device.peripherals[1].registers_clusters[1], Register)\n    assert device.peripherals[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[1].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[1].registers_clusters[1].size == 16\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/register_inheritance_overlap_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_overlap_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;32&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_register_inheritance_oversized_field","title":"<code>test_register_inheritance_oversized_field</code>","text":"<p>PeripheralB inherits from PeripheralA. PeripheralA contains <code>RegisterA</code>, which has a default size of 32 bits. <code>RegisterA</code> includes a field, <code>FieldA</code>, with a bit width of 32 bits. When inherited by PeripheralB, the size of <code>RegisterA</code> is reduced to 16 bits because PeripheralB has its size set to 16. However, <code>FieldA</code> is inherited with its original 32-bit width, which exceeds the space available in <code>RegisterA</code> within PeripheralB. Despite this mismatch, <code>svdconv</code> neither raises a warning nor an error. A parser should be aware of this condition and warn the user when a field exceeds the size of its containing register.</p> <p>Expected Outcome: The parser should process the file successfully and may issue a warning (<code>ProcessWarning</code>) to inform the user that <code>FieldA</code> exceeds the 16-bit size of <code>RegisterA</code> in PeripheralB. The device contains two peripherals: PeripheralA has <code>RegisterA</code> with a size of 32 bits and a field, <code>FieldA</code>, that spans from bit 0 to bit 31. PeripheralB inherits <code>RegisterA</code>, but with a reduced size of 16 bits, while <code>FieldA</code> retains its original 32-bit width. This creates a mismatch, as <code>RegisterA</code> in PeripheralB lacks sufficient space to accommodate the full width of <code>FieldA</code>. The parser should correctly handle the inheritance, but it should warn the user about the oversized field relative to the reduced register size.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>def test_register_inheritance_oversized_field(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    PeripheralB inherits from PeripheralA. PeripheralA contains `RegisterA`, which has a default size of 32 bits.\n    `RegisterA` includes a field, `FieldA`, with a bit width of 32 bits. When inherited by PeripheralB, the size\n    of `RegisterA` is reduced to 16 bits because PeripheralB has its size set to 16. However, `FieldA` is\n    inherited with its original 32-bit width, which exceeds the space available in `RegisterA` within PeripheralB.\n    Despite this mismatch, `svdconv` neither raises a warning nor an error. A parser should be aware of this\n    condition and warn the user when a field exceeds the size of its containing register.\n\n    **Expected Outcome:** The parser should process the file successfully and may issue a warning (`ProcessWarning`)\n    to inform the user that `FieldA` exceeds the 16-bit size of `RegisterA` in PeripheralB. The device contains\n    two peripherals: PeripheralA has `RegisterA` with a size of 32 bits and a field, `FieldA`, that spans from bit\n    0 to bit 31. PeripheralB inherits `RegisterA`, but with a reduced size of 16 bits, while `FieldA` retains its\n    original 32-bit width. This creates a mismatch, as `RegisterA` in PeripheralB lacks sufficient space to\n    accommodate the full width of `FieldA`. The parser should correctly handle the inheritance, but it should warn\n    the user about the oversized field relative to the reduced register size.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"peripheral_inheritance_via_derivedfrom/register_inheritance_oversized_field.svd\"\n        )\n\n    assert len(device.peripherals) == 2\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].size == 32\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 31\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].size == 16\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 16\n    assert len(device.peripherals[1].registers_clusters[0].fields) == 1\n    assert device.peripherals[1].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[1].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[1].registers_clusters[0].fields[0].msb == 31\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/register_inheritance_oversized_field.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_oversized_field&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;32&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;size&gt;16&lt;/size&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_register_inheritance_same_address","title":"<code>test_register_inheritance_same_address</code>","text":"<p>This test ensures that the parser correctly handles cases where a register is derived from another peripheral, so that two registers within the same peripheral are assigned the same address. Although <code>svdconv</code> generally raises an error when two registers share the same address, for compatibility with older <code>svdconv</code> versions, a warning is generated in some situations (e.g., when using <code>dim</code>). For a parser designed to work with both new and old SVD files, it is recommended to allow registers with the same addresses but issue a warning to the user.</p> <p>Expected Outcome: The parser should detect that <code>RegisterA</code> and <code>RegisterB</code> are assigned the same address (<code>0x00000000</code>) within peripheral <code>PeripheralB</code>. Instead of failing, the parser should successfully process the SVD file but issue a warning (<code>ProcessWarning</code>) to inform the user about the address conflict. The device should contain two peripherals, and the second peripheral should have two registers, <code>RegisterA</code> and <code>RegisterB</code>, both with an address offset of <code>0x0</code>.</p> <p>Processable with svdconv: no - see subfeature test case description</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>def test_register_inheritance_same_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly handles cases where a register is derived from another peripheral,\n    so that two registers within the same peripheral are assigned the same address. Although `svdconv` generally\n    raises an error when two registers share the same address, for compatibility with older `svdconv` versions, a\n    warning is generated in [some situations](https://github.com/Open-CMSIS-\n    Pack/devtools/blob/44643999691347946562c526fc0474194f865c74/tools/svdconv/SVDModel/src/SvdPeripheral.cpp#L721)\n    (e.g., when using `dim`). For a parser designed to work with both new and old SVD files, it is recommended to\n    allow registers with the same addresses but issue a warning to the user.\n\n    **Expected Outcome:** The parser should detect that `RegisterA` and `RegisterB` are assigned the same address\n    (`0x00000000`) within peripheral `PeripheralB`. Instead of failing, the parser should successfully process the\n    SVD file but issue a warning (`ProcessWarning`) to inform the user about the address conflict. The device\n    should contain two peripherals, and the second peripheral should have two registers, `RegisterA` and\n    `RegisterB`, both with an address offset of `0x0`.\n\n    **Processable with svdconv:** no - see subfeature test case description\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"peripheral_inheritance_via_derivedfrom/register_inheritance_same_address.svd\"\n        )\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert len(device.peripherals[1].registers_clusters) == 2\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert isinstance(device.peripherals[1].registers_clusters[1], Register)\n    assert device.peripherals[1].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[1].registers_clusters[1].address_offset == 0x0\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/register_inheritance_same_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_same_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_register_inheritance_same_address_dim","title":"<code>test_register_inheritance_same_address_dim</code>","text":"<p>This test is similar to the one above, but in this case, <code>dim</code> is used, which causes <code>svdconv</code> to issue a warning instead of an error for compatibility reasons.</p> <p>Expected Outcome: The parser should successfully process the SVD file without errors, even though <code>RegisterA0</code> and <code>RegisterB0</code> share the same address offset of <code>0x0</code>, and <code>RegisterA1</code> and <code>RegisterB1</code> share the address offset of <code>0x4</code>. Each register has a size of 32 bits, resulting in overlapping addresses. While this overlap occurs, the parser should continue processing and, as recommended, may issue a warning to inform the user about the overlapping addresses. The device should contain two peripherals, and <code>PeripheralB</code> should have four registers expanded using <code>dim</code>, with the correct address offsets and sizes maintained for each register.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>def test_register_inheritance_same_address_dim(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test is similar to the one above, but in this case, `dim` is used, which causes `svdconv` to issue a\n    warning instead of an error for compatibility reasons.\n\n    **Expected Outcome:** The parser should successfully process the SVD file without errors, even though `RegisterA0`\n    and `RegisterB0` share the same address offset of `0x0`, and `RegisterA1` and `RegisterB1` share the address\n    offset of `0x4`. Each register has a size of 32 bits, resulting in overlapping addresses. While this overlap\n    occurs, the parser should continue processing and, as recommended, may issue a warning to inform the user\n    about the overlapping addresses. The device should contain two peripherals, and `PeripheralB` should have four\n    registers expanded using `dim`, with the correct address offsets and sizes maintained for each register.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"peripheral_inheritance_via_derivedfrom/register_inheritance_same_address_dim.svd\"\n        )\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert len(device.peripherals[1].registers_clusters) == 4\n\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA0\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n\n    assert isinstance(device.peripherals[1].registers_clusters[1], Register)\n    assert device.peripherals[1].registers_clusters[1].name == \"RegisterB0\"\n    assert device.peripherals[1].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[1].size == 32\n\n    assert isinstance(device.peripherals[1].registers_clusters[2], Register)\n    assert device.peripherals[1].registers_clusters[2].name == \"RegisterA1\"\n    assert device.peripherals[1].registers_clusters[2].address_offset == 0x4\n    assert device.peripherals[1].registers_clusters[2].size == 32\n\n    assert isinstance(device.peripherals[1].registers_clusters[3], Register)\n    assert device.peripherals[1].registers_clusters[3].name == \"RegisterB1\"\n    assert device.peripherals[1].registers_clusters[3].address_offset == 0x4\n    assert device.peripherals[1].registers_clusters[3].size == 32\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/register_inheritance_same_address_dim.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_same_address_dim&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;name&gt;RegisterA%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;dim&gt;2&lt;/dim&gt;\n          &lt;dimIncrement&gt;0x4&lt;/dimIncrement&gt;\n          &lt;name&gt;RegisterB%s&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_register_inheritance_same_name","title":"<code>test_register_inheritance_same_name</code>","text":"<p>This test ensures that the parser correctly handles the case where a register in a derived peripheral has the same name as an inherited register from a base peripheral. The test verifies whether the parser raises an error when a register with the same name is defined both in the base and the derived peripheral, which would create a naming conflict.</p> <p>Expected Outcome: The parser should detect that <code>RegisterA</code> is already defined in <code>PeripheralB</code> and cannot be inherited from <code>PeripheralA</code> due to the naming conflict. The parser is expected to raise a <code>ProcessException</code> or an equivalent error indicating that the register inheritance cannot proceed because the register name is already in use in the derived peripheral.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=(\n        \"RegisterA is already defined in PeripheralB and cannot be inherited from PeripheralA \"\n        \"because it has the same name\"\n    ),\n)\ndef test_register_inheritance_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that the parser correctly handles the case where a register in a derived peripheral has the\n    same name as an inherited register from a base peripheral. The test verifies whether the parser raises an\n    error when a register with the same name is defined both in the base and the derived peripheral, which would\n    create a naming conflict.\n\n    **Expected Outcome:** The parser should detect that `RegisterA` is already defined in `PeripheralB` and cannot be\n    inherited from `PeripheralA` due to the naming conflict. The parser is expected to raise a `ProcessException`\n    or an equivalent error indicating that the register inheritance cannot proceed because the register name is\n    already in use in the derived peripheral.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/register_inheritance_same_name.svd\")\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/register_inheritance_same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_inheritance_same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_register_properties_inheritance_size_adjustment","title":"<code>test_register_properties_inheritance_size_adjustment</code>","text":"<p>This test evaluates how the size property is handled during inheritance. The test file contains four peripherals: PeripheralA, PeripheralB, PeripheralC, and PeripheralD. PeripheralB inherits from PeripheralA, while PeripheralD inherits from PeripheralC. PeripheralA and PeripheralC each contain a register named RegisterA. In PeripheralA, the size of RegisterA is implicitly set to 32 bits (inherited from the peripheral level), while in PeripheralC, the size is explicitly defined as 32 bits at the register level. In <code>svdconv</code>, sizes are handled differently depending on whether they are set implicitly (inherited from the peripheral level) or explicitly at the register level. This distinction must be considered when developing a parser.</p> <p>Expected Outcome: The parser should process the file correctly, reflecting how sizes are inherited or explicitly defined. PeripheralA has a size of 32 bits, which is implicitly applied to RegisterA. PeripheralB inherits from PeripheralA but adjusts its size to 16 bits, and this change is reflected in RegisterA, which now has a size of 16 bits. In contrast, PeripheralC explicitly defines the size of RegisterA as 32 bits at the register level, and this size remains unchanged in PeripheralD, which inherits from PeripheralC. The parser should correctly handle both the implicit and explicit size settings, ensuring that the sizes are applied as expected for each peripheral and register.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_register_properties_inheritance_size_adjustment(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the size property is handled during inheritance. The test file contains four\n    peripherals: PeripheralA, PeripheralB, PeripheralC, and PeripheralD. PeripheralB inherits from PeripheralA,\n    while PeripheralD inherits from PeripheralC. PeripheralA and PeripheralC each contain a register named\n    RegisterA. In PeripheralA, the size of RegisterA is implicitly set to 32 bits (inherited from the peripheral\n    level), while in PeripheralC, the size is explicitly defined as 32 bits at the register level. In `svdconv`,\n    sizes are handled differently depending on whether they are set implicitly (inherited from the peripheral\n    level) or explicitly at the register level. This distinction must be considered when developing a parser.\n\n    **Expected Outcome:** The parser should process the file correctly, reflecting how sizes are inherited or\n    explicitly defined. PeripheralA has a size of 32 bits, which is implicitly applied to RegisterA. PeripheralB\n    inherits from PeripheralA but adjusts its size to 16 bits, and this change is reflected in RegisterA, which\n    now has a size of 16 bits. In contrast, PeripheralC explicitly defines the size of RegisterA as 32 bits at the\n    register level, and this size remains unchanged in PeripheralD, which inherits from PeripheralC. The parser\n    should correctly handle both the implicit and explicit size settings, ensuring that the sizes are applied as\n    expected for each peripheral and register.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/register_properties_inheritance_size_adjustment.svd\"\n    )\n\n    assert len(device.peripherals) == 4\n\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].size == 32\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].size == 32\n\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].size == 16\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].size == 16\n\n    assert device.peripherals[2].name == \"PeripheralC\"\n    assert device.peripherals[2].size == 32\n    assert len(device.peripherals[2].registers_clusters) == 1\n    assert isinstance(device.peripherals[2].registers_clusters[0], Register)\n    assert device.peripherals[2].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[2].registers_clusters[0].size == 32\n\n    assert device.peripherals[3].name == \"PeripheralD\"\n    assert device.peripherals[3].size == 32\n    assert len(device.peripherals[3].registers_clusters) == 1\n    assert isinstance(device.peripherals[3].registers_clusters[0], Register)\n    assert device.peripherals[3].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[3].registers_clusters[0].size == 32\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/register_properties_inheritance_size_adjustment.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_properties_inheritance_size_adjustment&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;size&gt;32&lt;/size&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;size&gt;16&lt;/size&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralC&lt;/name&gt;\n      &lt;baseAddress&gt;0x40003000&lt;/baseAddress&gt;\n      &lt;size&gt;32&lt;/size&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;32&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralC\"&gt;\n      &lt;name&gt;PeripheralD&lt;/name&gt;\n      &lt;baseAddress&gt;0x40004000&lt;/baseAddress&gt;\n      &lt;size&gt;16&lt;/size&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_same_address","title":"<code>test_same_address</code>","text":"<p>This test case examines the scenario where two peripherals, <code>PeripheralA</code> and <code>PeripheralB</code>, are set to use the same base address (<code>0x40001000</code>). In the SVD file, <code>PeripheralB</code> is derived from <code>PeripheralA</code>, but it explicitly specifies the same base address. Typically, <code>svdconv</code> would issue an error for such conflicts because peripherals should not share the same base address unless there is an alternate relationship defined. However, overlapping addresses are only treated with a warning by <code>svdconv</code> due to compatibility reasons with older versions. Therefore, it may be advisable to allow such configurations while issuing a warning instead of an outright error.</p> <p>Expected Outcome: The parser should process the file successfully but issue a warning (e.g. <code>ProcessWarning</code>) to inform the user that the address blocks of <code>PeripheralA</code> and <code>PeripheralB</code> share the same address.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>def test_same_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines the scenario where two peripherals, `PeripheralA` and `PeripheralB`, are set to use\n    the same base address (`0x40001000`). In the SVD file, `PeripheralB` is derived from `PeripheralA`, but it\n    explicitly specifies the same base address. Typically, `svdconv` would issue an error for such conflicts\n    because peripherals should not share the same base address unless there is an alternate relationship defined.\n    However, overlapping addresses are only treated with a warning by `svdconv` due to compatibility reasons with\n    older versions. Therefore, it may be advisable to allow such configurations while issuing a warning instead of\n    an outright error.\n\n    **Expected Outcome:** The parser should process the file successfully but issue a warning (e.g. `ProcessWarning`)\n    to inform the user that the address blocks of `PeripheralA` and `PeripheralB` share the same address.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/same_address.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[0].name == \"PeripheralA\"\n    assert device.peripherals[0].base_address == 0x40001000\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].base_address == 0x40001000\n    assert len(device.peripherals[1].registers_clusters) == 1\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/same_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;same_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_same_name","title":"<code>test_same_name</code>","text":"<p>This test checks whether a derived peripheral with the same name as its base peripheral triggers an error. The expected behavior mirrors that of svdconv, which also raises an error in this scenario. When two peripherals have the same name, it should result in a conflict, and the parser must prevent this from occurring by raising an appropriate error.</p> <p>Expected Outcome: The parser should raise an error when it encounters two peripherals, a base peripheral and its derived peripheral, sharing the same name. This behavior aligns with <code>svdconv</code>, where the same condition also triggers an error. The parser should halt processing and notify the user of the conflict, ensuring that no two peripherals share the same name within the SVD file.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"Two peripherals cannot have the same name\",\n)\ndef test_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test checks whether a derived peripheral with the same name as its base peripheral triggers an error. The\n    expected behavior mirrors that of svdconv, which also raises an error in this scenario. When two peripherals\n    have the same name, it should result in a conflict, and the parser must prevent this from occurring by raising\n    an appropriate error.\n\n    **Expected Outcome:** The parser should raise an error when it encounters two peripherals, a base peripheral and\n    its derived peripheral, sharing the same name. This behavior aligns with `svdconv`, where the same condition\n    also triggers an error. The parser should halt processing and notify the user of the conflict, ensuring that\n    no two peripherals share the same name within the SVD file.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/same_name.svd\")\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_simple_inheritance_backward_reference","title":"<code>test_simple_inheritance_backward_reference</code>","text":"<p>The derived peripheral (PeripheralB) is declared after the base peripheral (PeripheralA), representing the typical and straightforward inheritance scenario. The test ensures that peripheral PeripheralB correctly inherits register RegisterA from Peripheral PeripheralA.</p> <p>Expected Outcome: The device is processed correctly, and peripheral inheritance functions as expected. PeripheralB correctly inherits the register <code>RegisterA</code> from PeripheralA. The device contains two peripherals, with PeripheralB having one register and one address block. The address block in PeripheralB starts at offset <code>0x0</code>, has a size of <code>0x1000</code>, and is used for registers. The inherited register is correctly identified as <code>RegisterA</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_backward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    The derived peripheral (PeripheralB) is declared **after** the base peripheral (PeripheralA), representing the\n    typical and straightforward inheritance scenario. The test ensures that peripheral PeripheralB correctly\n    inherits register RegisterA from Peripheral PeripheralA.\n\n    **Expected Outcome:** The device is processed correctly, and peripheral inheritance functions as expected.\n    PeripheralB correctly inherits the register `RegisterA` from PeripheralA. The device contains two peripherals,\n    with PeripheralB having one register and one address block. The address block in PeripheralB starts at offset\n    `0x0`, has a size of `0x1000`, and is used for registers. The inherited register is correctly identified as\n    `RegisterA`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/simple_inheritance_backward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert len(device.peripherals[1].address_blocks) == 1\n    assert device.peripherals[1].address_blocks[0].offset == 0x0\n    assert device.peripherals[1].address_blocks[0].size == 0x1000\n    assert device.peripherals[1].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/simple_inheritance_backward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_backward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;version&gt;1.0&lt;/version&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_simple_inheritance_forward_reference","title":"<code>test_simple_inheritance_forward_reference</code>","text":"<p>The derived peripheral (PeripheralA) is declared before the base peripheral (PeripheralB), but PeripheralA inherits from PeripheralB. This tests the parser's ability to handle forward references, resolving references to elements defined later in the SVD file.</p> <p>Expected Outcome: The parser successfully resolves the forward reference where PeripheralA inherits from PeripheralB, despite PeripheralB being declared later in the SVD file. The device contains two peripherals, with PeripheralA having one register and one address block. The address block in PeripheralA starts at offset <code>0x0</code>, has a size of <code>0x1000</code>, and is used for registers. The inherited register is correctly identified as <code>RegisterA</code>.</p> <p>Processable with svdconv: no - <code>svdconv</code> can't handle forward references over different peripherals.</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    The derived peripheral (PeripheralA) is declared before the base peripheral (PeripheralB), but PeripheralA\n    inherits from PeripheralB. This tests the parser's ability to handle forward references, resolving references\n    to elements defined later in the SVD file.\n\n    **Expected Outcome:** The parser successfully resolves the forward reference where PeripheralA inherits from\n    PeripheralB, despite PeripheralB being declared later in the SVD file. The device contains two peripherals,\n    with PeripheralA having one register and one address block. The address block in PeripheralA starts at offset\n    `0x0`, has a size of `0x1000`, and is used for registers. The inherited register is correctly identified as\n    `RegisterA`.\n\n    **Processable with svdconv:** no - `svdconv` can't handle forward references over different peripherals.\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"peripheral_inheritance_via_derivedfrom/simple_inheritance_forward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert len(device.peripherals[0].address_blocks) == 1\n    assert device.peripherals[0].address_blocks[0].offset == 0x0\n    assert device.peripherals[0].address_blocks[0].size == 0x1000\n    assert device.peripherals[0].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/simple_inheritance_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_forward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral derivedFrom=\"PeripheralB\"&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;version&gt;1.0&lt;/version&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_peripheral_inheritance_via_derived_from.html#tests.test_process.test_peripheral_inheritance_via_derived_from.test_value_inheritance","title":"<code>test_value_inheritance</code>","text":"<p>This test ensures that child elements from a base peripheral (PeripheralA) are correctly inherited by a derived peripheral (PeripheralB).</p> <p>Expected Outcome: The derived peripheral, PeripheralB, inherits the correct values from PeripheralA. PeripheralB should have the <code>name</code> \"PeripheralB\", <code>version</code> \"1.0\", <code>description</code> \"PeripheralA Description\", an <code>alternatePeripheral</code> of \"PeripheralC\", a <code>groupName</code> \"PeripheralsGroup\", a <code>prependToName</code> \"Prefix\", and a <code>appendToName</code> \"Suffix\". The <code>header_struct_name</code> is not inherited, which corresponds to the behavior of svdconv, but the <code>disable_condition</code> is set to <code>\"0 == 0\"</code>. Additionally, PeripheralB should have a base address of <code>0x40002000</code>, a <code>size</code> of 16 bits, <code>access</code> type of <code>WRITE_ONLY</code>, <code>protection</code> type <code>SECURE</code>, a <code>resetValue</code> of <code>0xDEADBEEF</code>, and a <code>resetMask</code> of <code>0xDEADC0DE</code>. PeripheralB has one address block starting at offset <code>0x0</code>, with a size of <code>0x1000</code> and usage for registers. PeripheralB contains no interrupts, and it correctly inherits the register <code>RegisterA</code>.</p> <p>Processable with svdconv: no - see Github issue #1796</p> Source code in <code>tests/test_process/test_peripheral_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_value_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test ensures that child elements from a base peripheral (PeripheralA) are correctly inherited by a\n    derived peripheral (PeripheralB).\n\n    **Expected Outcome:** The derived peripheral, PeripheralB, inherits the correct values from PeripheralA.\n    PeripheralB should have the `name` \"PeripheralB\", `version` \"1.0\", `description` \"PeripheralA Description\", an\n    `alternatePeripheral` of \"PeripheralC\", a `groupName` \"PeripheralsGroup\", a `prependToName` \"Prefix\", and a\n    `appendToName` \"Suffix\". The `header_struct_name` is not inherited, which corresponds to the behavior of\n    svdconv, but the `disable_condition` is set to `\"0 == 0\"`. Additionally, PeripheralB should have a base\n    address of `0x40002000`, a `size` of 16 bits, `access` type of `WRITE_ONLY`, `protection` type `SECURE`, a\n    `resetValue` of `0xDEADBEEF`, and a `resetMask` of `0xDEADC0DE`. PeripheralB has one address block starting at\n    offset `0x0`, with a size of `0x1000` and usage for registers. PeripheralB contains no interrupts, and it\n    correctly inherits the register `RegisterA`.\n\n    **Processable with svdconv:** no - see Github issue [#1796](https://github.com/Open-CMSIS-\n    Pack/devtools/issues/1796)\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"peripheral_inheritance_via_derivedfrom/value_inheritance.svd\")\n\n    assert len(device.peripherals) == 2\n    assert device.peripherals[1].name == \"PeripheralB\"\n    assert device.peripherals[1].version == \"1.0\"\n    assert device.peripherals[1].description == \"PeripheralA Description\"\n    assert device.peripherals[1].alternate_peripheral == \"PeripheralB\"\n    assert device.peripherals[1].group_name == \"PeripheralsGroup\"\n    assert device.peripherals[1].prepend_to_name == \"Prefix\"\n    assert device.peripherals[1].append_to_name == \"Suffix\"\n    assert device.peripherals[1].header_struct_name is None  # Not inherited in svdconv\n    assert device.peripherals[1].disable_condition == \"0 == 0\"\n    assert device.peripherals[1].base_address == 0x40002000\n    assert device.peripherals[1].size == 16\n    assert device.peripherals[1].access == AccessType.WRITE_ONLY\n    assert device.peripherals[1].protection == ProtectionStringType.SECURE\n    assert device.peripherals[1].reset_value == 0xDEADBEEF\n    assert device.peripherals[1].reset_mask == 0xDEADC0DE\n\n    assert len(device.peripherals[1].address_blocks) == 1\n    assert device.peripherals[1].address_blocks[0].offset == 0x0\n    assert device.peripherals[1].address_blocks[0].size == 0x1000\n    assert device.peripherals[1].address_blocks[0].usage == EnumeratedTokenType.REGISTERS\n\n    assert len(device.peripherals[1].interrupts) == 0\n\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n</code></pre> SVD file: <code>peripheral_inheritance_via_derivedfrom/value_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;value_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;version&gt;1.0&lt;/version&gt;\n      &lt;description&gt;PeripheralA Description&lt;/description&gt;\n      &lt;alternatePeripheral&gt;PeripheralB&lt;/alternatePeripheral&gt;\n      &lt;groupName&gt;PeripheralsGroup&lt;/groupName&gt;\n      &lt;prependToName&gt;Prefix&lt;/prependToName&gt;\n      &lt;appendToName&gt;Suffix&lt;/appendToName&gt;\n      &lt;headerStructName&gt;HeaderStructName&lt;/headerStructName&gt;\n      &lt;disableCondition&gt;0 == 0&lt;/disableCondition&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;size&gt;16&lt;/size&gt;\n      &lt;access&gt;write-only&lt;/access&gt;\n      &lt;protection&gt;s&lt;/protection&gt;\n      &lt;resetValue&gt;0xDEADBEEF&lt;/resetValue&gt;\n      &lt;resetMask&gt;0xDEADC0DE&lt;/resetMask&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;interrupt&gt;\n        &lt;name&gt;InterruptA&lt;/name&gt;\n        &lt;description&gt;InterruptA Description&lt;/description&gt;\n        &lt;value&gt;0&lt;/value&gt;\n      &lt;/interrupt&gt;\n      &lt;interrupt&gt;\n        &lt;name&gt;InterruptB&lt;/name&gt;\n        &lt;description&gt;InterruptB Description&lt;/description&gt;\n        &lt;value&gt;1&lt;/value&gt;\n      &lt;/interrupt&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral derivedFrom=\"PeripheralA\"&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html","title":"test_register_inheritance_via_derived_from","text":"<p>For this feature, test cases cover scenarios where a derived register inherits properties from a base register, ensuring correct behavior when values are inherited.</p>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_circular_inheritance","title":"<code>test_circular_inheritance</code>","text":"<p>This test case explores the scenario of circular inheritance, where <code>RegisterA</code> is defined to inherit from <code>RegisterB</code>, and <code>RegisterB</code> is, in turn, defined to inherit from <code>RegisterA</code>. This creates a circular reference loop, which is not a valid configuration. Circular inheritance would prevent the parser from resolving the properties of the registers correctly, as there would be no clear point of reference for the inherited attributes. The goal is to ensure that the parser detects such circular dependencies and raises an appropriate error to avoid an infinite loop or incorrect processing.</p> <p>Expected Outcome: The parser should detect the circular inheritance between <code>RegisterA</code> and <code>RegisterB</code> and raise an error. This indicates that circular inheritance is not allowed, and the parser correctly identifies and prevents it from being processed. <code>svdconv</code>, can't process the file, since deriving from <code>RegisterB</code> is not possible due to forward referencing.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Circular inheritance is not supported\")\ndef test_circular_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case explores the scenario of circular inheritance, where `RegisterA` is defined to inherit from\n    `RegisterB`, and `RegisterB` is, in turn, defined to inherit from `RegisterA`. This creates a circular\n    reference loop, which is not a valid configuration. Circular inheritance would prevent the parser from\n    resolving the properties of the registers correctly, as there would be no clear point of reference for the\n    inherited attributes. The goal is to ensure that the parser detects such circular dependencies and raises an\n    appropriate error to avoid an infinite loop or incorrect processing.\n\n    **Expected Outcome:** The parser should detect the circular inheritance between `RegisterA` and `RegisterB` and\n    raise an error. This indicates that circular inheritance is not allowed, and the parser correctly identifies\n    and prevents it from being processed. `svdconv`, can't process the file, since deriving from `RegisterB` is\n    not possible due to forward referencing.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/circular_inheritance.svd\")\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/circular_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;circular_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"RegisterB\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_derive_from_self","title":"<code>test_derive_from_self</code>","text":"<p>This test case evaluates a scenario where a register attempts to derive from itself, creating an invalid configuration. In the SVD file, <code>RegisterA</code> is defined with a <code>derivedFrom</code> attribute pointing to its own name. Such configurations should be detected as erroneous because a register cannot logically inherit properties from itself. This kind of self-reference should lead to a parsing error.</p> <p>Expected Outcome: The parser should detect the invalid self-referential inheritance and raise an error, indicating that a register cannot derive from itself. This ensures that the system handles such configurations correctly by stopping further processing and informing the user of the issue.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(strict=True, raises=ProcessException, reason=\"Can't derive from self\")\ndef test_derive_from_self(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates a scenario where a register attempts to derive from itself, creating an invalid\n    configuration. In the SVD file, `RegisterA` is defined with a `derivedFrom` attribute pointing to its own\n    name. Such configurations should be detected as erroneous because a register cannot logically inherit\n    properties from itself. This kind of self-reference should lead to a parsing error.\n\n    **Expected Outcome:** The parser should detect the invalid self-referential inheritance and raise an error,\n    indicating that a register cannot derive from itself. This ensures that the system handles such configurations\n    correctly by stopping further processing and informing the user of the issue.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/derive_from_self.svd\")\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/derive_from_self.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;derive_from_self&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_field_inheritance_overlap_bit_range","title":"<code>test_field_inheritance_overlap_bit_range</code>","text":"<p>This test case examines the scenario where a derived register (<code>RegisterB</code>) inherits <code>FieldA</code> from a base register (<code>RegisterA</code>) and attempts to define a new field (<code>FieldB</code>) that occupies an overlapping bit range as an inherited field (<code>FieldA</code>). According to the SVD standard, fields within a register must not overlap in their bit ranges, and any such conflicts should be detected and flagged as errors. This test ensures that the parser correctly identifies the overlap and raises an appropriate error.</p> <p>Expected Outcome: The parser should raise an error indicating that <code>FieldA</code> and <code>FieldB</code> cannot coexist because they overlap in their bit ranges. This behavior aligns with <code>svdconv</code>, which also detects and reports such conflicts. The parser's ability to catch this issue helps maintain the integrity of register definitions by preventing ambiguous or conflicting field configurations.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"FieldA overlaps with FieldB\",\n)\ndef test_field_inheritance_overlap_bit_range(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines the scenario where a derived register (`RegisterB`) inherits `FieldA` from a base\n    register (`RegisterA`) and attempts to define a new field (`FieldB`) that occupies an overlapping bit range as\n    an inherited field (`FieldA`). According to the SVD standard, fields within a register must not overlap in\n    their bit ranges, and any such conflicts should be detected and flagged as errors. This test ensures that the\n    parser correctly identifies the overlap and raises an appropriate error.\n\n    **Expected Outcome:** The parser should raise an error indicating that `FieldA` and `FieldB` cannot coexist\n    because they overlap in their bit ranges. This behavior aligns with `svdconv`, which also detects and reports\n    such conflicts. The parser's ability to catch this issue helps maintain the integrity of register definitions\n    by preventing ambiguous or conflicting field configurations.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/field_inheritance_overlap_bit_range.svd\")\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/field_inheritance_overlap_bit_range.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;field_inheritance_overlap_bit_range&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;2&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;4&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_field_inheritance_same_bit_range","title":"<code>test_field_inheritance_same_bit_range</code>","text":"<p>This test case examines the scenario where a derived register (<code>RegisterB</code>) inherits <code>FieldA</code> from a base register (<code>RegisterA</code>) and attempts to define a new field (<code>FieldB</code>) that occupies the same bit range as an inherited field (<code>FieldA</code>). According to the SVD standard, fields within a register must not overlap in their bit ranges, and any such conflicts should be detected and flagged as errors. This test ensures that the parser correctly identifies the overlap and raises an appropriate error.</p> <p>Expected Outcome: The parser should raise an error indicating that <code>FieldA</code> and <code>FieldB</code> cannot coexist because they overlap in their bit ranges. This behavior aligns with <code>svdconv</code>, which also detects and reports such conflicts. The parser's ability to catch this issue helps maintain the integrity of register definitions by preventing ambiguous or conflicting field configurations.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"FieldA overlaps with FieldB\",\n)\ndef test_field_inheritance_same_bit_range(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines the scenario where a derived register (`RegisterB`) inherits `FieldA` from a base\n    register (`RegisterA`) and attempts to define a new field (`FieldB`) that occupies the same bit range as an\n    inherited field (`FieldA`). According to the SVD standard, fields within a register must not overlap in their\n    bit ranges, and any such conflicts should be detected and flagged as errors. This test ensures that the parser\n    correctly identifies the overlap and raises an appropriate error.\n\n    **Expected Outcome:** The parser should raise an error indicating that `FieldA` and `FieldB` cannot coexist\n    because they overlap in their bit ranges. This behavior aligns with `svdconv`, which also detects and reports\n    such conflicts. The parser's ability to catch this issue helps maintain the integrity of register definitions\n    by preventing ambiguous or conflicting field configurations.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/field_inheritance_same_bit_range.svd\")\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/field_inheritance_same_bit_range.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;field_inheritance_same_bit_range&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_field_inheritance_same_name","title":"<code>test_field_inheritance_same_name</code>","text":"<p>This test case evaluates the behavior of field inheritance when a derived register (<code>RegisterB</code>) attempts to define a field (<code>FieldA</code>) that shares the same name as a field inherited from its base register (<code>RegisterA</code>). According to SVD specifications, each field within a register should have a unique name, and inheriting a field with the same name as an existing field in the derived register leads to a conflict. The goal of this test is to ensure that the parser detects this scenario and raises an appropriate error.</p> <p>Expected Outcome: The parser should raise an error, indicating that <code>FieldA</code> cannot be redefined in <code>RegisterB</code> because it already exists in the inherited properties from <code>RegisterA</code>. This behavior prevents conflicts in field definitions and maintains the integrity of the register's structure. Like <code>svdconv</code>, which also throws an error in this situation, the parser's explicit handling of this case ensures that users are clearly informed about the issue, guiding them to resolve such naming conflicts in their SVD files.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.xfail(\n    strict=True,\n    raises=ProcessException,\n    reason=\"FieldA is already defined in RegisterA and cannot be inherited because it has the same name\",\n)\ndef test_field_inheritance_same_name(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates the behavior of field inheritance when a derived register (`RegisterB`) attempts to\n    define a field (`FieldA`) that shares the same name as a field inherited from its base register (`RegisterA`).\n    According to SVD specifications, each field within a register should have a unique name, and inheriting a\n    field with the same name as an existing field in the derived register leads to a conflict. The goal of this\n    test is to ensure that the parser detects this scenario and raises an appropriate error.\n\n    **Expected Outcome:** The parser should raise an error, indicating that `FieldA` cannot be redefined in\n    `RegisterB` because it already exists in the inherited properties from `RegisterA`. This behavior prevents\n    conflicts in field definitions and maintains the integrity of the register's structure. Like `svdconv`, which\n    also throws an error in this situation, the parser's explicit handling of this case ensures that users are\n    clearly informed about the issue, guiding them to resolve such naming conflicts in their SVD files.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/field_inheritance_same_name.svd\")\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/field_inheritance_same_name.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;field_inheritance_same_name&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;3&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;2&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_multiple_inheritance_backward_reference","title":"<code>test_multiple_inheritance_backward_reference</code>","text":"<p>This test case evaluates the functionality of register inheritance when multiple derived registers inherit from a base register via backward references. In this scenario, <code>RegisterA</code> is defined as the base register with a specific set of attributes, including fields. <code>RegisterB</code> inherits from <code>RegisterA</code>, and <code>RegisterC</code> subsequently inherits from <code>RegisterB</code>. This chain of backward references ensures that <code>RegisterC</code> ultimately inherits properties from <code>RegisterA</code> through <code>RegisterB</code>. The SVD file clearly defines the inheritance structure, allowing each derived register to have a distinct address offset while maintaining the core properties from the base register.</p> <p>Expected Outcome: The parser should correctly interpret the inheritance chain, ensuring that both <code>RegisterB</code> and <code>RegisterC</code> inherit all attributes from <code>RegisterA</code>. This means that <code>RegisterB</code> and <code>RegisterC</code> should have the same field (<code>FieldA</code> with bits 0 to 2) as defined in <code>RegisterA</code>. Each register should be positioned at their respective address offsets (<code>0x0</code> for <code>RegisterA</code>, <code>0x4</code> for <code>RegisterB</code>, and <code>0x8</code> for <code>RegisterC</code>) with a size of 32 bits. The parsing should be consistent with the expected behavior of <code>svdconv</code>, which handles such backward reference chains correctly.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_backward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates the functionality of register inheritance when multiple derived registers inherit\n    from a base register via backward references. In this scenario, `RegisterA` is defined as the base register\n    with a specific set of attributes, including fields. `RegisterB` inherits from `RegisterA`, and `RegisterC`\n    subsequently inherits from `RegisterB`. This chain of backward references ensures that `RegisterC` ultimately\n    inherits properties from `RegisterA` through `RegisterB`. The SVD file clearly defines the inheritance\n    structure, allowing each derived register to have a distinct address offset while maintaining the core\n    properties from the base register.\n\n    **Expected Outcome:** The parser should correctly interpret the inheritance chain, ensuring that both `RegisterB`\n    and `RegisterC` inherit all attributes from `RegisterA`. This means that `RegisterB` and `RegisterC` should\n    have the same field (`FieldA` with bits 0 to 2) as defined in `RegisterA`. Each register should be positioned\n    at their respective address offsets (`0x0` for `RegisterA`, `0x4` for `RegisterB`, and `0x8` for `RegisterC`)\n    with a size of 32 bits. The parsing should be consistent with the expected behavior of `svdconv`, which\n    handles such backward reference chains correctly.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"register_inheritance_via_derivedfrom/multiple_inheritance_backward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Register)\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterC\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[2].size == 32\n    assert len(device.peripherals[0].registers_clusters[2].fields) == 1\n    assert device.peripherals[0].registers_clusters[2].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[2].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[2].fields[0].msb == 2\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/multiple_inheritance_backward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_inheritance_backward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterB\"&gt;\n          &lt;name&gt;RegisterC&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_multiple_inheritance_forward_reference","title":"<code>test_multiple_inheritance_forward_reference</code>","text":"<p>This test case examines the scenario of register inheritance using forward references. Here, <code>RegisterA</code> is defined to inherit from <code>RegisterB</code>, which in turn is defined to inherit from <code>RegisterC</code>. The SVD file specifies these registers in a sequence where <code>RegisterC</code> is defined last, creating a chain of forward references. The objective is to verify if the parser can correctly resolve these references and apply the inheritance as intended. Each derived register should inherit properties from the subsequent one in the chain, even though they are defined in a forward manner.</p> <p>Expected Outcome: The parser should successfully process the SVD file, correctly handling the forward references and applying the inheritance chain. This means that <code>RegisterA</code> should ultimately inherit properties from <code>RegisterC</code> via <code>RegisterB</code>, despite being defined earlier in the file. Each register should have the same field structure inherited from <code>RegisterC</code>, with <code>FieldA</code> occupying bits 0 to 2. The registers should appear at their respective address offsets: <code>0x0</code> for <code>RegisterA</code>, <code>0x4</code> for <code>RegisterB</code>, and <code>0x8</code> for <code>RegisterC</code>, all with a size of 32 bits. While <code>svdconv</code> does not handle such forward references, the parser should complete this without errors.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_multiple_inheritance_forward_reference(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines the scenario of register inheritance using forward references. Here, `RegisterA` is\n    defined to inherit from `RegisterB`, which in turn is defined to inherit from `RegisterC`. The SVD file\n    specifies these registers in a sequence where `RegisterC` is defined last, creating a chain of forward\n    references. The objective is to verify if the parser can correctly resolve these references and apply the\n    inheritance as intended. Each derived register should inherit properties from the subsequent one in the chain,\n    even though they are defined in a forward manner.\n\n    **Expected Outcome:** The parser should successfully process the SVD file, correctly handling the forward\n    references and applying the inheritance chain. This means that `RegisterA` should ultimately inherit\n    properties from `RegisterC` via `RegisterB`, despite being defined earlier in the file. Each register should\n    have the same field structure inherited from `RegisterC`, with `FieldA` occupying bits 0 to 2. The registers\n    should appear at their respective address offsets: `0x0` for `RegisterA`, `0x4` for `RegisterB`, and `0x8` for\n    `RegisterC`, all with a size of 32 bits. While `svdconv` does not handle such forward references, the parser\n    should complete this without errors.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"register_inheritance_via_derivedfrom/multiple_inheritance_forward_reference.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Register)\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterC\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[2].size == 32\n    assert len(device.peripherals[0].registers_clusters[2].fields) == 1\n    assert device.peripherals[0].registers_clusters[2].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[2].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[2].fields[0].msb == 2\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/multiple_inheritance_forward_reference.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;multiple_inheritance_forward_reference&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"RegisterB\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterC\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterC&lt;/name&gt;\n          &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_override_behavior","title":"<code>test_override_behavior</code>","text":"<p>This test case examines the use of the <code>derivedFrom</code> attribute to inherit properties from a base register while allowing for selective overrides. In this scenario, <code>RegisterB</code> is defined to inherit properties from <code>RegisterA</code>, but several attributes are explicitly overridden. The SVD file defines <code>RegisterA</code> with a comprehensive set of attributes, including size, access type, reset values, and field details. <code>RegisterB</code> inherits these attributes via <code>derivedFrom</code>, but overrides certain properties such as size, description, access type, and field structure.</p> <p>Expected Outcome: The parser should correctly process <code>RegisterB</code>, inheriting all attributes from <code>RegisterA</code> except those that are explicitly overridden in <code>RegisterB</code>. This means that <code>RegisterB</code> should retain properties like <code>alternateRegister</code>, <code>resetValue</code>, and <code>fields</code> from <code>RegisterA</code> unless a different value is specified. For example, <code>RegisterB</code> should inherit the field <code>FieldA</code> from <code>RegisterA</code> but should also introduce a new field, <code>FieldB</code>. The parser should handle this inheritance and overriding mechanism seamlessly, producing a result where <code>RegisterA</code> and <code>RegisterB</code> are distinct yet connected through shared properties. This behavior matches the expected output from <code>svdconv</code>, which processes similar cases without issues.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_override_behavior(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines the use of the `derivedFrom` attribute to inherit properties from a base register\n    while allowing for selective overrides. In this scenario, `RegisterB` is defined to inherit properties from\n    `RegisterA`, but several attributes are explicitly overridden. The SVD file defines `RegisterA` with a\n    comprehensive set of attributes, including size, access type, reset values, and field details. `RegisterB`\n    inherits these attributes via `derivedFrom`, but overrides certain properties such as size, description,\n    access type, and field structure.\n\n    **Expected Outcome:** The parser should correctly process `RegisterB`, inheriting all attributes from `RegisterA`\n    except those that are explicitly overridden in `RegisterB`. This means that `RegisterB` should retain\n    properties like `alternateRegister`, `resetValue`, and `fields` from `RegisterA` unless a different value is\n    specified. For example, `RegisterB` should inherit the field `FieldA` from `RegisterA` but should also\n    introduce a new field, `FieldB`. The parser should handle this inheritance and overriding mechanism\n    seamlessly, producing a result where `RegisterA` and `RegisterB` are distinct yet connected through shared\n    properties. This behavior matches the expected output from `svdconv`, which processes similar cases without\n    issues.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/override_behavior.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].display_name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].description == \"RegisterA description\"\n    assert device.peripherals[0].registers_clusters[0].alternate_register == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 16\n    assert device.peripherals[0].registers_clusters[0].access == AccessType.READ_ONLY\n    assert device.peripherals[0].registers_clusters[0].protection == ProtectionStringType.SECURE\n    assert device.peripherals[0].registers_clusters[0].reset_value == 0xDEAD\n    assert device.peripherals[0].registers_clusters[0].reset_mask == 0xC0DE\n    assert device.peripherals[0].registers_clusters[0].data_type == DataTypeType.UINT32_T\n    assert device.peripherals[0].registers_clusters[0].modified_write_values == ModifiedWriteValuesType.ONE_TO_CLEAR\n    assert device.peripherals[0].registers_clusters[0].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[0].write_constraint.write_as_read is True\n    assert device.peripherals[0].registers_clusters[0].read_action == ReadActionType.MODIFY\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n    assert device.peripherals[0].registers_clusters[0].fields[0].access == AccessType.READ_ONLY\n    assert device.peripherals[0].registers_clusters[0].fields[0].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[0].fields[0].write_constraint.write_as_read is True\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].display_name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].description == \"RegisterB description\"\n    assert device.peripherals[0].registers_clusters[1].alternate_register == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].size == 8\n    assert device.peripherals[0].registers_clusters[1].access == AccessType.WRITE_ONLY\n    assert device.peripherals[0].registers_clusters[1].protection == ProtectionStringType.NON_SECURE\n    assert device.peripherals[0].registers_clusters[1].reset_value == 0xAB\n    assert device.peripherals[0].registers_clusters[1].reset_mask == 0xDE\n    assert device.peripherals[0].registers_clusters[1].data_type == DataTypeType.UINT8_T\n    assert device.peripherals[0].registers_clusters[1].modified_write_values == ModifiedWriteValuesType.ONE_TO_SET\n    assert device.peripherals[0].registers_clusters[1].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[1].write_constraint.use_enumerated_values is True\n    assert device.peripherals[0].registers_clusters[1].read_action == ReadActionType.SET\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 2\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 2\n    assert device.peripherals[0].registers_clusters[1].fields[0].access == AccessType.WRITE_ONLY\n    assert device.peripherals[0].registers_clusters[1].fields[0].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[1].fields[0].write_constraint.use_enumerated_values is True\n    assert device.peripherals[0].registers_clusters[1].fields[1].name == \"FieldB\"\n    assert device.peripherals[0].registers_clusters[1].fields[1].lsb == 3\n    assert device.peripherals[0].registers_clusters[1].fields[1].msb == 4\n    assert device.peripherals[0].registers_clusters[1].fields[1].access == AccessType.WRITE_ONLY\n    assert device.peripherals[0].registers_clusters[1].fields[1].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[1].fields[1].write_constraint.use_enumerated_values is True\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/override_behavior.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;override_behavior&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;displayName&gt;RegisterA&lt;/displayName&gt;\n          &lt;description&gt;RegisterA description&lt;/description&gt;\n          &lt;alternateRegister&gt;RegisterB&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n          &lt;access&gt;read-only&lt;/access&gt;\n          &lt;protection&gt;s&lt;/protection&gt;\n          &lt;resetValue&gt;0xDEAD&lt;/resetValue&gt;\n          &lt;resetMask&gt;0xC0DE&lt;/resetMask&gt;\n          &lt;dataType&gt;uint32_t&lt;/dataType&gt;\n          &lt;modifiedWriteValues&gt;oneToClear&lt;/modifiedWriteValues&gt;\n          &lt;writeConstraint&gt;\n            &lt;writeAsRead&gt;true&lt;/writeAsRead&gt;\n          &lt;/writeConstraint&gt;\n          &lt;readAction&gt;modify&lt;/readAction&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;displayName&gt;RegisterB&lt;/displayName&gt;\n          &lt;description&gt;RegisterB description&lt;/description&gt;\n          &lt;alternateRegister&gt;RegisterA&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;size&gt;8&lt;/size&gt;\n          &lt;access&gt;write-only&lt;/access&gt;\n          &lt;protection&gt;n&lt;/protection&gt;\n          &lt;resetValue&gt;0xAB&lt;/resetValue&gt;\n          &lt;resetMask&gt;0xDE&lt;/resetMask&gt;\n          &lt;dataType&gt;uint8_t&lt;/dataType&gt;\n          &lt;modifiedWriteValues&gt;oneToSet&lt;/modifiedWriteValues&gt;\n          &lt;writeConstraint&gt;\n            &lt;useEnumeratedValues&gt;true&lt;/useEnumeratedValues&gt;\n          &lt;/writeConstraint&gt;\n          &lt;readAction&gt;set&lt;/readAction&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldB&lt;/name&gt;\n              &lt;bitOffset&gt;3&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;2&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_register_overlap","title":"<code>test_register_overlap</code>","text":"<p>This test case addresses a situation where two registers, <code>RegisterA</code> and <code>RegisterB</code>, have overlapping address spaces within the same peripheral. In this example, <code>RegisterB</code> is derived from <code>RegisterA</code> but is defined at an address offset (<code>0x2</code>) that causes it to overlap partially with <code>RegisterA</code>. While such overlaps can lead to conflicts, <code>svdconv</code> issues a warning rather than an error to maintain compatibility with older <code>svdconv</code> versions, which have not detected overlapping addresses. A robust parser implementation should mimic this behavior, issuing a warning to inform the user of the overlap but still proceed with processing the file.</p> <p>Expected Outcome: The parser should successfully process the SVD file but issue a warning indicating the address overlap between <code>RegisterA</code> and <code>RegisterB</code>. This approach maintains compatibility with existing tools like <code>svdconv</code>, which handle such scenarios by warning the user rather than blocking the processing altogether.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>def test_register_overlap(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case addresses a situation where two registers, `RegisterA` and `RegisterB`, have overlapping\n    address spaces within the same peripheral. In this example, `RegisterB` is derived from `RegisterA` but is\n    defined at an address offset (`0x2`) that causes it to overlap partially with `RegisterA`. While such overlaps\n    can lead to conflicts, `svdconv` issues a warning rather than an error to maintain compatibility with older\n    `svdconv` versions, which have not detected overlapping addresses. A robust parser implementation should mimic\n    this behavior, issuing a warning to inform the user of the overlap but still proceed with processing the file.\n\n    **Expected Outcome:** The parser should successfully process the SVD file but issue a warning indicating the\n    address overlap between `RegisterA` and `RegisterB`. This approach maintains compatibility with existing tools\n    like `svdconv`, which handle such scenarios by warning the user rather than blocking the processing\n    altogether.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/register_overlap.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].size == 16\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 2\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/register_overlap.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;register_overlap&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_same_address","title":"<code>test_same_address</code>","text":"<p>This test case explores a scenario where two registers, <code>RegisterA</code> and <code>RegisterB</code>, share the same address offset within the same peripheral. The <code>RegisterB</code> is derived from <code>RegisterA</code>, meaning it inherits its configuration but is defined at the same address (<code>0x0</code>). According to the SVD standard, multiple registers should not occupy the same address space unless they have an alternate relationship, and <code>svdconv</code> enforces this rule by issuing an error. However, for enhanced compatibility, especially with older <code>svdconv</code> versions, it may be advisable to allow such configurations while issuing a warning instead of an outright error.</p> <p>Expected Outcome: The parser should issue a warning indicating that <code>RegisterA</code> and <code>RegisterB</code> share the same address offset, but it should still successfully process the SVD file. This approach aligns with the idea of maintaining compatibility with various SVD formats, including older versions where multiple registers might share the same address. Although <code>svdconv</code> would reject this file outright, a more flexible parser should permit it while clearly warning users of the potential conflict.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>def test_same_address(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case explores a scenario where two registers, `RegisterA` and `RegisterB`, share the same address\n    offset within the same peripheral. The `RegisterB` is derived from `RegisterA`, meaning it inherits its\n    configuration but is defined at the same address (`0x0`). According to the SVD standard, multiple registers\n    should not occupy the same address space unless they have an alternate relationship, and `svdconv` enforces\n    this rule by issuing an error. However, for enhanced compatibility, especially with older `svdconv` versions,\n    it may be advisable to allow such configurations while issuing a warning instead of an outright error.\n\n    **Expected Outcome:** The parser should issue a warning indicating that `RegisterA` and `RegisterB` share the same\n    address offset, but it should still successfully process the SVD file. This approach aligns with the idea of\n    maintaining compatibility with various SVD formats, including older versions where multiple registers might\n    share the same address. Although `svdconv` would reject this file outright, a more flexible parser should\n    permit it while clearly warning users of the potential conflict.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/same_address.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 2\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/same_address.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;same_address&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_simple_inheritance_backward_reference_different_scope","title":"<code>test_simple_inheritance_backward_reference_different_scope</code>","text":"<p>This test case evaluates the behavior of register inheritance using the <code>derivedFrom</code> attribute when the base register is defined within a different peripheral. In the SVD file, <code>RegisterA</code> is defined within <code>PeripheralA</code>, located at base address <code>0x40001000</code>. This register contains a field named <code>FieldA</code>, occupying bits 0 through 2. In <code>PeripheralB</code>, which has a different base address (<code>0x40002000</code>), another <code>RegisterA</code> is defined that uses the <code>derivedFrom</code> attribute to inherit all properties from <code>PeripheralA.RegisterA</code>.</p> <p>Expected Outcome: The parser should correctly process the SVD file, recognizing that <code>PeripheralB.RegisterA</code> inherits all attributes from <code>PeripheralA.RegisterA</code>, including the field definition <code>FieldA</code>. Both registers should have identical structures, with the derived register correctly inheriting the properties from its base, even though they are defined in separate peripherals. The parsing should be consistent with <code>svdconv</code>, which successfully handles this cross-scope backward reference, resulting in <code>RegisterA</code> in <code>PeripheralB</code> being properly inherited and recognized without issues.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_backward_reference_different_scope(\n    get_processed_device_from_testfile: Callable[[str], Device]\n):\n    \"\"\"\n    This test case evaluates the behavior of register inheritance using the `derivedFrom` attribute when the base\n    register is defined within a different peripheral. In the SVD file, `RegisterA` is defined within\n    `PeripheralA`, located at base address `0x40001000`. This register contains a field named `FieldA`, occupying\n    bits 0 through 2. In `PeripheralB`, which has a different base address (`0x40002000`), another `RegisterA` is\n    defined that uses the `derivedFrom` attribute to inherit all properties from `PeripheralA.RegisterA`.\n\n    **Expected Outcome:** The parser should correctly process the SVD file, recognizing that `PeripheralB.RegisterA`\n    inherits all attributes from `PeripheralA.RegisterA`, including the field definition `FieldA`. Both registers\n    should have identical structures, with the derived register correctly inheriting the properties from its base,\n    even though they are defined in separate peripherals. The parsing should be consistent with `svdconv`, which\n    successfully handles this cross-scope backward reference, resulting in `RegisterA` in `PeripheralB` being\n    properly inherited and recognized without issues.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"register_inheritance_via_derivedfrom/simple_inheritance_backward_reference_different_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n    assert len(device.peripherals[1].registers_clusters[0].fields) == 1\n    assert device.peripherals[1].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[1].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[1].registers_clusters[0].fields[0].msb == 2\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/simple_inheritance_backward_reference_different_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_backward_reference_different_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"PeripheralA.RegisterA\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_simple_inheritance_backward_reference_same_scope","title":"<code>test_simple_inheritance_backward_reference_same_scope</code>","text":"<p>This test case evaluates the behavior of register inheritance using the <code>derivedFrom</code> attribute within the same peripheral scope. The scenario involves <code>RegisterB</code> inheriting properties from <code>RegisterA</code>, which has been defined earlier in the same scope. In the provided SVD file, <code>RegisterA</code> is explicitly defined with an address offset of <code>0x0</code>, and it contains a field named <code>FieldA</code> occupying bits 0 through 2. <code>RegisterB</code> is defined to inherit from <code>RegisterA</code> via the <code>derivedFrom</code> attribute, while being located at a different address offset (<code>0x4</code>).</p> <p>Expected Outcome: The parser should successfully process the SVD file, recognizing <code>RegisterB</code> as inheriting all attributes from <code>RegisterA</code>. This includes the field <code>FieldA</code> with the same bit positioning (bits 0 to 2). <code>RegisterA</code> should appear at address offset <code>0x0</code> and <code>RegisterB</code> at <code>0x4</code>, both having a size of 32 bits and containing an identical field structure. The parsing should complete without any issues, consistent with the expected behavior of <code>svdconv</code>, which correctly handles backward references within the same scope.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_backward_reference_same_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case evaluates the behavior of register inheritance using the `derivedFrom` attribute within the\n    same peripheral scope. The scenario involves `RegisterB` inheriting properties from `RegisterA`, which has\n    been defined earlier in the same scope. In the provided SVD file, `RegisterA` is explicitly defined with an\n    address offset of `0x0`, and it contains a field named `FieldA` occupying bits 0 through 2. `RegisterB` is\n    defined to inherit from `RegisterA` via the `derivedFrom` attribute, while being located at a different\n    address offset (`0x4`).\n\n    **Expected Outcome:** The parser should successfully process the SVD file, recognizing `RegisterB` as inheriting\n    all attributes from `RegisterA`. This includes the field `FieldA` with the same bit positioning (bits 0 to 2).\n    `RegisterA` should appear at address offset `0x0` and `RegisterB` at `0x4`, both having a size of 32 bits and\n    containing an identical field structure. The parsing should complete without any issues, consistent with the\n    expected behavior of `svdconv`, which correctly handles backward references within the same scope.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"register_inheritance_via_derivedfrom/simple_inheritance_backward_reference_same_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 2\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/simple_inheritance_backward_reference_same_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_backward_reference_same_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_simple_inheritance_forward_reference_different_scope","title":"<code>test_simple_inheritance_forward_reference_different_scope</code>","text":"<p>This test case explores the behavior of register inheritance using the <code>derivedFrom</code> attribute when a derived register attempts to inherit from a base register defined in a different peripheral that appears later in the file. Specifically, <code>PeripheralA.RegisterA</code> is set to inherit from <code>PeripheralB.RegisterA</code>, even though <code>PeripheralB</code> is defined after <code>PeripheralA</code> in the SVD file. The base register <code>PeripheralB.RegisterA</code> contains a field named <code>FieldA</code> located at bits 0 through 2, and it is defined at address offset <code>0x0</code> within <code>PeripheralB</code>.</p> <p>Expected Outcome: The parser should be able to correctly handle this forward reference, recognizing that <code>PeripheralA.RegisterA</code> inherits all attributes from <code>PeripheralB.RegisterA</code>, including the field <code>FieldA</code>. Both registers should maintain identical structures, and the derived register should accurately reflect the inherited properties, despite the forward reference. Unlike <code>svdconv</code>, which cannot process this type of forward reference across different scopes and would produce an error, the parser is expected to resolve this relationship correctly, ensuring <code>RegisterA</code> in <code>PeripheralA</code> is properly inherited from <code>PeripheralB.RegisterA</code> without any issues.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_forward_reference_different_scope(\n    get_processed_device_from_testfile: Callable[[str], Device]\n):\n    \"\"\"\n    This test case explores the behavior of register inheritance using the `derivedFrom` attribute when a derived\n    register attempts to inherit from a base register defined in a different peripheral that appears later in the\n    file. Specifically, `PeripheralA.RegisterA` is set to inherit from `PeripheralB.RegisterA`, even though\n    `PeripheralB` is defined after `PeripheralA` in the SVD file. The base register `PeripheralB.RegisterA`\n    contains a field named `FieldA` located at bits 0 through 2, and it is defined at address offset `0x0` within\n    `PeripheralB`.\n\n    **Expected Outcome:** The parser should be able to correctly handle this forward reference, recognizing that\n    `PeripheralA.RegisterA` inherits all attributes from `PeripheralB.RegisterA`, including the field `FieldA`.\n    Both registers should maintain identical structures, and the derived register should accurately reflect the\n    inherited properties, despite the forward reference. Unlike `svdconv`, which cannot process this type of\n    forward reference across different scopes and would produce an error, the parser is expected to resolve this\n    relationship correctly, ensuring `RegisterA` in `PeripheralA` is properly inherited from\n    `PeripheralB.RegisterA` without any issues.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"register_inheritance_via_derivedfrom/simple_inheritance_forward_reference_different_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 2\n\n    assert len(device.peripherals[0].registers_clusters) == 1\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n\n    assert len(device.peripherals[1].registers_clusters) == 1\n    assert isinstance(device.peripherals[1].registers_clusters[0], Register)\n    assert device.peripherals[1].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[1].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[1].registers_clusters[0].size == 32\n    assert len(device.peripherals[1].registers_clusters[0].fields) == 1\n    assert device.peripherals[1].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[1].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[1].registers_clusters[0].fields[0].msb == 2\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/simple_inheritance_forward_reference_different_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_forward_reference_different_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"PeripheralB.RegisterA\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralB&lt;/name&gt;\n      &lt;baseAddress&gt;0x40002000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_simple_inheritance_forward_reference_same_scope","title":"<code>test_simple_inheritance_forward_reference_same_scope</code>","text":"<p>This test case examines the handling of register inheritance using the <code>derivedFrom</code> attribute when the base register is defined later in the same peripheral scope. Here, <code>RegisterA</code> is defined to inherit from <code>RegisterB</code>, even though <code>RegisterB</code> appears afterward in the SVD file. This setup tests the parser's ability to resolve forward references, where the derived register (<code>RegisterA</code>) relies on properties that are specified only after its own definition. In the provided SVD file, <code>RegisterA</code> uses the <code>derivedFrom</code> attribute to inherit from <code>RegisterB</code>, which is defined with an address offset of <code>0x4</code> and contains a field named <code>FieldA</code>. <code>RegisterA</code> should inherit all properties of <code>RegisterB</code>, while occupying its own distinct address offset (<code>0x0</code>).</p> <p>Expected Outcome: The parser should correctly handle the forward reference, resolving <code>RegisterA</code>'s inheritance from <code>RegisterB</code> and applying all relevant properties. <code>RegisterA</code> should have the same field structure as <code>RegisterB</code>, including <code>FieldA</code> occupying bits 0 through 2. Both registers should be correctly recognized, with <code>RegisterA</code> located at address offset <code>0x0</code> and <code>RegisterB</code> at <code>0x4</code>, each with a size of 32 bits. Unlike <code>svdconv</code>, which cannot handle forward references and raises an error, the parser should resolve this scenario seamlessly.</p> <p>Processable with svdconv: no</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_inheritance_forward_reference_same_scope(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines the handling of register inheritance using the `derivedFrom` attribute when the base\n    register is defined later in the same peripheral scope. Here, `RegisterA` is defined to inherit from\n    `RegisterB`, even though `RegisterB` appears afterward in the SVD file. This setup tests the parser's ability\n    to resolve forward references, where the derived register (`RegisterA`) relies on properties that are\n    specified only after its own definition. In the provided SVD file, `RegisterA` uses the `derivedFrom`\n    attribute to inherit from `RegisterB`, which is defined with an address offset of `0x4` and contains a field\n    named `FieldA`. `RegisterA` should inherit all properties of `RegisterB`, while occupying its own distinct\n    address offset (`0x0`).\n\n    **Expected Outcome:** The parser should correctly handle the forward reference, resolving `RegisterA`'s\n    inheritance from `RegisterB` and applying all relevant properties. `RegisterA` should have the same field\n    structure as `RegisterB`, including `FieldA` occupying bits 0 through 2. Both registers should be correctly\n    recognized, with `RegisterA` located at address offset `0x0` and `RegisterB` at `0x4`, each with a size of 32\n    bits. Unlike `svdconv`, which cannot handle forward references and raises an error, the parser should resolve\n    this scenario seamlessly.\n\n    **Processable with svdconv:** no\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\n        \"register_inheritance_via_derivedfrom/simple_inheritance_forward_reference_same_scope.svd\"\n    )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 32\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 32\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 2\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/simple_inheritance_forward_reference_same_scope.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_inheritance_forward_reference_same_scope&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register derivedFrom=\"RegisterB\"&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_register_inheritance_via_derived_from.html#tests.test_process.test_register_inheritance_via_derived_from.test_value_inheritance","title":"<code>test_value_inheritance</code>","text":"<p>This test case examines how the <code>derivedFrom</code> attribute is used to inherit register properties, focusing on a scenario where <code>RegisterB</code> inherits multiple attributes from <code>RegisterA</code>. In the provided SVD file, <code>RegisterA</code> is defined with a wide range of attributes, including display name, description, access type, size, protection level, and more. <code>RegisterB</code> is set to inherit from <code>RegisterA</code> while having a distinct address offset of <code>0x2</code>. The test ensures that <code>RegisterB</code> correctly inherits all properties of <code>RegisterA</code> except for the explicitly overridden attributes. A special case is the attribute <code>displayName</code>. Although it is also inherited, it is only allowed to appear once within the scope. Therefore, it must be explicitly overridden in <code>RegisterB</code>.</p> <p>Expected Outcome: The parser should successfully process the SVD file and recognize that <code>RegisterB</code> inherits all applicable properties from <code>RegisterA</code>. This includes attributes such as the display name, description, size, access type, and protection level, among others. <code>RegisterA</code> should be located at address offset <code>0x0</code>, while <code>RegisterB</code> should be at <code>0x2</code>, both with the same attributes and configurations. The inherited properties should match precisely, reflecting accurate inheritance behavior. This is consistent with <code>svdconv</code>, which also handles this scenario correctly without any issues.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_register_inheritance_via_derived_from.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_value_inheritance(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test case examines how the `derivedFrom` attribute is used to inherit register properties, focusing on a\n    scenario where `RegisterB` inherits multiple attributes from `RegisterA`. In the provided SVD file,\n    `RegisterA` is defined with a wide range of attributes, including display name, description, access type,\n    size, protection level, and more. `RegisterB` is set to inherit from `RegisterA` while having a distinct\n    address offset of `0x2`. The test ensures that `RegisterB` correctly inherits all properties of `RegisterA`\n    except for the explicitly overridden attributes. A special case is the attribute `displayName`. Although it is\n    also inherited, it is only allowed to appear once within the scope. Therefore, it must be explicitly\n    overridden in `RegisterB`.\n\n    **Expected Outcome:** The parser should successfully process the SVD file and recognize that `RegisterB` inherits\n    all applicable properties from `RegisterA`. This includes attributes such as the display name, description,\n    size, access type, and protection level, among others. `RegisterA` should be located at address offset `0x0`,\n    while `RegisterB` should be at `0x2`, both with the same attributes and configurations. The inherited\n    properties should match precisely, reflecting accurate inheritance behavior. This is consistent with\n    `svdconv`, which also handles this scenario correctly without any issues.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"register_inheritance_via_derivedfrom/value_inheritance.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].display_name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].description == \"RegisterA description\"\n    assert device.peripherals[0].registers_clusters[0].alternate_register == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 16\n    assert device.peripherals[0].registers_clusters[0].access == AccessType.READ_ONLY\n    assert device.peripherals[0].registers_clusters[0].protection == ProtectionStringType.SECURE\n    assert device.peripherals[0].registers_clusters[0].reset_value == 0xDEAD\n    assert device.peripherals[0].registers_clusters[0].reset_mask == 0xC0DE\n    assert device.peripherals[0].registers_clusters[0].data_type == DataTypeType.UINT32_T\n    assert device.peripherals[0].registers_clusters[0].modified_write_values == ModifiedWriteValuesType.ONE_TO_CLEAR\n    assert device.peripherals[0].registers_clusters[0].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[0].write_constraint.write_as_read is True\n    assert device.peripherals[0].registers_clusters[0].read_action == ReadActionType.MODIFY\n    assert len(device.peripherals[0].registers_clusters[0].fields) == 1\n    assert device.peripherals[0].registers_clusters[0].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[0].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[0].fields[0].msb == 2\n    assert device.peripherals[0].registers_clusters[0].fields[0].access == AccessType.READ_ONLY\n    assert device.peripherals[0].registers_clusters[0].fields[0].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[0].fields[0].write_constraint.write_as_read is True\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].display_name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].description == \"RegisterA description\"\n    assert device.peripherals[0].registers_clusters[1].alternate_register == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x2\n    assert device.peripherals[0].registers_clusters[1].size == 16\n    assert device.peripherals[0].registers_clusters[1].access == AccessType.READ_ONLY\n    assert device.peripherals[0].registers_clusters[1].protection == ProtectionStringType.SECURE\n    assert device.peripherals[0].registers_clusters[1].reset_value == 0xDEAD\n    assert device.peripherals[0].registers_clusters[1].reset_mask == 0xC0DE\n    assert device.peripherals[0].registers_clusters[1].data_type == DataTypeType.UINT32_T\n    assert device.peripherals[0].registers_clusters[1].modified_write_values == ModifiedWriteValuesType.ONE_TO_CLEAR\n    assert device.peripherals[0].registers_clusters[1].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[1].write_constraint.write_as_read is True\n    assert device.peripherals[0].registers_clusters[1].read_action == ReadActionType.MODIFY\n    assert len(device.peripherals[0].registers_clusters[1].fields) == 1\n    assert device.peripherals[0].registers_clusters[1].fields[0].name == \"FieldA\"\n    assert device.peripherals[0].registers_clusters[1].fields[0].lsb == 0\n    assert device.peripherals[0].registers_clusters[1].fields[0].msb == 2\n    assert device.peripherals[0].registers_clusters[1].fields[0].access == AccessType.READ_ONLY\n    assert device.peripherals[0].registers_clusters[1].fields[0].write_constraint is not None\n    assert device.peripherals[0].registers_clusters[1].fields[0].write_constraint.write_as_read is True\n</code></pre> SVD file: <code>register_inheritance_via_derivedfrom/value_inheritance.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;value_inheritance&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;displayName&gt;RegisterA&lt;/displayName&gt;\n          &lt;description&gt;RegisterA description&lt;/description&gt;\n          &lt;alternateRegister&gt;RegisterA&lt;/alternateRegister&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;size&gt;16&lt;/size&gt;\n          &lt;access&gt;read-only&lt;/access&gt;\n          &lt;protection&gt;s&lt;/protection&gt;\n          &lt;resetValue&gt;0xDEAD&lt;/resetValue&gt;\n          &lt;resetMask&gt;0xC0DE&lt;/resetMask&gt;\n          &lt;dataType&gt;uint32_t&lt;/dataType&gt;\n          &lt;modifiedWriteValues&gt;oneToClear&lt;/modifiedWriteValues&gt;\n          &lt;writeConstraint&gt;\n            &lt;writeAsRead&gt;true&lt;/writeAsRead&gt;\n          &lt;/writeConstraint&gt;\n          &lt;readAction&gt;modify&lt;/readAction&gt;\n          &lt;fields&gt;\n            &lt;field&gt;\n              &lt;name&gt;FieldA&lt;/name&gt;\n              &lt;bitOffset&gt;0&lt;/bitOffset&gt;\n              &lt;bitWidth&gt;3&lt;/bitWidth&gt;\n            &lt;/field&gt;\n          &lt;/fields&gt;\n        &lt;/register&gt;\n        &lt;register derivedFrom=\"RegisterA\"&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;displayName&gt;RegisterB&lt;/displayName&gt;\n          &lt;addressOffset&gt;0x2&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_size_inheritance_and_adjustment.html","title":"test_size_inheritance_and_adjustment","text":"<p>Contrary to what is defined in the CMSIS SVD standard, in <code>svdconv</code> the inheritance and adjustment of register sizes follow a specific algorithm based on implicit and explicit size definitions at different levels. The calculation of the effective size involves both explicit definitions and inheritance from higher levels, following a recursive approach to determine the maximum size within each level. Here's how the algorithm works:</p> <p>For each peripheral, if clusters are present, they are resolved from the inside out, starting with the innermost clusters (where children are only registers). Each cluster is examined by iterating through all of its children\u2014either registers or subclusters. The effective size for a register is either explicitly defined or inherited from a higher level, such as from the cluster, peripheral, or ultimately the device level. If no explicit size is defined, it inherits the size from the levels above, taking the first size that is found while traversing upwards. If this traversal reaches the device level and no size is defined there either, the size is set to 32 bits by default.</p> <p>For a given cluster, its size is determined by finding the maximum size among all of its children, including both registers and subclusters.</p> <p>This process is repeated recursively, starting with the innermost clusters and moving outward to determine the size of the parent clusters. Finally, the peripheral's size is calculated by taking the maximum size among all of its direct children, including clusters and registers. This approach ensures that the effective size of a peripheral is determined based on the largest size found in its entire hierarchy.</p> Python code that demonstrates the algorithm (click to expand)  ```python from dataclasses import dataclass, field  @dataclass(kw_only=True) class Device: size: None | int = None name: str peripherals: list[\"Peripheral\"] = field(default_factory=list)  @dataclass(kw_only=True) class Peripheral: size: None | int = None name: str registers_clusters: list[\"Register | Cluster\"] = field(default_factory=list) parent: Device  @dataclass(kw_only=True) class Cluster: size: None | int = None name: str registers_clusters: list[\"Register | Cluster\"] = field(default_factory=list) parent: \"Cluster | Peripheral\"  @dataclass(kw_only=True) class Register: size: None | int = None name: str parent: \"Cluster | Peripheral\"  def resolve_size_over_levels(peripheral: Peripheral) -&gt; int: # Start resolving the size for the peripheral by examining all its children inherited_size = resolve_inherited_size(peripheral) effective_size = inherited_size  for element in peripheral.registers_clusters: child_size = resolve_size(element, inherited_size) effective_size = max(effective_size, child_size)  peripheral.size = effective_size return effective_size  def resolve_size(element: Register | Cluster, inherited_size: int) -&gt; int: # Determine effective size for Register or Cluster if isinstance(element, Register): return element.size if element.size is not None else inherited_size  if isinstance(element, Cluster): return resolve_cluster_size(element)  raise ValueError(\"Element must be either Register or Cluster\")  def resolve_cluster_size(cluster: Cluster) -&gt; int: # Start resolving the size for the cluster by examining all its children cluster_inherited_size = resolve_inherited_size(cluster) effective_size = cluster_inherited_size  for child in cluster.registers_clusters: child_size = resolve_size(child, cluster_inherited_size) effective_size = max(effective_size, child_size)  cluster.size = effective_size return effective_size  def resolve_inherited_size(element: Peripheral | Cluster | Register) -&gt; int: # Traverse upwards to find the first defined size, or return 32 if no size is defined current = element.parent while current is not None: if current.size is not None: return current.size current = getattr(current, \"parent\", None) return 32 # Default to 32 if no size is found in any parent level  # Example usage: def print_hierarchy(element: Peripheral | Cluster | Register, path: str = \"\"): if isinstance(element, Peripheral): path += element.name print(f\"{path} (size: {element.size})\") for child in element.registers_clusters: print_hierarchy(child, path + \".\") elif isinstance(element, Cluster): path += element.name print(f\"{path} (size: {element.size})\") for child in element.registers_clusters: print_hierarchy(child, path + \".\") elif isinstance(element, Register): path += element.name print(f\"{path} (size: {element.size})\") else: raise ValueError(\"Element must be either Peripheral, Cluster or Register\")  device = Device(name=\"DeviceA\") peripheral_a = Peripheral(name=\"PeripheralA\", parent=device)  cluster_a = Cluster(name=\"ClusterA\", parent=peripheral_a) register_a = Register(name=\"RegisterA\", parent=cluster_a) register_b = Register(name=\"RegisterB\", parent=cluster_a) cluster_b = Cluster(name=\"ClusterB\", parent=cluster_a) register_a_in_cluster_b = Register(name=\"RegisterA\", parent=cluster_b) register_b_in_cluster_b = Register(name=\"RegisterB\", size=64, parent=cluster_b) cluster_b.registers_clusters.extend([register_a_in_cluster_b, register_b_in_cluster_b]) cluster_a.registers_clusters.extend([register_a, register_b, cluster_b])  cluster_c = Cluster(name=\"ClusterC\", parent=peripheral_a) register_a_in_cluster_c = Register(name=\"RegisterA\", parent=cluster_c) register_b_in_cluster_c = Register(name=\"RegisterB\", parent=cluster_c) cluster_c.registers_clusters.extend([register_a_in_cluster_c, register_b_in_cluster_c])  register_a_in_peripheral = Register(name=\"RegisterA\", parent=peripheral_a)  peripheral_a.registers_clusters.extend([cluster_a, cluster_c, register_a_in_peripheral]) device.peripherals.append(peripheral_a)  # Resolve sizes and print hierarchy resolve_size_over_levels(peripheral_a) print_hierarchy(peripheral_a) ```"},{"location":"test_size_inheritance_and_adjustment.html#tests.test_process.test_size_inheritance_and_adjustment.test_complex_size_adjustment","title":"<code>test_complex_size_adjustment</code>","text":"<p>This test examines how the parser handles more intricate scenarios of size inheritance and adjustments across clusters and registers within a peripheral. The SVD file contains clusters and registers with varying degrees of explicit and implicit size definitions. The parser must determine the correct effective sizes based on size inheritance rules and adjustments at different levels. In this case, the sizes within the clusters and registers are adjusted, either explicitly or inherited, following a recursive calculation of the maximum effective size.</p> <p>Expected Outcome: The parser should process the file without errors, correctly inheriting and adjusting sizes across clusters and registers. ClusterA, which has no explicit size defined, should have its size adjusted to 64 bits, inherited from ClusterB and its child registers. Both <code>RegisterA</code> and <code>RegisterB</code> within ClusterA should also have effective sizes of 64 bits. Similarly, ClusterB should inherit a size of 64 bits from its children, while ClusterC, which also lacks an explicit size, should have a final size of 32 bits, based on its child registers, which inherit the size implicitly from device level (default value). Since the size adjustment for ClusterC is executed before the final size adjustment for PeripheralA, at this point of time, no size is set for PeripheralA. Finally, PeripheralA should adjust its size to 64 bits, reflecting the largest size found in its children. The parser should handle all these size adjustments and inheritance steps accurately, consistent with the behavior of <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_size_inheritance_and_adjustment.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_complex_size_adjustment(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test examines how the parser handles more intricate scenarios of size inheritance and adjustments across\n    clusters and registers within a peripheral. The SVD file contains clusters and registers with varying degrees\n    of explicit and implicit size definitions. The parser must determine the correct effective sizes based on size\n    inheritance rules and adjustments at different levels. In this case, the sizes within the clusters and\n    registers are adjusted, either explicitly or inherited, following a recursive calculation of the maximum\n    effective size.\n\n    **Expected Outcome:** The parser should process the file without errors, correctly inheriting and adjusting sizes\n    across clusters and registers. ClusterA, which has no explicit size defined, should have its size adjusted to\n    64 bits, inherited from ClusterB and its child registers. Both `RegisterA` and `RegisterB` within ClusterA\n    should also have effective sizes of 64 bits. Similarly, ClusterB should inherit a size of 64 bits from its\n    children, while ClusterC, which also lacks an explicit size, should have a final size of 32 bits, based on its\n    child registers, which inherit the size implicitly from device level (default value). Since the size\n    adjustment for ClusterC is executed before the final size adjustment for PeripheralA, at this point of time,\n    no size is set for PeripheralA. Finally, PeripheralA should adjust its size to 64 bits, reflecting the largest\n    size found in its children. The parser should handle all these size adjustments and inheritance steps\n    accurately, consistent with the behavior of `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"size_inheritance_and_adjustment/complex_size_adjustment.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 3\n\n    cluster_a = device.peripherals[0].registers_clusters[0]\n    assert isinstance(cluster_a, Cluster)\n    assert cluster_a.name == \"ClusterA\"\n    assert cluster_a.address_offset == 0x0\n    assert cluster_a.size == 64  # not set, size adjustment results in 64 from ClusterB\n    assert len(cluster_a.registers_clusters) == 3\n\n    assert isinstance(cluster_a.registers_clusters[0], Register)\n    assert cluster_a.registers_clusters[0].name == \"RegisterA\"\n    assert cluster_a.registers_clusters[0].address_offset == 0x0\n    assert cluster_a.registers_clusters[0].size == 64  # not set, effective size results in 64 from ClusterA\n\n    assert isinstance(cluster_a.registers_clusters[1], Register)\n    assert cluster_a.registers_clusters[1].name == \"RegisterB\"\n    assert cluster_a.registers_clusters[1].address_offset == 0x8\n    assert cluster_a.registers_clusters[1].size == 64  # not set, effective size results in 64 from ClusterA\n\n    cluster_b = cluster_a.registers_clusters[2]\n    assert isinstance(cluster_b, Cluster)\n    assert cluster_b.name == \"ClusterB\"\n    assert cluster_b.address_offset == 0x10\n    assert cluster_b.size == 64  # not set, size adjustment results in 64 from RegisterB\n    assert len(cluster_b.registers_clusters) == 2\n\n    assert isinstance(cluster_b.registers_clusters[0], Register)\n    assert cluster_b.registers_clusters[0].name == \"RegisterA\"\n    assert cluster_b.registers_clusters[0].address_offset == 0x0\n    assert cluster_b.registers_clusters[0].size == 64  # not set, effective size results in 64 from ClusterB\n\n    assert isinstance(cluster_b.registers_clusters[1], Register)\n    assert cluster_b.registers_clusters[1].name == \"RegisterB\"\n    assert cluster_b.registers_clusters[1].address_offset == 0x8\n    assert cluster_b.registers_clusters[1].size == 64  # explicitly set to 64\n\n    cluster_c = device.peripherals[0].registers_clusters[1]\n    assert isinstance(cluster_c, Cluster)\n    assert cluster_c.name == \"ClusterC\"\n    assert cluster_c.address_offset == 0x20\n    assert cluster_c.size == 32  # not set, size adjustment results implicit in 32 from RegisterA and RegisterB\n    assert len(cluster_c.registers_clusters) == 2\n\n    assert isinstance(cluster_c.registers_clusters[0], Register)\n    assert cluster_c.registers_clusters[0].name == \"RegisterA\"\n    assert cluster_c.registers_clusters[0].address_offset == 0x0\n    assert cluster_c.registers_clusters[0].size == 32  # not set, effective size results in 32 from ClusterC size\n\n    assert isinstance(cluster_c.registers_clusters[1], Register)\n    assert cluster_c.registers_clusters[1].name == \"RegisterB\"\n    assert cluster_c.registers_clusters[1].address_offset == 0x8\n    assert cluster_c.registers_clusters[1].size == 32  # not set, effective size results in 32 from ClusterC size\n\n    assert isinstance(device.peripherals[0].registers_clusters[2], Register)\n    assert device.peripherals[0].registers_clusters[2].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[2].address_offset == 0x30\n    assert device.peripherals[0].registers_clusters[2].size == 64  # not set, ef. size results in 64 from peripheral\n</code></pre> SVD file: <code>size_inheritance_and_adjustment/complex_size_adjustment.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;complex_size_adjustment&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterA&lt;/name&gt;\n          &lt;description&gt;ClusterA description&lt;/description&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;cluster&gt;\n            &lt;name&gt;ClusterB&lt;/name&gt;\n            &lt;description&gt;ClusterB description&lt;/description&gt;\n            &lt;addressOffset&gt;0x10&lt;/addressOffset&gt;\n            &lt;register&gt;\n              &lt;name&gt;RegisterA&lt;/name&gt;\n              &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n            &lt;/register&gt;\n            &lt;register&gt;\n              &lt;name&gt;RegisterB&lt;/name&gt;\n              &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n              &lt;size&gt;64&lt;/size&gt;\n            &lt;/register&gt;\n          &lt;/cluster&gt;\n        &lt;/cluster&gt;\n        &lt;cluster&gt;\n          &lt;name&gt;ClusterC&lt;/name&gt;\n          &lt;description&gt;ClusterC description&lt;/description&gt;\n          &lt;addressOffset&gt;0x20&lt;/addressOffset&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterA&lt;/name&gt;\n            &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n          &lt;/register&gt;\n          &lt;register&gt;\n            &lt;name&gt;RegisterB&lt;/name&gt;\n            &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n          &lt;/register&gt;\n        &lt;/cluster&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x30&lt;/addressOffset&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_size_inheritance_and_adjustment.html#tests.test_process.test_size_inheritance_and_adjustment.test_overlap_due_to_size_adjustment","title":"<code>test_overlap_due_to_size_adjustment</code>","text":"<p>This test verifies how the parser handles size adjustments that lead to register overlaps. The SVD file contains a peripheral where the size inheritance and adjustment algorithm causes an overlap between two registers. Specifically, <code>PeripheralA</code> starts with a defined size of 32 bits, but the effective size is adjusted to 64 bits due to the size of <code>RegisterB</code>. <code>RegisterA</code>, which does not have an explicit size, inherits its size from the peripheral, leading to an overlap with <code>RegisterB</code>, which has an address offset of 0x4.</p> <p>Expected Outcome: The parser should process the file and issue a warning about the overlap caused by the size adjustment. <code>PeripheralA</code> should have a final size of 64 bits, overriding the original size of 32 bits due to the size of <code>RegisterB</code>. <code>RegisterA</code>, which does not have a size defined, should inherit the size from <code>PeripheralA</code> and have a final size of 64 bits. This leads to an overlap with <code>RegisterB</code>, whose size is explicitly set to 64 bits, starting at address offset 0x4. The parser should handle this case by adjusting the sizes correctly and raising a warning due to the overlap, similar to the behavior in <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_size_inheritance_and_adjustment.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_overlap_due_to_size_adjustment(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test verifies how the parser handles size adjustments that lead to register overlaps. The SVD file\n    contains a peripheral where the size inheritance and adjustment algorithm causes an overlap between two\n    registers. Specifically, `PeripheralA` starts with a defined size of 32 bits, but the effective size is\n    adjusted to 64 bits due to the size of `RegisterB`. `RegisterA`, which does not have an explicit size,\n    inherits its size from the peripheral, leading to an overlap with `RegisterB`, which has an address offset of\n    0x4.\n\n    **Expected Outcome:** The parser should process the file and issue a warning about the overlap caused by the size\n    adjustment. `PeripheralA` should have a final size of 64 bits, overriding the original size of 32 bits due to\n    the size of `RegisterB`. `RegisterA`, which does not have a size defined, should inherit the size from\n    `PeripheralA` and have a final size of 64 bits. This leads to an overlap with `RegisterB`, whose size is\n    explicitly set to 64 bits, starting at address offset 0x4. The parser should handle this case by adjusting the\n    sizes correctly and raising a warning due to the overlap, similar to the behavior in `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    with pytest.warns(ProcessWarning):\n        device = get_processed_device_from_testfile(\n            \"size_inheritance_and_adjustment/overlap_due_to_size_adjustment.svd\"\n        )\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n    assert device.peripherals[0].size == 64  # explicitly set to 32, adjustment overwrite to 64 from RegisterB\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 64  # not set, ef. size results in 64 (PeripheralA)\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x4\n    assert device.peripherals[0].registers_clusters[1].size == 64  # explicitly set to 64\n</code></pre> SVD file: <code>size_inheritance_and_adjustment/overlap_due_to_size_adjustment.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;overlap_due_to_size_adjustment&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n    &lt;name&gt;CM0&lt;/name&gt;\n    &lt;revision&gt;r0p0&lt;/revision&gt;\n    &lt;endian&gt;little&lt;/endian&gt;\n    &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n    &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n    &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n    &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n    &lt;peripheral&gt;\n      &lt;name&gt;PeripheralA&lt;/name&gt;\n      &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n      &lt;size&gt;32&lt;/size&gt;\n      &lt;addressBlock&gt;\n        &lt;offset&gt;0x0&lt;/offset&gt;\n        &lt;size&gt;0x1000&lt;/size&gt;\n        &lt;usage&gt;registers&lt;/usage&gt;\n      &lt;/addressBlock&gt;\n      &lt;registers&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterA&lt;/name&gt;\n          &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n        &lt;/register&gt;\n        &lt;register&gt;\n          &lt;name&gt;RegisterB&lt;/name&gt;\n          &lt;addressOffset&gt;0x4&lt;/addressOffset&gt;\n          &lt;size&gt;64&lt;/size&gt;\n        &lt;/register&gt;\n      &lt;/registers&gt;\n    &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"},{"location":"test_size_inheritance_and_adjustment.html#tests.test_process.test_size_inheritance_and_adjustment.test_simple_size_adjustment","title":"<code>test_simple_size_adjustment</code>","text":"<p>This test evaluates how the parser handles simple size inheritance and explicit size adjustments within a peripheral. In this scenario, the peripheral has both implicit and explicit size definitions, and the parser must adjust these sizes based on the rules described. Specifically, <code>RegisterA</code> has no explicit size set, so it should inherit the size from the peripheral level, while <code>RegisterB</code> has an explicit size defined. <code>svdconv</code> processes this file correctly, applying size adjustments based on the highest level's explicit settings.</p> <p>Expected Outcome: The parser should correctly adjust the sizes, processing the SVD file without errors. The peripheral should have two registers, <code>RegisterA</code> and <code>RegisterB</code>. The overall size of the peripheral should be set to 64 bits, which overrides the explicit 16-bit setting due to size adjustments. <code>RegisterA</code>, with no explicit size set, should inherit the peripheral's size and be 64 bits. <code>RegisterB</code>, which explicitly has a size of 64 bits, should retain this size. The parser should process the inheritance and size adjustment algorithm correctly, reflecting the behavior of <code>svdconv</code>.</p> <p>Processable with svdconv: yes</p> Source code in <code>tests/test_process/test_size_inheritance_and_adjustment.py</code> <pre><code>@pytest.mark.filterwarnings(\"error::svdsuite.process.ProcessWarning\")\ndef test_simple_size_adjustment(get_processed_device_from_testfile: Callable[[str], Device]):\n    \"\"\"\n    This test evaluates how the parser handles simple size inheritance and explicit size adjustments within a\n    peripheral. In this scenario, the peripheral has both implicit and explicit size definitions, and the parser\n    must adjust these sizes based on the rules described. Specifically, `RegisterA` has no explicit size set, so\n    it should inherit the size from the peripheral level, while `RegisterB` has an explicit size defined.\n    `svdconv` processes this file correctly, applying size adjustments based on the highest level's explicit\n    settings.\n\n    **Expected Outcome:** The parser should correctly adjust the sizes, processing the SVD file without errors. The\n    peripheral should have two registers, `RegisterA` and `RegisterB`. The overall size of the peripheral should\n    be set to 64 bits, which overrides the explicit 16-bit setting due to size adjustments. `RegisterA`, with no\n    explicit size set, should inherit the peripheral's size and be 64 bits. `RegisterB`, which explicitly has a\n    size of 64 bits, should retain this size. The parser should process the inheritance and size adjustment\n    algorithm correctly, reflecting the behavior of `svdconv`.\n\n    **Processable with svdconv:** yes\n    \"\"\"\n\n    device = get_processed_device_from_testfile(\"size_inheritance_and_adjustment/simple_size_adjustment.svd\")\n\n    assert len(device.peripherals) == 1\n    assert len(device.peripherals[0].registers_clusters) == 2\n    assert device.peripherals[0].size == 64  # explicitly set to 16, adjustment overwrite to 64\n\n    assert isinstance(device.peripherals[0].registers_clusters[0], Register)\n    assert device.peripherals[0].registers_clusters[0].name == \"RegisterA\"\n    assert device.peripherals[0].registers_clusters[0].address_offset == 0x0\n    assert device.peripherals[0].registers_clusters[0].size == 64  # not set, effective size results in 64\n\n    assert isinstance(device.peripherals[0].registers_clusters[1], Register)\n    assert device.peripherals[0].registers_clusters[1].name == \"RegisterB\"\n    assert device.peripherals[0].registers_clusters[1].address_offset == 0x8\n    assert device.peripherals[0].registers_clusters[1].size == 64  # explicitly set to 64\n</code></pre> SVD file: <code>size_inheritance_and_adjustment/simple_size_adjustment.svd</code><pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;device xmlns:xs=\"http://www.w3.org/2001/XMLSchema-instance\" xs:noNamespaceSchemaLocation=\"CMSIS-SVD.xsd\" schemaVersion=\"1.3\"&gt;\n  &lt;name&gt;simple_size_adjustment&lt;/name&gt;\n  &lt;version&gt;1.0&lt;/version&gt;\n  &lt;description&gt;Test_Example device&lt;/description&gt;\n  &lt;cpu&gt;\n  &lt;name&gt;CM0&lt;/name&gt;\n  &lt;revision&gt;r0p0&lt;/revision&gt;\n  &lt;endian&gt;little&lt;/endian&gt;\n  &lt;mpuPresent&gt;false&lt;/mpuPresent&gt;\n  &lt;fpuPresent&gt;false&lt;/fpuPresent&gt;\n  &lt;nvicPrioBits&gt;4&lt;/nvicPrioBits&gt;\n  &lt;vendorSystickConfig&gt;false&lt;/vendorSystickConfig&gt;\n  &lt;/cpu&gt;\n  &lt;addressUnitBits&gt;8&lt;/addressUnitBits&gt;\n  &lt;width&gt;32&lt;/width&gt;\n  &lt;peripherals&gt;\n  &lt;peripheral&gt;\n    &lt;name&gt;PeripheralA&lt;/name&gt;\n    &lt;baseAddress&gt;0x40001000&lt;/baseAddress&gt;\n    &lt;size&gt;16&lt;/size&gt;\n    &lt;addressBlock&gt;\n    &lt;offset&gt;0x0&lt;/offset&gt;\n    &lt;size&gt;0x1000&lt;/size&gt;\n    &lt;usage&gt;registers&lt;/usage&gt;\n    &lt;/addressBlock&gt;\n    &lt;registers&gt;\n    &lt;register&gt;\n      &lt;name&gt;RegisterA&lt;/name&gt;\n      &lt;addressOffset&gt;0x0&lt;/addressOffset&gt;\n    &lt;/register&gt;\n    &lt;register&gt;\n      &lt;name&gt;RegisterB&lt;/name&gt;\n      &lt;addressOffset&gt;0x8&lt;/addressOffset&gt;\n      &lt;size&gt;64&lt;/size&gt;\n    &lt;/register&gt;\n    &lt;/registers&gt;\n  &lt;/peripheral&gt;\n  &lt;/peripherals&gt;\n&lt;/device&gt;\n</code></pre>"}]}